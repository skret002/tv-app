/**
* @module vue-mdc-adapterdrawer 0.15.4
* @exports VueMDCDrawer
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.35.2"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.VueMDCDrawer = factory());
}(this, (function () { 'use strict';

    function autoInit(plugin) {
      // Auto-install
      var _Vue = null;
      if (typeof window !== 'undefined') {
        _Vue = window.Vue;
      } else if (typeof global !== 'undefined') {
        /*global global*/
        _Vue = global.Vue;
      }
      if (_Vue) {
        _Vue.use(plugin);
      }
    }

    function BasePlugin(components) {
      return {
        version: '0.15.4',
        install: function install(vm) {
          for (var key in components) {
            var component = components[key];
            vm.component(component.name, component);
          }
        },
        components: components
      };
    }

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    var get = function get(object, property, receiver) {
      if (object === null) object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);

      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);

        if (parent === null) {
          return undefined;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;

        if (getter === undefined) {
          return undefined;
        }

        return getter.call(receiver);
      }
    };

    var inherits = function (subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };

    var possibleConstructorReturn = function (self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };

    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      } else {
        return Array.from(arr);
      }
    };

    var CustomLink = {
      name: 'custom-link',
      functional: true,
      props: {
        tag: { type: String, default: 'a' },
        link: Object
      },
      render: function render(h, context) {
        var element = void 0;
        var data = _extends({}, context.data);

        if (context.props.link && context.parent.$router) {
          // router-link case
          element = context.parent.$root.$options.components['router-link'];
          data.props = _extends({ tag: context.props.tag }, context.props.link);
          if (data.on.click) {
            data.nativeOn = { click: data.on.click };
          }
        } else {
          // element fallback
          element = context.props.tag;
        }

        return h(element, data, context.children);
      }
    };

    var CustomLinkMixin = {
      props: {
        to: [String, Object],
        exact: Boolean,
        append: Boolean,
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String
      },
      computed: {
        link: function link() {
          return this.to && {
            to: this.to,
            exact: this.exact,
            append: this.append,
            replace: this.replace,
            activeClass: this.activeClass,
            exactActiveClass: this.exactActiveClass
          };
        }
      },
      components: {
        CustomLink: CustomLink
      }
    };

    /* global CustomEvent */

    var DispatchEventMixin = {
      props: {
        event: String,
        'event-target': Object,
        'event-args': Array
      },
      methods: {
        dispatchEvent: function dispatchEvent(evt) {
          evt && this.$emit(evt.type, evt);
          if (this.event) {
            var target = this.eventTarget || this.$root;
            var args = this.eventArgs || [];
            target.$emit.apply(target, [this.event].concat(toConsumableArray(args)));
          }
        }
      },
      computed: {
        listeners: function listeners() {
          var _this = this;

          return _extends({}, this.$listeners, {
            click: function click(e) {
              return _this.dispatchEvent(e);
            }
          });
        }
      }
    };

    var mdcPermanentDrawer = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-permanent-drawer mdc-drawer--permanent mdc-typography" }, [_c('nav', { staticClass: "mdc-drawer__content" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
      }, staticRenderFns: [],
      name: 'mdc-permanent-drawer',
      props: {
        'toolbar-spacer': Boolean
      }
    };

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation = function () {
      createClass(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get$$1() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }

        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get$$1() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }

        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get$$1() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }

        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get$$1() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }

        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        classCallCheck(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      createClass(MDCFoundation, [{
        key: "init",
        value: function init() {
          // Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);
      return MDCFoundation;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template F
     */

    var MDCComponent = function () {
      createClass(MDCComponent, null, [{
        key: 'attachTo',

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation());
        }

        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        classCallCheck(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args);
        // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.
        /** @protected {!F} */
        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      createClass(MDCComponent, [{
        key: 'initialize',
        value: function initialize() /* ...args */{}
        // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.


        /**
         * @return {!F} foundation
         */

      }, {
        key: 'getDefaultFoundation',
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: 'initialSyncWithDOM',
        value: function initialSyncWithDOM() {
          // Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }

        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: 'listen',
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }

        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: 'unlisten',
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }

        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: 'emit',
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          var evt = void 0;
          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);
      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
      inherits(MDCSlidableDrawerFoundation, _MDCFoundation);
      createClass(MDCSlidableDrawerFoundation, null, [{
        key: 'defaultAdapter',
        get: function get$$1() {
          return {
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            hasClass: function hasClass() /* className: string */{},
            hasNecessaryDom: function hasNecessaryDom() {
              return (/* boolean */false
              );
            },
            registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
            deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
            registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
            deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
            registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
            deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
            registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
            deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
            setTranslateX: function setTranslateX() /* value: number | null */{},
            getFocusableElements: function getFocusableElements() /* NodeList */{},
            saveElementTabState: function saveElementTabState() /* el: Element */{},
            restoreElementTabState: function restoreElementTabState() /* el: Element */{},
            makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
            notifyOpen: function notifyOpen() {},
            notifyClose: function notifyClose() {},
            isRtl: function isRtl() {
              return (/* boolean */false
              );
            },
            getDrawerWidth: function getDrawerWidth() {
              return (/* number */0
              );
            }
          };
        }
      }]);

      function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
        classCallCheck(this, MDCSlidableDrawerFoundation);

        var _this = possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, _extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

        _this.rootCssClass_ = rootCssClass;
        _this.animatingCssClass_ = animatingCssClass;
        _this.openCssClass_ = openCssClass;

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd_(evt);
        };

        _this.inert_ = false;

        _this.componentTouchStartHandler_ = function (evt) {
          return _this.handleTouchStart_(evt);
        };
        _this.componentTouchMoveHandler_ = function (evt) {
          return _this.handleTouchMove_(evt);
        };
        _this.componentTouchEndHandler_ = function (evt) {
          return _this.handleTouchEnd_(evt);
        };
        _this.documentKeydownHandler_ = function (evt) {
          if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
            _this.close();
          }
        };
        return _this;
      }

      createClass(MDCSlidableDrawerFoundation, [{
        key: 'init',
        value: function init() {
          var ROOT = this.rootCssClass_;
          var OPEN = this.openCssClass_;

          if (!this.adapter_.hasClass(ROOT)) {
            throw new Error(ROOT + ' class required in root element.');
          }

          if (!this.adapter_.hasNecessaryDom()) {
            throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
          }

          if (this.adapter_.hasClass(OPEN)) {
            this.isOpen_ = true;
          } else {
            this.detabinate_();
            this.isOpen_ = false;
          }

          this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
          this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
          this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
          this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
          this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
          // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
          this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        }
      }, {
        key: 'open',
        value: function open() {
          this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.addClass(this.animatingCssClass_);
          this.adapter_.addClass(this.openCssClass_);
          this.retabinate_();
          // Debounce multiple calls
          if (!this.isOpen_) {
            this.adapter_.notifyOpen();
          }
          this.isOpen_ = true;
        }
      }, {
        key: 'close',
        value: function close() {
          this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.addClass(this.animatingCssClass_);
          this.adapter_.removeClass(this.openCssClass_);
          this.detabinate_();
          // Debounce multiple calls
          if (this.isOpen_) {
            this.adapter_.notifyClose();
          }
          this.isOpen_ = false;
        }
      }, {
        key: 'isOpen',
        value: function isOpen() {
          return this.isOpen_;
        }

        /**
         *  Render all children of the drawer inert when it's closed.
         */

      }, {
        key: 'detabinate_',
        value: function detabinate_() {
          if (this.inert_) {
            return;
          }

          var elements = this.adapter_.getFocusableElements();
          if (elements) {
            for (var i = 0; i < elements.length; i++) {
              this.adapter_.saveElementTabState(elements[i]);
              this.adapter_.makeElementUntabbable(elements[i]);
            }
          }

          this.inert_ = true;
        }

        /**
         *  Make all children of the drawer tabbable again when it's open.
         */

      }, {
        key: 'retabinate_',
        value: function retabinate_() {
          if (!this.inert_) {
            return;
          }

          var elements = this.adapter_.getFocusableElements();
          if (elements) {
            for (var i = 0; i < elements.length; i++) {
              this.adapter_.restoreElementTabState(elements[i]);
            }
          }

          this.inert_ = false;
        }
      }, {
        key: 'handleTouchStart_',
        value: function handleTouchStart_(evt) {
          if (!this.adapter_.hasClass(this.openCssClass_)) {
            return;
          }
          if (evt.pointerType && evt.pointerType !== 'touch') {
            return;
          }

          this.direction_ = this.adapter_.isRtl() ? -1 : 1;
          this.drawerWidth_ = this.adapter_.getDrawerWidth();
          this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
          this.currentX_ = this.startX_;

          this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
        }
      }, {
        key: 'handleTouchMove_',
        value: function handleTouchMove_(evt) {
          if (evt.pointerType && evt.pointerType !== 'touch') {
            return;
          }

          this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
        }
      }, {
        key: 'handleTouchEnd_',
        value: function handleTouchEnd_(evt) {
          if (evt.pointerType && evt.pointerType !== 'touch') {
            return;
          }

          this.prepareForTouchEnd_();

          // Did the user close the drawer by more than 50%?
          if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
            this.close();
          } else {
            // Triggering an open here means we'll get a nice animation back to the fully open state.
            this.open();
          }
        }
      }, {
        key: 'prepareForTouchEnd_',
        value: function prepareForTouchEnd_() {
          cancelAnimationFrame(this.updateRaf_);
          this.adapter_.setTranslateX(null);
        }
      }, {
        key: 'updateDrawer_',
        value: function updateDrawer_() {
          this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
          this.adapter_.setTranslateX(this.newPosition_);
        }
      }, {
        key: 'isRootTransitioningEventTarget_',
        value: function isRootTransitioningEventTarget_() {
          // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
          // if the event target is the root event target currently transitioning.
          return false;
        }
      }, {
        key: 'handleTransitionEnd_',
        value: function handleTransitionEnd_(evt) {
          if (this.isRootTransitioningEventTarget_(evt.target)) {
            this.adapter_.removeClass(this.animatingCssClass_);
            this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
          }
        }
      }, {
        key: 'newPosition_',
        get: function get$$1() {
          var newPos = null;

          if (this.direction_ === 1) {
            newPos = Math.min(0, this.currentX_ - this.startX_);
          } else {
            newPos = Math.max(0, this.currentX_ - this.startX_);
          }

          return newPos;
        }
      }]);
      return MDCSlidableDrawerFoundation;
    }(MDCFoundation);

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var cssClasses = {
      ROOT: 'mdc-drawer--persistent',
      OPEN: 'mdc-drawer--open',
      ANIMATING: 'mdc-drawer--animating'
    };

    var strings = {
      DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
      FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
      OPEN_EVENT: 'MDCPersistentDrawer:open',
      CLOSE_EVENT: 'MDCPersistentDrawer:close'
    };

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
      inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);
      createClass(MDCPersistentDrawerFoundation, null, [{
        key: 'cssClasses',
        get: function get$$1() {
          return cssClasses;
        }
      }, {
        key: 'strings',
        get: function get$$1() {
          return strings;
        }
      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
            isDrawer: function isDrawer() {
              return false;
            }
          });
        }
      }]);

      function MDCPersistentDrawerFoundation(adapter) {
        classCallCheck(this, MDCPersistentDrawerFoundation);
        return possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, _extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
      }

      createClass(MDCPersistentDrawerFoundation, [{
        key: 'isRootTransitioningEventTarget_',
        value: function isRootTransitioningEventTarget_(el) {
          return this.adapter_.isDrawer(el);
        }
      }]);
      return MDCPersistentDrawerFoundation;
    }(MDCSlidableDrawerFoundation);

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var TAB_DATA = 'data-mdc-tabindex';
    var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

    var storedTransformPropertyName_ = void 0;
    var supportsPassive_$1 = void 0;

    // Remap touch events to pointer events, if the browser doesn't support touch events.
    function remapEvent(eventName) {
      var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

      if (!('ontouchstart' in globalObj.document)) {
        switch (eventName) {
          case 'touchstart':
            return 'pointerdown';
          case 'touchmove':
            return 'pointermove';
          case 'touchend':
            return 'pointerup';
          default:
            return eventName;
        }
      }

      return eventName;
    }

    // Choose the correct transform property to use on the current browser.
    function getTransformPropertyName() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (storedTransformPropertyName_ === undefined || forceRefresh) {
        var el = globalObj.document.createElement('div');
        var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
        storedTransformPropertyName_ = transformPropertyName;
      }

      return storedTransformPropertyName_;
    }

    // Determine whether the current browser supports CSS properties.
    function supportsCssCustomProperties() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

      if ('CSS' in globalObj) {
        return globalObj.CSS.supports('(--color: red)');
      }
      return false;
    }

    // Determine whether the current browser supports passive event listeners, and if so, use them.
    function applyPassive$1() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$1 === undefined || forceRefresh) {
        var isSupported = false;
        try {
          globalObj.document.addEventListener('test', null, { get passive() {
              isSupported = true;
            } });
        } catch (e) {}

        supportsPassive_$1 = isSupported;
      }

      return supportsPassive_$1 ? { passive: true } : false;
    }

    // Save the tab state for an element.
    function saveElementTabState(el) {
      if (el.hasAttribute('tabindex')) {
        el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
      }
      el.setAttribute(TAB_DATA_HANDLED, true);
    }

    // Restore the tab state for an element, if it was saved.
    function restoreElementTabState(el) {
      // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
      if (el.hasAttribute(TAB_DATA_HANDLED)) {
        if (el.hasAttribute(TAB_DATA)) {
          el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
          el.removeAttribute(TAB_DATA);
        } else {
          el.removeAttribute('tabindex');
        }
        el.removeAttribute(TAB_DATA_HANDLED);
      }
    }

    var mdcPersistentDrawer = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-persistent-drawer mdc-drawer--persistent mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
      }, staticRenderFns: [],
      name: 'mdc-persistent-drawer',
      model: {
        prop: 'open',
        event: 'change'
      },
      props: {
        'toolbar-spacer': Boolean,
        open: Boolean
      },
      data: function data() {
        return {
          classes: {}
        };
      },

      watch: {
        open: '_refresh'
      },
      mounted: function mounted() {
        var _this = this;

        var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


        this.foundation = new MDCPersistentDrawerFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.classes, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.classes, className);
          },
          hasClass: function hasClass(className) {
            return _this.$el.classList.contains(className);
          },
          hasNecessaryDom: function hasNecessaryDom() {
            return !!_this.$refs.drawer;
          },
          registerInteractionHandler: function registerInteractionHandler(evt, handler) {
            _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$1());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
            _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$1());
          },
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
            _this.$refs.drawer.addEventListener(remapEvent(evt), handler, applyPassive$1());
          },
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
            _this.$refs.drawer.removeEventListener(remapEvent(evt), handler, applyPassive$1());
          },
          registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
            _this.$refs.drawer.addEventListener('transitionend', handler);
          },
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
            _this.$refs.drawer.removeEventListener('transitionend', handler);
          },
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
            document.addEventListener('keydown', handler);
          },
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
            document.removeEventListener('keydown', handler);
          },
          getDrawerWidth: function getDrawerWidth() {
            return _this.$refs.drawer.offsetWidth;
          },
          setTranslateX: function setTranslateX(value) {
            _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
          },
          getFocusableElements: function getFocusableElements() {
            return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
          },
          saveElementTabState: function saveElementTabState$$1(el) {
            saveElementTabState(el);
          },
          restoreElementTabState: function restoreElementTabState$$1(el) {
            restoreElementTabState(el);
          },
          makeElementUntabbable: function makeElementUntabbable(el) {
            el.setAttribute('tabindex', -1);
          },
          notifyOpen: function notifyOpen() {
            _this.$emit('change', true);
            _this.$emit('open');
          },
          notifyClose: function notifyClose() {
            _this.$emit('change', false);
            _this.$emit('close');
          },
          isRtl: function isRtl() {
            /* global getComputedStyle */
            return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
          },
          isDrawer: function isDrawer(el) {
            return el === _this.$refs.drawer;
          }
        });
        this.foundation && this.foundation.init();
        this._refresh();
      },
      beforeDestroy: function beforeDestroy() {
        this.foundation && this.foundation.destroy();
        this.foundation = null;
      },

      methods: {
        _refresh: function _refresh() {
          if (this.open) {
            this.foundation && this.foundation.open();
          } else {
            this.foundation && this.foundation.close();
          }
        }
      }
    };

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var cssClasses$1 = {
      ROOT: 'mdc-drawer--temporary',
      OPEN: 'mdc-drawer--open',
      ANIMATING: 'mdc-drawer--animating',
      SCROLL_LOCK: 'mdc-drawer-scroll-lock'
    };

    var strings$1 = {
      DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
      OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
      FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
      OPEN_EVENT: 'MDCTemporaryDrawer:open',
      CLOSE_EVENT: 'MDCTemporaryDrawer:close'
    };

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
      inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);
      createClass(MDCTemporaryDrawerFoundation, null, [{
        key: 'cssClasses',
        get: function get$$1() {
          return cssClasses$1;
        }
      }, {
        key: 'strings',
        get: function get$$1() {
          return strings$1;
        }
      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
            addBodyClass: function addBodyClass() /* className: string */{},
            removeBodyClass: function removeBodyClass() /* className: string */{},
            isDrawer: function isDrawer() {
              return false;
            },
            updateCssVariable: function updateCssVariable() /* value: string */{},
            eventTargetHasClass: function eventTargetHasClass() {
              return (/* target: EventTarget, className: string */ /* boolean */false
              );
            }
          });
        }
      }]);

      function MDCTemporaryDrawerFoundation(adapter) {
        classCallCheck(this, MDCTemporaryDrawerFoundation);

        var _this = possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, _extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

        _this.componentClickHandler_ = function (evt) {
          if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$1.ROOT)) {
            _this.close(true);
          }
        };
        return _this;
      }

      createClass(MDCTemporaryDrawerFoundation, [{
        key: 'init',
        value: function init() {
          get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'init', this).call(this);

          // Make browser aware of custom property being used in this element.
          // Workaround for certain types of hard-to-reproduce heisenbugs.
          this.adapter_.updateCssVariable(0);
          this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'destroy', this).call(this);

          this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
          this.enableScroll_();
        }
      }, {
        key: 'open',
        value: function open() {
          this.disableScroll_();
          // Make sure custom property values are cleared before starting.
          this.adapter_.updateCssVariable('');

          get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'open', this).call(this);
        }
      }, {
        key: 'close',
        value: function close() {
          // Make sure custom property values are cleared before making any changes.
          this.adapter_.updateCssVariable('');

          get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'close', this).call(this);
        }
      }, {
        key: 'prepareForTouchEnd_',
        value: function prepareForTouchEnd_() {
          get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'prepareForTouchEnd_', this).call(this);

          this.adapter_.updateCssVariable('');
        }
      }, {
        key: 'updateDrawer_',
        value: function updateDrawer_() {
          get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'updateDrawer_', this).call(this);

          var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
          this.adapter_.updateCssVariable(newOpacity);
        }
      }, {
        key: 'isRootTransitioningEventTarget_',
        value: function isRootTransitioningEventTarget_(el) {
          return this.adapter_.isDrawer(el);
        }
      }, {
        key: 'handleTransitionEnd_',
        value: function handleTransitionEnd_(evt) {
          get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'handleTransitionEnd_', this).call(this, evt);
          if (!this.isOpen_) {
            this.enableScroll_();
          }
        }
      }, {
        key: 'disableScroll_',
        value: function disableScroll_() {
          this.adapter_.addBodyClass(cssClasses$1.SCROLL_LOCK);
        }
      }, {
        key: 'enableScroll_',
        value: function enableScroll_() {
          this.adapter_.removeBodyClass(cssClasses$1.SCROLL_LOCK);
        }
      }]);
      return MDCTemporaryDrawerFoundation;
    }(MDCSlidableDrawerFoundation);

    var mdcTemporaryDrawer = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-temporary-drawer mdc-drawer--temporary mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
      }, staticRenderFns: [],
      name: 'mdc-temporary-drawer',
      model: {
        prop: 'open',
        event: 'change'
      },
      props: {
        open: Boolean,
        'toolbar-spacer': Boolean
      },
      data: function data() {
        return {
          classes: {}
        };
      },

      watch: {
        open: '_refresh'
      },
      mounted: function mounted() {
        var _this = this;

        var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
            FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
            OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


        this.foundation = new MDCTemporaryDrawerFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.classes, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.classes, className);
          },
          hasClass: function hasClass(className) {
            return _this.$el.classList.contains(className);
          },
          addBodyClass: function addBodyClass(className) {
            return document.body.classList.add(className);
          },
          removeBodyClass: function removeBodyClass(className) {
            return document.body.classList.remove(className);
          },
          eventTargetHasClass: function eventTargetHasClass(target, className) {
            return target.classList.contains(className);
          },
          hasNecessaryDom: function hasNecessaryDom() {
            return !!_this.$refs.drawer;
          },
          registerInteractionHandler: function registerInteractionHandler(evt, handler) {
            _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$1());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
            _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$1());
          },
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
            _this.$refs.drawer.addEventListener(remapEvent(evt), handler, applyPassive$1());
          },
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
            _this.$refs.drawer.removeEventListener(remapEvent(evt), handler, applyPassive$1());
          },
          registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
            _this.$refs.drawer.addEventListener('transitionend', handler);
          },
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
            _this.$refs.drawer.removeEventListener('transitionend', handler);
          },
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
            document.addEventListener('keydown', handler);
          },
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
            document.removeEventListener('keydown', handler);
          },
          getDrawerWidth: function getDrawerWidth() {
            return _this.$refs.drawer.offsetWidth;
          },
          setTranslateX: function setTranslateX(value) {
            _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
          },
          updateCssVariable: function updateCssVariable(value) {
            if (supportsCssCustomProperties()) {
              _this.$el.style.setProperty(OPACITY_VAR_NAME, value);
            }
          },
          getFocusableElements: function getFocusableElements() {
            return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
          },
          saveElementTabState: function saveElementTabState$$1(el) {
            saveElementTabState(el);
          },
          restoreElementTabState: function restoreElementTabState$$1(el) {
            restoreElementTabState(el);
          },
          makeElementUntabbable: function makeElementUntabbable(el) {
            el.setAttribute('tabindex', -1);
          },
          notifyOpen: function notifyOpen() {
            _this.$emit('change', true);
            _this.$emit('open');
          },
          notifyClose: function notifyClose() {
            _this.$emit('change', false);
            _this.$emit('close');
          },
          isRtl: function isRtl() {
            /* global getComputedStyle */
            return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
          },
          isDrawer: function isDrawer(el) {
            return el === _this.$refs.drawer;
          }
        });
        this.foundation && this.foundation.init();
        this._refresh();
      },
      beforeDestroy: function beforeDestroy() {
        this.foundation && this.foundation.destroy();
        this.foundation = null;
      },

      methods: {
        _refresh: function _refresh() {
          if (this.open) {
            this.foundation && this.foundation.open();
          } else {
            this.foundation && this.foundation.close();
          }
        }
      }
    };

    var media = new (function () {
      function _class() {
        classCallCheck(this, _class);
      }

      createClass(_class, [{
        key: 'small',
        get: function get$$1() {
          return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
        }
      }, {
        key: 'large',
        get: function get$$1() {
          return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
        }
      }]);
      return _class;
    }())();

    var mdcDrawer = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { ref: "drawer", tag: "component", staticClass: "mdc-drawer", attrs: { "toolbar-spacer": _vm.toolbarSpacer }, on: { "change": _vm.onChange, "open": function open($event) {
              _vm.$emit('open');
            }, "close": function close($event) {
              _vm.$emit('close');
            } }, model: { value: _vm.open_, callback: function callback($$v) {
              _vm.open_ = $$v;
            }, expression: "open_" } }, [_vm._t("default")], 2);
      }, staticRenderFns: [],
      name: 'mdc-drawer',
      components: {
        'mdc-permanent-drawer': mdcPermanentDrawer,
        'mdc-persistent-drawer': mdcPersistentDrawer,
        'mdc-temporary-drawer': mdcTemporaryDrawer
      },
      model: {
        prop: 'open',
        event: 'change'
      },
      props: {
        open: Boolean,
        permanent: Boolean,
        persistent: Boolean,
        temporary: Boolean,
        drawerType: {
          type: String,
          validator: function validator(val) {
            return val in ['temporary', 'persistent', 'permanent'];
          }
        },
        toolbarSpacer: Boolean,
        toggleOn: String,
        toggleOnSource: { type: Object, required: false },
        openOn: String,
        openOnSource: { type: Object, required: false },
        closeOn: String,
        closeOnSource: { type: Object, required: false }
      },
      provide: function provide() {
        return { mdcDrawer: this };
      },
      data: function data() {
        return {
          small: false,
          large: false,
          open_: false
        };
      },

      computed: {
        type: function type() {
          if (this.permanent) {
            return 'mdc-permanent-drawer';
          } else if (this.persistent) {
            return 'mdc-persistent-drawer';
          } else if (this.temporary) {
            return 'mdc-temporary-drawer';
          } else {
            switch (this.drawerType) {
              case 'permanent':
                return 'mdc-permanent-drawer';
              case 'persistent':
                return 'mdc-persistent-drawer';
              case 'temporary':
                return 'mdc-temporary-drawer';
              default:
                return this.small ? 'mdc-temporary-drawer' : 'mdc-persistent-drawer';
            }
          }
        },
        isPermanent: function isPermanent() {
          return this.permanent || this.type === 'mdc-permanent-drawer';
        },
        isPersistent: function isPersistent() {
          return this.persistent || this.type === 'mdc-persistent-drawer';
        },
        isTemporary: function isTemporary() {
          return this.temporary || this.type === 'mdc-temporary-drawer';
        },
        isResponsive: function isResponsive() {
          return !(this.permanent || this.persistent || this.temporary || this.drawerType);
        }
      },
      watch: {
        open: 'onOpen_'
      },
      created: function created() {
        if (window && window.matchMedia) {
          this.small = media.small.matches;
          this.large = media.large.matches;
        }
      },
      mounted: function mounted() {
        var _this = this;

        if (this.toggleOn) {
          this.toggleOnEventSource = this.toggleOnSource || this.$root;
          this.toggleOnEventSource.$on(this.toggleOn, this.toggleDrawer);
        }
        if (this.openOn) {
          this.openOnEventSource = this.openOnSource || this.$root;
          this.openOnEventSource.$on(this.openOn, this.openDrawer);
        }
        if (this.closeOn) {
          this.closeOnEventSource = this.closeOnSource || this.$root;
          this.closeOnEventSource.$on(this.closeOn, this.closeDrawer);
        }
        media.small.addListener(this.refreshMedia);
        media.large.addListener(this.refreshMedia);
        this.$nextTick(function () {
          return _this.refreshMedia();
        });
      },
      beforeDestroy: function beforeDestroy() {
        media.small.removeListener(this.refreshMedia);
        media.large.removeListener(this.refreshMedia);

        if (this.toggleOnEventSource) {
          this.toggleOnEventSource.$off(this.toggleOn, this.toggleDrawer);
        }
        if (this.openOnEventSource) {
          this.openOnEventSource.$off(this.openOn, this.openDrawer);
        }
        if (this.closeOnEventSource) {
          this.closeOnEventSource.$off(this.closeOn, this.closeDrawer);
        }
      },

      methods: {
        onOpen_: function onOpen_(value) {
          this.isPermanent || (this.open_ = value);
        },
        onChange: function onChange(event) {
          this.$emit('change', event);
          this.$root.$emit('vma:layout');
        },
        openDrawer: function openDrawer() {
          this.open_ = true;
        },
        closeDrawer: function closeDrawer() {
          this.isPermanent || (this.open_ = false);
        },
        toggleDrawer: function toggleDrawer() {
          this.isPermanent || (this.isOpen() ? this.closeDrawer() : this.openDrawer());
        },
        isOpen: function isOpen() {
          return this.isPermanent || this.open_;
        },
        refreshMedia: function refreshMedia() {
          this.small = media.small.matches;
          this.large = media.large.matches;
          if (this.isResponsive) {
            if (this.large) {
              this.openDrawer();
            } else {
              this.closeDrawer();
            }
          }
        }
      }
    };

    var mdcDrawerLayout = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-drawer-layout" }, [_vm._t("default")], 2);
      }, staticRenderFns: [],
      name: 'mdc-drawer-layout'
    };

    var mdcDrawerHeader = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.show ? _c('header', { staticClass: "mdc-drawer-header mdc-drawer__header" }, [_c('div', { staticClass: "mdc-drawer__header-content" }, [_vm._t("default")], 2)]) : _vm._e();
      }, staticRenderFns: [],
      name: 'mdc-drawer-header',
      props: {
        permanent: Boolean,
        persistent: Boolean,
        temporary: Boolean
      },
      inject: ['mdcDrawer'],
      computed: {
        show: function show() {
          if (this.temporary || this.persistent || this.permanent) {
            return this.temporary && this.mdcDrawer.isTemporary || this.persistent && this.mdcDrawer.isPersistent || this.permanent && this.mdcDrawer.isPermanent;
          } else {
            return true;
          }
        }
      }
    };

    var mdcDrawerList = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
      }, staticRenderFns: [],
      name: 'mdc-drawer-list',
      props: {
        dense: Boolean
      },
      data: function data() {
        return {
          classes: {
            'mdc-list--dense': this.dense
          }
        };
      }
    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter = function () {
      function MDCRippleAdapter() {
        classCallCheck(this, MDCRippleAdapter);
      }

      createClass(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}

        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}

        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}

        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}

        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}

        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}

        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}

        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}

        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}

        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}

        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}

        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}

        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}

        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}

        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}

        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);
      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var cssClasses$2 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };

    var strings$2 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };

    var numbers = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_ = void 0;

    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */
    var supportsPassive_$2 = void 0;

    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */
    function detectEdgePseudoVarBug(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node);

      // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }

    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */

    function supportsCssVariables(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var supportsCssVariables = supportsCssVariables_;
      if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
      // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari
      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_ = supportsCssVariables;
      }
      return supportsCssVariables;
    }

    //
    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */
    function applyPassive$2() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$2 === undefined || forceRefresh) {
        var isSupported = false;
        try {
          globalObj.document.addEventListener('test', null, { get passive() {
              isSupported = true;
            } });
        } catch (e) {}

        supportsPassive_$2 = isSupported;
      }

      return supportsPassive_$2 ? { passive: true } : false;
    }

    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */
    function getMatchesProperty(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }

    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */
    function getNormalizedEventCoords(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;

      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;

      var normalizedX = void 0;
      var normalizedY = void 0;
      // Determine touch point relative to the ripple container.
      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return { x: normalizedX, y: normalizedY };
    }

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    // Activation events registered on the root element of each instance for activation
    var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

    // Deactivation events registered on documentElement when a pointer-related down event occurs
    var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

    // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
    /** @type {!Array<!EventTarget>} */
    var activatedTargets = [];

    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation = function (_MDCFoundation) {
      inherits(MDCRippleFoundation, _MDCFoundation);
      createClass(MDCRippleFoundation, null, [{
        key: 'cssClasses',
        get: function get$$1() {
          return cssClasses$2;
        }
      }, {
        key: 'strings',
        get: function get$$1() {
          return strings$2;
        }
      }, {
        key: 'numbers',
        get: function get$$1() {
          return numbers;
        }
      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
            isUnbounded: function isUnbounded() /* boolean */{},
            isSurfaceActive: function isSurfaceActive() /* boolean */{},
            isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
            registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
            deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
            computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
            getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        classCallCheck(this, MDCRippleFoundation);

        /** @private {number} */
        var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

        _this.layoutFrame_ = 0;

        /** @private {!ClientRect} */
        _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

        /** @private {!ActivationStateType} */
        _this.activationState_ = _this.defaultActivationState_();

        /** @private {number} */
        _this.initialSize_ = 0;

        /** @private {number} */
        _this.maxRadius_ = 0;

        /** @private {function(!Event)} */
        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };

        /** @private {function(!Event)} */
        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };

        /** @private {function(?Event=)} */
        _this.focusHandler_ = function () {
          return requestAnimationFrame(function () {
            return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        };

        /** @private {function(?Event=)} */
        _this.blurHandler_ = function () {
          return requestAnimationFrame(function () {
            return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        };

        /** @private {!Function} */
        _this.resizeHandler_ = function () {
          return _this.layout();
        };

        /** @private {{left: number, top:number}} */
        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };

        /** @private {number} */
        _this.fgScale_ = 0;

        /** @private {number} */
        _this.activationTimer_ = 0;

        /** @private {number} */
        _this.fgDeactivationRemovalTimer_ = 0;

        /** @private {boolean} */
        _this.activationAnimationHasEnded_ = false;

        /** @private {!Function} */
        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;
          _this.runDeactivationUXLogicIfReady_();
        };

        /** @private {?Event} */
        _this.previousActivationEvent_ = null;
        return _this;
      }

      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      createClass(MDCRippleFoundation, [{
        key: 'isSupported_',
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }

        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: 'defaultActivationState_',
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
      }, {
        key: 'init',
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }
          this.registerRootHandlers_();

          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);
            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED);
              // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
              _this2.layoutInternal_();
            }
          });
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();

          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);
            _this3.adapter_.removeClass(UNBOUNDED);
            _this3.removeCssVars_();
          });
        }

        /** @private */

      }, {
        key: 'registerRootHandlers_',
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }

        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: 'registerDeactivationHandlers_',
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }

        /** @private */

      }, {
        key: 'deregisterRootHandlers_',
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }

        /** @private */

      }, {
        key: 'deregisterDeactivationHandlers_',
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }

        /** @private */

      }, {
        key: 'removeCssVars_',
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;

          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }

        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: 'activate_',
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;
          if (activationState.isActivated) {
            return;
          }

          // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

          var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });
          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets.push( /** @type {!EventTarget} */e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);
              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }

        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: 'checkElementMadeActive_',
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }

        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: 'activate',
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          this.activate_(event);
        }

        /** @private */

      }, {
        key: 'animateActivation_',
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


          this.layoutInternal_();

          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
                startPoint = _getFgTranslationCoor.startPoint,
                endPoint = _getFgTranslationCoor.endPoint;

            translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
            translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
          // Cancel any ongoing activation/deactivation animations
          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION);

          // Force layout in order to re-trigger the animation.
          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }

        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: 'getFgTranslationCoordinates_',
        value: function getFgTranslationCoordinates_() {
          var _activationState_ = this.activationState_,
              activationEvent = _activationState_.activationEvent,
              wasActivatedByPointer = _activationState_.wasActivatedByPointer;


          var startPoint = void 0;
          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords(
            /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          }
          // Center the element around the start point.
          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };

          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };

          return { startPoint: startPoint, endPoint: endPoint };
        }

        /** @private */

      }, {
        key: 'runDeactivationUXLogicIfReady_',
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _activationState_2 = this.activationState_,
              hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
              isActivated = _activationState_2.isActivated;

          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers.FG_DEACTIVATION_MS);
          }
        }

        /** @private */

      }, {
        key: 'rmBoundedActivationClasses_',
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: 'resetActivationState_',
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_();
          // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.
          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }

        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: 'deactivate_',
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_;
          // This can happen in scenarios such as when you have a keyup event that blurs the element.
          if (!activationState.isActivated) {
            return;
          }

          var state = /** @type {!ActivationStateType} */_extends({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;
              _this13.animateDeactivation_(e, state);
              _this13.resetActivationState_();
            });
          }
        }

        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: 'deactivate',
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          this.deactivate_(event);
        }

        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: 'animateDeactivation_',
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: 'layout',
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }
          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();
            _this14.layoutFrame_ = 0;
          });
        }

        /** @private */

      }, {
        key: 'layoutInternal_',
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width);

          // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.
          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

          // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;

          this.updateLayoutCssVars_();
        }

        /** @private */

      }, {
        key: 'updateLayoutCssVars_',
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


          this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };

            this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
            this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
          }
        }

        /** @param {boolean} unbounded */

      }, {
        key: 'setUnbounded',
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }]);
      return MDCRippleFoundation;
    }(MDCFoundation);

    var RippleBase = function (_MDCRippleFoundation) {
      inherits(RippleBase, _MDCRippleFoundation);
      createClass(RippleBase, null, [{
        key: 'isSurfaceActive',
        value: function isSurfaceActive(ref) {
          return ref[RippleBase.MATCHES](':active');
        }
      }, {
        key: 'MATCHES',
        get: function get$$1() {
          /* global HTMLElement */
          return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
        }
      }]);

      function RippleBase(vm, options) {
        classCallCheck(this, RippleBase);
        return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return false;
          },
          isSurfaceActive: function isSurfaceActive() {
            return vm.$el[RippleBase.MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return vm.disabled;
          },
          addClass: function addClass(className) {
            vm.$set(vm.classes, className, true);
          },
          removeClass: function removeClass(className) {
            vm.$delete(vm.classes, className);
          },

          containsEventTarget: function containsEventTarget(target) {
            return vm.$el.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evt, handler) {
            vm.$el.addEventListener(evt, handler, applyPassive$2());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
            vm.$el.removeEventListener(evt, handler, applyPassive$2());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive$2());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive$2());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            vm.$set(vm.styles, varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return vm.$el.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return { x: window.pageXOffset, y: window.pageYOffset };
          }
        }, options)));
      }

      return RippleBase;
    }(MDCRippleFoundation);

    var mdcDrawerItem = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', _vm._g({ staticClass: "mdc-drawer-item mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "link": _vm.link } }, _vm.mylisteners), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail", [_c('i', { staticClass: "material-icons", attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.startIcon))])])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
      }, staticRenderFns: [],
      name: 'mdc-drawer-item',
      inject: ['mdcDrawer'],
      mixins: [DispatchEventMixin, CustomLinkMixin],
      props: {
        startIcon: String,
        temporaryClose: {
          type: Boolean,
          default: true
        },
        activated: Boolean,
        exactActiveClass: {
          type: String,
          default: 'mdc-list-item--activated'
        }
      },
      data: function data() {
        return {
          classes: {},
          styles: {}
        };
      },

      computed: {
        mylisteners: function mylisteners() {
          var _this = this;

          return _extends({}, this.$listeners, {
            click: function click(e) {
              _this.mdcDrawer.isTemporary && _this.temporaryClose && _this.mdcDrawer.closeDrawer();
              _this.dispatchEvent(e);
            }
          });
        },
        itemClasses: function itemClasses() {
          return {
            'mdc-list-item--activated': this.activated
          };
        },
        hasStartDetail: function hasStartDetail() {
          return this.startIcon || this.$slots['start-detail'];
        }
      },
      mounted: function mounted() {
        this.ripple = new RippleBase(this);
        this.ripple.init();
      },
      beforeDestroy: function beforeDestroy() {
        this.ripple && this.ripple.destroy();
        this.ripple = null;
      }
    };

    var mdcDrawerDivider = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-divider" });
      }, staticRenderFns: [],
      name: 'mdc-drawer-divider'
    };

    var plugin = BasePlugin({
      mdcDrawer: mdcDrawer,
      mdcDrawerLayout: mdcDrawerLayout,
      mdcDrawerHeader: mdcDrawerHeader,
      mdcDrawerList: mdcDrawerList,
      mdcDrawerItem: mdcDrawerItem,
      mdcDrawerDivider: mdcDrawerDivider
    });

    autoInit(plugin);

    return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhd2VyLmpzIiwic291cmNlcyI6WyIuLi8uLi9jb21wb25lbnRzL2Jhc2UvYXV0by1pbml0LmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2Jhc2UtcGx1Z2luLmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1saW5rLmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1ldmVudC5qcyIsIi4uLy4uL2NvbXBvbmVudHMvYmFzZS9kaXNwYXRjaC1ldmVudC1taXhpbi5qcyIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1wZXJtYW5lbnQtZHJhd2VyLnZ1ZSIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3NsaWRhYmxlL2NvbnN0YW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3NsaWRhYmxlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9zbGlkYWJsZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3BlcnNpc3RlbnQvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvcGVyc2lzdGVudC9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvdXRpbC5qcyIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1wZXJzaXN0ZW50LWRyYXdlci52dWUiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvdGVtcG9yYXJ5L2ZvdW5kYXRpb24uanMiLCIuLi8uLi9jb21wb25lbnRzL2RyYXdlci9tZGMtdGVtcG9yYXJ5LWRyYXdlci52dWUiLCIuLi8uLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItbGF5b3V0LnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItaGVhZGVyLnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItbGlzdC52dWUiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9hZGFwdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvdXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLWJhc2UuanMiLCIuLi8uLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWl0ZW0udnVlIiwiLi4vLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1kaXZpZGVyLnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL2luZGV4LmpzIiwiLi4vLi4vY29tcG9uZW50cy9kcmF3ZXIvZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGF1dG9Jbml0KHBsdWdpbikge1xuICAvLyBBdXRvLWluc3RhbGxcbiAgbGV0IF9WdWUgPSBudWxsXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIF9WdWUgPSB3aW5kb3cuVnVlXG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvKmdsb2JhbCBnbG9iYWwqL1xuICAgIF9WdWUgPSBnbG9iYWwuVnVlXG4gIH1cbiAgaWYgKF9WdWUpIHtcbiAgICBfVnVlLnVzZShwbHVnaW4pXG4gIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBCYXNlUGx1Z2luKGNvbXBvbmVudHMpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnX19WRVJTSU9OX18nLFxuICAgIGluc3RhbGw6IHZtID0+IHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2tleV1cbiAgICAgICAgdm0uY29tcG9uZW50KGNvbXBvbmVudC5uYW1lLCBjb21wb25lbnQpXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzXG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBDdXN0b21MaW5rID0ge1xuICBuYW1lOiAnY3VzdG9tLWxpbmsnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHRhZzogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdhJyB9LFxuICAgIGxpbms6IE9iamVjdFxuICB9LFxuICByZW5kZXIoaCwgY29udGV4dCkge1xuICAgIGxldCBlbGVtZW50XG4gICAgbGV0IGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LmRhdGEpXG5cbiAgICBpZiAoY29udGV4dC5wcm9wcy5saW5rICYmIGNvbnRleHQucGFyZW50LiRyb3V0ZXIpIHtcbiAgICAgIC8vIHJvdXRlci1saW5rIGNhc2VcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnBhcmVudC4kcm9vdC4kb3B0aW9ucy5jb21wb25lbnRzWydyb3V0ZXItbGluayddXG4gICAgICBkYXRhLnByb3BzID0gT2JqZWN0LmFzc2lnbih7IHRhZzogY29udGV4dC5wcm9wcy50YWcgfSwgY29udGV4dC5wcm9wcy5saW5rKVxuICAgICAgaWYgKGRhdGEub24uY2xpY2spIHtcbiAgICAgICAgZGF0YS5uYXRpdmVPbiA9IHsgY2xpY2s6IGRhdGEub24uY2xpY2sgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbGVtZW50IGZhbGxiYWNrXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wcm9wcy50YWdcbiAgICB9XG5cbiAgICByZXR1cm4gaChlbGVtZW50LCBkYXRhLCBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21MaW5rTWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgdG86IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmdcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsaW5rKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy50byAmJiB7XG4gICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICAgICAgYXBwZW5kOiB0aGlzLmFwcGVuZCxcbiAgICAgICAgICByZXBsYWNlOiB0aGlzLnJlcGxhY2UsXG4gICAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMuYWN0aXZlQ2xhc3MsXG4gICAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogdGhpcy5leGFjdEFjdGl2ZUNsYXNzXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21MaW5rXG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBDdXN0b21FdmVudCAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZW1pdEN1c3RvbUV2ZW50KGVsLCBldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICBsZXQgZXZ0XG4gIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZ0VHlwZSwge1xuICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKVxuICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZ0VHlwZSwgc2hvdWxkQnViYmxlLCBmYWxzZSwgZXZ0RGF0YSlcbiAgfVxuICBlbC5kaXNwYXRjaEV2ZW50KGV2dClcbn1cbiIsImV4cG9ydCBjb25zdCBEaXNwYXRjaEV2ZW50TWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgZXZlbnQ6IFN0cmluZyxcbiAgICAnZXZlbnQtdGFyZ2V0JzogT2JqZWN0LFxuICAgICdldmVudC1hcmdzJzogQXJyYXlcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGRpc3BhdGNoRXZlbnQoZXZ0KSB7XG4gICAgICBldnQgJiYgdGhpcy4kZW1pdChldnQudHlwZSwgZXZ0KVxuICAgICAgaWYgKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZXZlbnRUYXJnZXQgfHwgdGhpcy4kcm9vdFxuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZXZlbnRBcmdzIHx8IFtdXG4gICAgICAgIHRhcmdldC4kZW1pdCh0aGlzLmV2ZW50LCAuLi5hcmdzKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzLiRsaXN0ZW5lcnMsXG4gICAgICAgIGNsaWNrOiBlID0+IHRoaXMuZGlzcGF0Y2hFdmVudChlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8bmF2IGNsYXNzPVwibWRjLXBlcm1hbmVudC1kcmF3ZXIgbWRjLWRyYXdlci0tcGVybWFuZW50IG1kYy10eXBvZ3JhcGh5XCI+XG4gICAgPG5hdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2NvbnRlbnRcIj5cbiAgICAgIDxkaXYgXG4gICAgICAgIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWRyYXdlcl9fdG9vbGJhci1zcGFjZXJcIi8+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvbmF2PlxuICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcGVybWFuZW50LWRyYXdlcicsXG4gIHByb3BzOiB7XG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhblxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBGT0NVU0FCTEVfRUxFTUVOVFMgPVxuICAnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksICcgK1xuICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCBbdGFiaW5kZXhdLCBbY29udGVudGVkaXRhYmxlXSc7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG5leHBvcnQge01EQ0ZvdW5kYXRpb24sIE1EQ0NvbXBvbmVudH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcblxuZXhwb3J0IGNsYXNzIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHNldFRyYW5zbGF0ZVg6ICgvKiB2YWx1ZTogbnVtYmVyIHwgbnVsbCAqLykgPT4ge30sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4gLyogTm9kZUxpc3QgKi8ge30sXG4gICAgICBzYXZlRWxlbWVudFRhYlN0YXRlOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZTogKC8qIGVsOiBFbGVtZW50ICovKSA9PiB7fSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogKC8qIGVsOiBFbGVtZW50ICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeU9wZW46ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBnZXREcmF3ZXJXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIHJvb3RDc3NDbGFzcywgYW5pbWF0aW5nQ3NzQ2xhc3MsIG9wZW5Dc3NDbGFzcykge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLnJvb3RDc3NDbGFzc18gPSByb290Q3NzQ2xhc3M7XG4gICAgdGhpcy5hbmltYXRpbmdDc3NDbGFzc18gPSBhbmltYXRpbmdDc3NDbGFzcztcbiAgICB0aGlzLm9wZW5Dc3NDbGFzc18gPSBvcGVuQ3NzQ2xhc3M7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KTtcblxuICAgIHRoaXMuaW5lcnRfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVG91Y2hTdGFydF8oZXZ0KTtcbiAgICB0aGlzLmNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUb3VjaE1vdmVfKGV2dCk7XG4gICAgdGhpcy5jb21wb25lbnRUb3VjaEVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUb3VjaEVuZF8oZXZ0KTtcbiAgICB0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgJiYgZXZ0LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZ0LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBST09UID0gdGhpcy5yb290Q3NzQ2xhc3NfO1xuICAgIGNvbnN0IE9QRU4gPSB0aGlzLm9wZW5Dc3NDbGFzc187XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoUk9PVCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtST09UfSBjbGFzcyByZXF1aXJlZCBpbiByb290IGVsZW1lbnQuYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc05lY2Vzc2FyeURvbSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVkIERPTSBub2RlcyBtaXNzaW5nIGluICR7Uk9PVH0gY29tcG9uZW50LmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE9QRU4pKSB7XG4gICAgICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRldGFiaW5hdGVfKCk7XG4gICAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaHN0YXJ0JywgdGhpcy5jb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNobW92ZScsIHRoaXMuY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoZW5kJywgdGhpcy5jb21wb25lbnRUb3VjaEVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaHN0YXJ0JywgdGhpcy5jb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2htb3ZlJywgdGhpcy5jb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaGVuZCcsIHRoaXMuY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyk7XG4gICAgLy8gRGVyZWdpc3RlciB0aGUgZG9jdW1lbnQga2V5ZG93biBoYW5kbGVyIGp1c3QgaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCB3aGlsZSB0aGUgbWVudSBpcyBvcGVuLlxuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLm9wZW5Dc3NDbGFzc18pO1xuICAgIHRoaXMucmV0YWJpbmF0ZV8oKTtcbiAgICAvLyBEZWJvdW5jZSBtdWx0aXBsZSBjYWxsc1xuICAgIGlmICghdGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeU9wZW4oKTtcbiAgICB9XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMub3BlbkNzc0NsYXNzXyk7XG4gICAgdGhpcy5kZXRhYmluYXRlXygpO1xuICAgIC8vIERlYm91bmNlIG11bHRpcGxlIGNhbGxzXG4gICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgLyoqXG4gICAqICBSZW5kZXIgYWxsIGNoaWxkcmVuIG9mIHRoZSBkcmF3ZXIgaW5lcnQgd2hlbiBpdCdzIGNsb3NlZC5cbiAgICovXG4gIGRldGFiaW5hdGVfKCkge1xuICAgIGlmICh0aGlzLmluZXJ0Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2FibGVFbGVtZW50cygpO1xuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNhdmVFbGVtZW50VGFiU3RhdGUoZWxlbWVudHNbaV0pO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm1ha2VFbGVtZW50VW50YWJiYWJsZShlbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmVydF8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqICBNYWtlIGFsbCBjaGlsZHJlbiBvZiB0aGUgZHJhd2VyIHRhYmJhYmxlIGFnYWluIHdoZW4gaXQncyBvcGVuLlxuICAgKi9cbiAgcmV0YWJpbmF0ZV8oKSB7XG4gICAgaWYgKCF0aGlzLmluZXJ0Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2FibGVFbGVtZW50cygpO1xuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5lcnRfID0gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVUb3VjaFN0YXJ0XyhldnQpIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3ModGhpcy5vcGVuQ3NzQ2xhc3NfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGlyZWN0aW9uXyA9IHRoaXMuYWRhcHRlcl8uaXNSdGwoKSA/IC0xIDogMTtcbiAgICB0aGlzLmRyYXdlcldpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0RHJhd2VyV2lkdGgoKTtcbiAgICB0aGlzLnN0YXJ0WF8gPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLnBhZ2VYIDogZXZ0LnBhZ2VYO1xuICAgIHRoaXMuY3VycmVudFhfID0gdGhpcy5zdGFydFhfO1xuXG4gICAgdGhpcy51cGRhdGVSYWZfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlRHJhd2VyXy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGhhbmRsZVRvdWNoTW92ZV8oZXZ0KSB7XG4gICAgaWYgKGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRYXyA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0ucGFnZVggOiBldnQucGFnZVg7XG4gIH1cblxuICBoYW5kbGVUb3VjaEVuZF8oZXZ0KSB7XG4gICAgaWYgKGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXBhcmVGb3JUb3VjaEVuZF8oKTtcblxuICAgIC8vIERpZCB0aGUgdXNlciBjbG9zZSB0aGUgZHJhd2VyIGJ5IG1vcmUgdGhhbiA1MCU/XG4gICAgaWYgKE1hdGguYWJzKHRoaXMubmV3UG9zaXRpb25fIC8gdGhpcy5kcmF3ZXJXaWR0aF8pID49IDAuNSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmlnZ2VyaW5nIGFuIG9wZW4gaGVyZSBtZWFucyB3ZSdsbCBnZXQgYSBuaWNlIGFuaW1hdGlvbiBiYWNrIHRvIHRoZSBmdWxseSBvcGVuIHN0YXRlLlxuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgcHJlcGFyZUZvclRvdWNoRW5kXygpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZVJhZl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhbnNsYXRlWChudWxsKTtcbiAgfVxuXG4gIHVwZGF0ZURyYXdlcl8oKSB7XG4gICAgdGhpcy51cGRhdGVSYWZfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlRHJhd2VyXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFRyYW5zbGF0ZVgodGhpcy5uZXdQb3NpdGlvbl8pO1xuICB9XG5cbiAgZ2V0IG5ld1Bvc2l0aW9uXygpIHtcbiAgICBsZXQgbmV3UG9zID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmRpcmVjdGlvbl8gPT09IDEpIHtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWluKDAsIHRoaXMuY3VycmVudFhfIC0gdGhpcy5zdGFydFhfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3UG9zID0gTWF0aC5tYXgoMCwgdGhpcy5jdXJyZW50WF8gLSB0aGlzLnN0YXJ0WF8pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQb3M7XG4gIH1cblxuICBpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlXG4gICAgLy8gaWYgdGhlIGV2ZW50IHRhcmdldCBpcyB0aGUgcm9vdCBldmVudCB0YXJnZXQgY3VycmVudGx5IHRyYW5zaXRpb25pbmcuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KSB7XG4gICAgaWYgKHRoaXMuaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyhldnQudGFyZ2V0KSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgfVxuICB9O1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IHtGT0NVU0FCTEVfRUxFTUVOVFN9IGZyb20gJy4vY29uc3RhbnRzJztcbmV4cG9ydCB7TURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9ufSBmcm9tICcuL2ZvdW5kYXRpb24nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtGT0NVU0FCTEVfRUxFTUVOVFN9IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtZHJhd2VyLS1wZXJzaXN0ZW50JyxcbiAgT1BFTjogJ21kYy1kcmF3ZXItLW9wZW4nLFxuICBBTklNQVRJTkc6ICdtZGMtZHJhd2VyLS1hbmltYXRpbmcnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIERSQVdFUl9TRUxFQ1RPUjogJy5tZGMtZHJhd2VyLS1wZXJzaXN0ZW50IC5tZGMtZHJhd2VyX19kcmF3ZXInLFxuICBGT0NVU0FCTEVfRUxFTUVOVFMsXG4gIE9QRU5fRVZFTlQ6ICdNRENQZXJzaXN0ZW50RHJhd2VyOm9wZW4nLFxuICBDTE9TRV9FVkVOVDogJ01EQ1BlcnNpc3RlbnREcmF3ZXI6Y2xvc2UnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9ufSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwge1xuICAgICAgaXNEcmF3ZXI6ICgpID0+IGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbihNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlciksXG4gICAgICBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlJPT1QsXG4gICAgICBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyxcbiAgICAgIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG4gIH1cblxuICBpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNEcmF3ZXIoZWwpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBUQUJfREFUQSA9ICdkYXRhLW1kYy10YWJpbmRleCc7XG5jb25zdCBUQUJfREFUQV9IQU5ETEVEID0gJ2RhdGEtbWRjLXRhYmluZGV4LWhhbmRsZWQnO1xuXG5sZXQgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcbmxldCBzdXBwb3J0c1Bhc3NpdmVfO1xuXG4vLyBSZW1hcCB0b3VjaCBldmVudHMgdG8gcG9pbnRlciBldmVudHMsIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0b3VjaCBldmVudHMuXG5leHBvcnQgZnVuY3Rpb24gcmVtYXBFdmVudChldmVudE5hbWUsIGdsb2JhbE9iaiA9IHdpbmRvdykge1xuICBpZiAoISgnb250b3VjaHN0YXJ0JyBpbiBnbG9iYWxPYmouZG9jdW1lbnQpKSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICBjYXNlICd0b3VjaHN0YXJ0JzpcbiAgICAgIHJldHVybiAncG9pbnRlcmRvd24nO1xuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICByZXR1cm4gJ3BvaW50ZXJtb3ZlJztcbiAgICBjYXNlICd0b3VjaGVuZCc6XG4gICAgICByZXR1cm4gJ3BvaW50ZXJ1cCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50TmFtZTtcbn1cblxuLy8gQ2hvb3NlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBwcm9wZXJ0eSB0byB1c2Ugb24gdGhlIGN1cnJlbnQgYnJvd3Nlci5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGVsID0gZ2xvYmFsT2JqLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRyYW5zZm9ybVByb3BlcnR5TmFtZSA9ICgndHJhbnNmb3JtJyBpbiBlbC5zdHlsZSA/ICd0cmFuc2Zvcm0nIDogJy13ZWJraXQtdHJhbnNmb3JtJyk7XG4gICAgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyA9IHRyYW5zZm9ybVByb3BlcnR5TmFtZTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xufVxuXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIENTUyBwcm9wZXJ0aWVzLlxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzQ3NzQ3VzdG9tUHJvcGVydGllcyhnbG9iYWxPYmogPSB3aW5kb3cpIHtcbiAgaWYgKCdDU1MnIGluIGdsb2JhbE9iaikge1xuICAgIHJldHVybiBnbG9iYWxPYmouQ1NTLnN1cHBvcnRzKCcoLS1jb2xvcjogcmVkKScpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cblxuLy8gU2F2ZSB0aGUgdGFiIHN0YXRlIGZvciBhbiBlbGVtZW50LlxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVFbGVtZW50VGFiU3RhdGUoZWwpIHtcbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShUQUJfREFUQSwgZWwuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKTtcbiAgfVxuICBlbC5zZXRBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCwgdHJ1ZSk7XG59XG5cbi8vIFJlc3RvcmUgdGhlIHRhYiBzdGF0ZSBmb3IgYW4gZWxlbWVudCwgaWYgaXQgd2FzIHNhdmVkLlxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWwpIHtcbiAgLy8gT25seSBtb2RpZnkgZWxlbWVudHMgd2UndmUgYWxyZWFkeSBoYW5kbGVkLCBpbiBjYXNlIGFueXRoaW5nIHdhcyBkeW5hbWljYWxseSBhZGRlZCBzaW5jZSB3ZSBzYXZlZCBzdGF0ZS5cbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVEKSkge1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoVEFCX0RBVEEpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgZWwuZ2V0QXR0cmlidXRlKFRBQl9EQVRBKSk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoVEFCX0RBVEEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVEKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGVcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy1wZXJzaXN0ZW50LWRyYXdlciBtZGMtZHJhd2VyLS1wZXJzaXN0ZW50IG1kYy10eXBvZ3JhcGh5XCI+XG4gICAgPG5hdlxuICAgICAgcmVmPVwiZHJhd2VyXCJcbiAgICAgIGNsYXNzPVwibWRjLWRyYXdlcl9fZHJhd2VyXCI+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtZHJhd2VyX190b29sYmFyLXNwYWNlclwiLz5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvYXNpZGU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvcGVyc2lzdGVudC9mb3VuZGF0aW9uJ1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3V0aWwnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1wZXJzaXN0ZW50LWRyYXdlcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ29wZW4nLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgICd0b29sYmFyLXNwYWNlcic6IEJvb2xlYW4sXG4gICAgb3BlbjogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuOiAnX3JlZnJlc2gnXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgeyBGT0NVU0FCTEVfRUxFTUVOVFMgfSA9IE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLnN0cmluZ3NcblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZWZzLmRyYXdlclxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHV0aWwucmVtYXBFdmVudChldnQpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgdXRpbC5hcHBseVBhc3NpdmUoKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHV0aWwucmVtYXBFdmVudChldnQpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgdXRpbC5hcHBseVBhc3NpdmUoKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogdmFsdWUgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICB1dGlsLmdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSgpLFxuICAgICAgICAgIHZhbHVlID09PSBudWxsID8gbnVsbCA6IGB0cmFuc2xhdGVYKCR7dmFsdWV9cHgpYFxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKVxuICAgICAgfSxcbiAgICAgIHNhdmVFbGVtZW50VGFiU3RhdGU6IGVsID0+IHtcbiAgICAgICAgdXRpbC5zYXZlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6IGVsID0+IHtcbiAgICAgICAgdXRpbC5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogZWwgPT4ge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpXG4gICAgICB9LFxuICAgICAgbm90aWZ5T3BlbjogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0cnVlKVxuICAgICAgICB0aGlzLiRlbWl0KCdvcGVuJylcbiAgICAgIH0sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnKVxuICAgICAgfSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7XG4gICAgICAgIC8qIGdsb2JhbCBnZXRDb21wdXRlZFN0eWxlICovXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBpc0RyYXdlcjogZWwgPT4ge1xuICAgICAgICByZXR1cm4gZWwgPT09IHRoaXMuJHJlZnMuZHJhd2VyXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuX3JlZnJlc2goKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgX3JlZnJlc2goKSB7XG4gICAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtGT0NVU0FCTEVfRUxFTUVOVFN9IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtZHJhd2VyLS10ZW1wb3JhcnknLFxuICBPUEVOOiAnbWRjLWRyYXdlci0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kcmF3ZXItLWFuaW1hdGluZycsXG4gIFNDUk9MTF9MT0NLOiAnbWRjLWRyYXdlci1zY3JvbGwtbG9jaycsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgRFJBV0VSX1NFTEVDVE9SOiAnLm1kYy1kcmF3ZXItLXRlbXBvcmFyeSAubWRjLWRyYXdlcl9fZHJhd2VyJyxcbiAgT1BBQ0lUWV9WQVJfTkFNRTogJy0tbWRjLXRlbXBvcmFyeS1kcmF3ZXItb3BhY2l0eScsXG4gIEZPQ1VTQUJMRV9FTEVNRU5UUyxcbiAgT1BFTl9FVkVOVDogJ01EQ1RlbXBvcmFyeURyYXdlcjpvcGVuJyxcbiAgQ0xPU0VfRVZFTlQ6ICdNRENUZW1wb3JhcnlEcmF3ZXI6Y2xvc2UnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9ufSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCB7XG4gICAgICBhZGRCb2R5Q2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBpc0RyYXdlcjogKCkgPT4gZmFsc2UsXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKC8qIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKC8qIHRhcmdldDogRXZlbnRUYXJnZXQsIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbihNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSxcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5ST09ULFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyxcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcblxuICAgIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3MoZXZ0LnRhcmdldCwgY3NzQ2xhc3Nlcy5ST09UKSkge1xuICAgICAgICB0aGlzLmNsb3NlKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIHN1cGVyLmluaXQoKTtcblxuICAgIC8vIE1ha2UgYnJvd3NlciBhd2FyZSBvZiBjdXN0b20gcHJvcGVydHkgYmVpbmcgdXNlZCBpbiB0aGlzIGVsZW1lbnQuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBoYXJkLXRvLXJlcHJvZHVjZSBoZWlzZW5idWdzLlxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoMCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmVuYWJsZVNjcm9sbF8oKTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5kaXNhYmxlU2Nyb2xsXygpO1xuICAgIC8vIE1ha2Ugc3VyZSBjdXN0b20gcHJvcGVydHkgdmFsdWVzIGFyZSBjbGVhcmVkIGJlZm9yZSBzdGFydGluZy5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcblxuICAgIHN1cGVyLm9wZW4oKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIC8vIE1ha2Ugc3VyZSBjdXN0b20gcHJvcGVydHkgdmFsdWVzIGFyZSBjbGVhcmVkIGJlZm9yZSBtYWtpbmcgYW55IGNoYW5nZXMuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgnJyk7XG5cbiAgICBzdXBlci5jbG9zZSgpO1xuICB9XG5cbiAgcHJlcGFyZUZvclRvdWNoRW5kXygpIHtcbiAgICBzdXBlci5wcmVwYXJlRm9yVG91Y2hFbmRfKCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcbiAgfVxuXG4gIHVwZGF0ZURyYXdlcl8oKSB7XG4gICAgc3VwZXIudXBkYXRlRHJhd2VyXygpO1xuXG4gICAgY29uc3QgbmV3T3BhY2l0eSA9IE1hdGgubWF4KDAsIDEgKyB0aGlzLmRpcmVjdGlvbl8gKiAodGhpcy5uZXdQb3NpdGlvbl8gLyB0aGlzLmRyYXdlcldpZHRoXykpO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUobmV3T3BhY2l0eSk7XG4gIH1cblxuICBpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNEcmF3ZXIoZWwpO1xuICB9XG5cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KSB7XG4gICAgc3VwZXIuaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KTtcbiAgICBpZiAoIXRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gICAgfVxuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGVcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy10ZW1wb3JhcnktZHJhd2VyIG1kYy1kcmF3ZXItLXRlbXBvcmFyeSBtZGMtdHlwb2dyYXBoeVwiPlxuICAgIDxuYXZcbiAgICAgIHJlZj1cImRyYXdlclwiXG4gICAgICBjbGFzcz1cIm1kYy1kcmF3ZXJfX2RyYXdlclwiPlxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwidG9vbGJhclNwYWNlclwiXG4gICAgICAgIGNsYXNzPVwibWRjLWRyYXdlcl9fdG9vbGJhci1zcGFjZXJcIi8+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvbmF2PlxuICA8L2FzaWRlPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvdGVtcG9yYXJ5L2ZvdW5kYXRpb24nXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvdXRpbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdvcGVuJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBvcGVuOiBCb29sZWFuLFxuICAgICd0b29sYmFyLXNwYWNlcic6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge31cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbjogJ19yZWZyZXNoJ1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIEZPQ1VTQUJMRV9FTEVNRU5UUyxcbiAgICAgIE9QQUNJVFlfVkFSX05BTUVcbiAgICB9ID0gTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5zdHJpbmdzXG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGFkZEJvZHlDbGFzczogY2xhc3NOYW1lID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiBjbGFzc05hbWUgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAodGFyZ2V0LCBjbGFzc05hbWUpID0+XG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZWZzLmRyYXdlclxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHV0aWwucmVtYXBFdmVudChldnQpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgdXRpbC5hcHBseVBhc3NpdmUoKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHV0aWwucmVtYXBFdmVudChldnQpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgdXRpbC5hcHBseVBhc3NpdmUoKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogdmFsdWUgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICB1dGlsLmdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSgpLFxuICAgICAgICAgIHZhbHVlID09PSBudWxsID8gbnVsbCA6IGB0cmFuc2xhdGVYKCR7dmFsdWV9cHgpYFxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHV0aWwuc3VwcG9ydHNDc3NDdXN0b21Qcm9wZXJ0aWVzKCkpIHtcbiAgICAgICAgICB0aGlzLiRlbC5zdHlsZS5zZXRQcm9wZXJ0eShPUEFDSVRZX1ZBUl9OQU1FLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldEZvY3VzYWJsZUVsZW1lbnRzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyYXdlci5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUylcbiAgICAgIH0sXG4gICAgICBzYXZlRWxlbWVudFRhYlN0YXRlOiBlbCA9PiB7XG4gICAgICAgIHV0aWwuc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiBlbCA9PiB7XG4gICAgICAgIHV0aWwucmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICBtYWtlRWxlbWVudFVudGFiYmFibGU6IGVsID0+IHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeU9wZW46ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdHJ1ZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJylcbiAgICAgIH0sXG4gICAgICBpc1J0bDogKCkgPT4ge1xuICAgICAgICAvKiBnbG9iYWwgZ2V0Q29tcHV0ZWRTdHlsZSAqL1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJ1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgaXNEcmF3ZXI6IGVsID0+IGVsID09PSB0aGlzLiRyZWZzLmRyYXdlclxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLl9yZWZyZXNoKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIF9yZWZyZXNoKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y29tcG9uZW50IFxuICAgIHJlZj1cImRyYXdlclwiIFxuICAgIDppcz1cInR5cGVcIlxyXG4gICAgdi1tb2RlbD1cIm9wZW5fXCIgXG4gICAgOnRvb2xiYXItc3BhY2VyPVwidG9vbGJhclNwYWNlclwiXHJcbiAgICBjbGFzcz1cIm1kYy1kcmF3ZXJcIlxyXG4gICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcclxuICAgIEBvcGVuPVwiJGVtaXQoJ29wZW4nKVwiXHJcbiAgICBAY2xvc2U9XCIkZW1pdCgnY2xvc2UnKVwiID5cclxuICAgIDxzbG90IC8+XHJcbiAgPC9jb21wb25lbnQ+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgbWRjUGVybWFuZW50RHJhd2VyIGZyb20gJy4vbWRjLXBlcm1hbmVudC1kcmF3ZXIudnVlJ1xyXG5pbXBvcnQgbWRjUGVyc2lzdGVudERyYXdlciBmcm9tICcuL21kYy1wZXJzaXN0ZW50LWRyYXdlci52dWUnXHJcbmltcG9ydCBtZGNUZW1wb3JhcnlEcmF3ZXIgZnJvbSAnLi9tZGMtdGVtcG9yYXJ5LWRyYXdlci52dWUnXHJcblxyXG5jb25zdCBtZWRpYSA9IG5ldyBjbGFzcyB7XHJcbiAgZ2V0IHNtYWxsKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy5fc21hbGwgfHwgKHRoaXMuX3NtYWxsID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtYXgtd2lkdGg6IDgzOXB4KScpKVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgZ2V0IGxhcmdlKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy5fbGFyZ2UgfHwgKHRoaXMuX2xhcmdlID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDEyMDBweCknKSlcclxuICAgIClcclxuICB9XHJcbn0oKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtZHJhd2VyJyxcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICAnbWRjLXBlcm1hbmVudC1kcmF3ZXInOiBtZGNQZXJtYW5lbnREcmF3ZXIsXHJcbiAgICAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJzogbWRjUGVyc2lzdGVudERyYXdlcixcclxuICAgICdtZGMtdGVtcG9yYXJ5LWRyYXdlcic6IG1kY1RlbXBvcmFyeURyYXdlclxyXG4gIH0sXHJcbiAgbW9kZWw6IHtcclxuICAgIHByb3A6ICdvcGVuJyxcclxuICAgIGV2ZW50OiAnY2hhbmdlJ1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIG9wZW46IEJvb2xlYW4sXHJcbiAgICBwZXJtYW5lbnQ6IEJvb2xlYW4sXHJcbiAgICBwZXJzaXN0ZW50OiBCb29sZWFuLFxyXG4gICAgdGVtcG9yYXJ5OiBCb29sZWFuLFxyXG4gICAgZHJhd2VyVHlwZToge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIHZhbGlkYXRvcjogdmFsID0+IHtcclxuICAgICAgICByZXR1cm4gdmFsIGluIFsndGVtcG9yYXJ5JywgJ3BlcnNpc3RlbnQnLCAncGVybWFuZW50J11cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRvb2xiYXJTcGFjZXI6IEJvb2xlYW4sXHJcbiAgICB0b2dnbGVPbjogU3RyaW5nLFxyXG4gICAgdG9nZ2xlT25Tb3VyY2U6IHsgdHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2UgfSxcclxuICAgIG9wZW5PbjogU3RyaW5nLFxyXG4gICAgb3Blbk9uU291cmNlOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlIH0sXHJcbiAgICBjbG9zZU9uOiBTdHJpbmcsXHJcbiAgICBjbG9zZU9uU291cmNlOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlIH1cclxuICB9LFxyXG4gIHByb3ZpZGUoKSB7XHJcbiAgICByZXR1cm4geyBtZGNEcmF3ZXI6IHRoaXMgfVxyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNtYWxsOiBmYWxzZSxcclxuICAgICAgbGFyZ2U6IGZhbHNlLFxyXG4gICAgICBvcGVuXzogZmFsc2VcclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICB0eXBlKCkge1xyXG4gICAgICBpZiAodGhpcy5wZXJtYW5lbnQpIHtcclxuICAgICAgICByZXR1cm4gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGVyc2lzdGVudCkge1xyXG4gICAgICAgIHJldHVybiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJ1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudGVtcG9yYXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuICdtZGMtdGVtcG9yYXJ5LWRyYXdlcidcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhd2VyVHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAncGVybWFuZW50JzpcclxuICAgICAgICAgICAgcmV0dXJuICdtZGMtcGVybWFuZW50LWRyYXdlcidcclxuICAgICAgICAgIGNhc2UgJ3BlcnNpc3RlbnQnOlxyXG4gICAgICAgICAgICByZXR1cm4gJ21kYy1wZXJzaXN0ZW50LWRyYXdlcidcclxuICAgICAgICAgIGNhc2UgJ3RlbXBvcmFyeSc6XHJcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbWFsbCA/ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcicgOiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJ1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGlzUGVybWFuZW50KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wZXJtYW5lbnQgfHwgdGhpcy50eXBlID09PSAnbWRjLXBlcm1hbmVudC1kcmF3ZXInXHJcbiAgICB9LFxyXG4gICAgaXNQZXJzaXN0ZW50KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW50IHx8IHRoaXMudHlwZSA9PT0gJ21kYy1wZXJzaXN0ZW50LWRyYXdlcidcclxuICAgIH0sXHJcbiAgICBpc1RlbXBvcmFyeSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGVtcG9yYXJ5IHx8IHRoaXMudHlwZSA9PT0gJ21kYy10ZW1wb3JhcnktZHJhd2VyJ1xyXG4gICAgfSxcclxuICAgIGlzUmVzcG9uc2l2ZSgpIHtcclxuICAgICAgcmV0dXJuICEoXHJcbiAgICAgICAgdGhpcy5wZXJtYW5lbnQgfHxcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbnQgfHxcclxuICAgICAgICB0aGlzLnRlbXBvcmFyeSB8fFxyXG4gICAgICAgIHRoaXMuZHJhd2VyVHlwZVxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgb3BlbjogJ29uT3Blbl8nXHJcbiAgfSxcclxuICBjcmVhdGVkKCkge1xyXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cubWF0Y2hNZWRpYSkge1xyXG4gICAgICB0aGlzLnNtYWxsID0gbWVkaWEuc21hbGwubWF0Y2hlc1xyXG4gICAgICB0aGlzLmxhcmdlID0gbWVkaWEubGFyZ2UubWF0Y2hlc1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgbW91bnRlZCgpIHtcclxuICAgIGlmICh0aGlzLnRvZ2dsZU9uKSB7XHJcbiAgICAgIHRoaXMudG9nZ2xlT25FdmVudFNvdXJjZSA9IHRoaXMudG9nZ2xlT25Tb3VyY2UgfHwgdGhpcy4kcm9vdFxyXG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UuJG9uKHRoaXMudG9nZ2xlT24sIHRoaXMudG9nZ2xlRHJhd2VyKVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3Blbk9uKSB7XHJcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UgPSB0aGlzLm9wZW5PblNvdXJjZSB8fCB0aGlzLiRyb290XHJcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9uKHRoaXMub3Blbk9uLCB0aGlzLm9wZW5EcmF3ZXIpXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jbG9zZU9uKSB7XHJcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlID0gdGhpcy5jbG9zZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcclxuICAgICAgdGhpcy5jbG9zZU9uRXZlbnRTb3VyY2UuJG9uKHRoaXMuY2xvc2VPbiwgdGhpcy5jbG9zZURyYXdlcilcclxuICAgIH1cclxuICAgIG1lZGlhLnNtYWxsLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gICAgbWVkaWEubGFyZ2UuYWRkTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXHJcbiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB0aGlzLnJlZnJlc2hNZWRpYSgpKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSgpIHtcclxuICAgIG1lZGlhLnNtYWxsLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gICAgbWVkaWEubGFyZ2UucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXHJcblxyXG4gICAgaWYgKHRoaXMudG9nZ2xlT25FdmVudFNvdXJjZSkge1xyXG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLnRvZ2dsZU9uLCB0aGlzLnRvZ2dsZURyYXdlcilcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wZW5PbkV2ZW50U291cmNlKSB7XHJcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLm9wZW5PbiwgdGhpcy5vcGVuRHJhd2VyKVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY2xvc2VPbkV2ZW50U291cmNlKSB7XHJcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlLiRvZmYodGhpcy5jbG9zZU9uLCB0aGlzLmNsb3NlRHJhd2VyKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgb25PcGVuXyh2YWx1ZSkge1xyXG4gICAgICB0aGlzLmlzUGVybWFuZW50IHx8ICh0aGlzLm9wZW5fID0gdmFsdWUpXHJcbiAgICB9LFxyXG4gICAgb25DaGFuZ2UoZXZlbnQpIHtcclxuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQpXHJcbiAgICAgIHRoaXMuJHJvb3QuJGVtaXQoJ3ZtYTpsYXlvdXQnKVxyXG4gICAgfSxcclxuICAgIG9wZW5EcmF3ZXIoKSB7XHJcbiAgICAgIHRoaXMub3Blbl8gPSB0cnVlXHJcbiAgICB9LFxyXG4gICAgY2xvc2VEcmF3ZXIoKSB7XHJcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMub3Blbl8gPSBmYWxzZSlcclxuICAgIH0sXHJcbiAgICB0b2dnbGVEcmF3ZXIoKSB7XHJcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHxcclxuICAgICAgICAodGhpcy5pc09wZW4oKSA/IHRoaXMuY2xvc2VEcmF3ZXIoKSA6IHRoaXMub3BlbkRyYXdlcigpKVxyXG4gICAgfSxcclxuICAgIGlzT3BlbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaXNQZXJtYW5lbnQgfHwgdGhpcy5vcGVuX1xyXG4gICAgfSxcclxuICAgIHJlZnJlc2hNZWRpYSgpIHtcclxuICAgICAgdGhpcy5zbWFsbCA9IG1lZGlhLnNtYWxsLm1hdGNoZXNcclxuICAgICAgdGhpcy5sYXJnZSA9IG1lZGlhLmxhcmdlLm1hdGNoZXNcclxuICAgICAgaWYgKHRoaXMuaXNSZXNwb25zaXZlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFyZ2UpIHtcclxuICAgICAgICAgIHRoaXMub3BlbkRyYXdlcigpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuY2xvc2VEcmF3ZXIoKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlci1sYXlvdXRcIj5cbiAgICA8c2xvdCAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWxheW91dCdcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aGVhZGVyIFxuICAgIHYtaWY9XCJzaG93XCIgXG4gICAgY2xhc3M9XCJtZGMtZHJhd2VyLWhlYWRlciBtZGMtZHJhd2VyX19oZWFkZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlcl9faGVhZGVyLWNvbnRlbnRcIj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9kaXY+XG4gIDwvaGVhZGVyPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItaGVhZGVyJyxcbiAgcHJvcHM6IHtcbiAgICBwZXJtYW5lbnQ6IEJvb2xlYW4sXG4gICAgcGVyc2lzdGVudDogQm9vbGVhbixcbiAgICB0ZW1wb3Jhcnk6IEJvb2xlYW5cbiAgfSxcbiAgaW5qZWN0OiBbJ21kY0RyYXdlciddLFxuICBjb21wdXRlZDoge1xuICAgIHNob3coKSB7XG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnkgfHwgdGhpcy5wZXJzaXN0ZW50IHx8IHRoaXMucGVybWFuZW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHRoaXMudGVtcG9yYXJ5ICYmIHRoaXMubWRjRHJhd2VyLmlzVGVtcG9yYXJ5KSB8fFxuICAgICAgICAgICh0aGlzLnBlcnNpc3RlbnQgJiYgdGhpcy5tZGNEcmF3ZXIuaXNQZXJzaXN0ZW50KSB8fFxuICAgICAgICAgICh0aGlzLnBlcm1hbmVudCAmJiB0aGlzLm1kY0RyYXdlci5pc1Blcm1hbmVudClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bmF2IFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1kcmF3ZXItbGlzdCBtZGMtbGlzdFwiPlxuICAgIDxzbG90Lz5cbiAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1saXN0JyxcbiAgcHJvcHM6IHtcbiAgICBkZW5zZTogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtbGlzdC0tZGVuc2UnOiB0aGlzLmRlbnNlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgUmlwcGxlLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIENTUyB2YXJpYWJsZXNcbiAqIC0gcG9zaXRpb25cbiAqIC0gZGltZW5zaW9uc1xuICogLSBzY3JvbGwgcG9zaXRpb25cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqIC0gdW5ib3VuZGVkLCBhY3RpdmUgYW5kIGRpc2FibGVkIHN0YXRlc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDUmlwcGxlQWRhcHRlciB7XG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBicm93c2VyU3VwcG9ydHNDc3NWYXJzKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNVbmJvdW5kZWQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1N1cmZhY2VBY3RpdmUoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1N1cmZhY2VEaXNhYmxlZCgpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRUYXJnZXR9IHRhcmdldCAqL1xuICBjb250YWluc0V2ZW50VGFyZ2V0KHRhcmdldCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhck5hbWVcbiAgICogQHBhcmFtIHs/bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAgICovXG4gIHVwZGF0ZUNzc1ZhcmlhYmxlKHZhck5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshQ2xpZW50UmVjdH0gKi9cbiAgY29tcHV0ZUJvdW5kaW5nUmVjdCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19ICovXG4gIGdldFdpbmRvd1BhZ2VPZmZzZXQoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIC8vIFJpcHBsZSBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgXCJyb290XCIgY29tcG9uZW50IGlzIHJlYWxseSBhIFwibWl4aW5cIiBvZiBzb3J0cyxcbiAgLy8gZ2l2ZW4gdGhhdCBpdCdzIGFuICd1cGdyYWRlJyB0byBhbiBleGlzdGluZyBjb21wb25lbnQuIFRoYXQgYmVpbmcgc2FpZCBpdCBpcyB0aGUgcm9vdFxuICAvLyBDU1MgY2xhc3MgdGhhdCBhbGwgb3RoZXIgQ1NTIGNsYXNzZXMgZGVyaXZlIGZyb20uXG4gIFJPT1Q6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkJyxcbiAgVU5CT1VOREVEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tdW5ib3VuZGVkJyxcbiAgQkdfRk9DVVNFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWJhY2tncm91bmQtZm9jdXNlZCcsXG4gIEZHX0FDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWFjdGl2YXRpb24nLFxuICBGR19ERUFDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWRlYWN0aXZhdGlvbicsXG59O1xuXG5jb25zdCBzdHJpbmdzID0ge1xuICBWQVJfTEVGVDogJy0tbWRjLXJpcHBsZS1sZWZ0JyxcbiAgVkFSX1RPUDogJy0tbWRjLXJpcHBsZS10b3AnLFxuICBWQVJfRkdfU0laRTogJy0tbWRjLXJpcHBsZS1mZy1zaXplJyxcbiAgVkFSX0ZHX1NDQUxFOiAnLS1tZGMtcmlwcGxlLWZnLXNjYWxlJyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9TVEFSVDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtc3RhcnQnLFxuICBWQVJfRkdfVFJBTlNMQVRFX0VORDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kJyxcbn07XG5cbmNvbnN0IG51bWJlcnMgPSB7XG4gIFBBRERJTkc6IDEwLFxuICBJTklUSUFMX09SSUdJTl9TQ0FMRTogMC42LFxuICBERUFDVElWQVRJT05fVElNRU9VVF9NUzogMjI1LCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS10cmFuc2xhdGUtZHVyYXRpb24gKGkuZS4gYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXG4gIEZHX0RFQUNUSVZBVElPTl9NUzogMTUwLCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS1mYWRlLW91dC1kdXJhdGlvbiAoaS5lLiBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBUQVBfREVMQVlfTVM6IDMwMCwgLy8gRGVsYXkgYmV0d2VlbiB0b3VjaCBhbmQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBvbiB0b3VjaCBkZXZpY2VzXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogU3RvcmVzIHJlc3VsdCBmcm9tIHN1cHBvcnRzQ3NzVmFyaWFibGVzIHRvIGF2b2lkIHJlZHVuZGFudCBwcm9jZXNzaW5nIHRvIGRldGVjdCBDU1MgY3VzdG9tIHZhcmlhYmxlIHN1cHBvcnQuXG4gKiBAcHJpdmF0ZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cbmxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG5cbi8qKlxuICogU3RvcmVzIHJlc3VsdCBmcm9tIGFwcGx5UGFzc2l2ZSB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopIHtcbiAgLy8gRGV0ZWN0IHZlcnNpb25zIG9mIEVkZ2Ugd2l0aCBidWdneSB2YXIoKSBzdXBwb3J0XG4gIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTE0OTU0NDgvXG4gIGNvbnN0IGRvY3VtZW50ID0gd2luZG93T2JqLmRvY3VtZW50O1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG5vZGUuY2xhc3NOYW1lID0gJ21kYy1yaXBwbGUtc3VyZmFjZS0tdGVzdC1lZGdlLXZhci1idWcnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gIC8vIFRoZSBidWcgZXhpc3RzIGlmIDo6YmVmb3JlIHN0eWxlIGVuZHMgdXAgcHJvcGFnYXRpbmcgdG8gdGhlIHBhcmVudCBlbGVtZW50LlxuICAvLyBBZGRpdGlvbmFsbHksIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBudWxsIGluIGlmcmFtZXMgd2l0aCBkaXNwbGF5OiBcIm5vbmVcIiBpbiBGaXJlZm94LFxuICAvLyBidXQgRmlyZWZveCBpcyBrbm93biB0byBzdXBwb3J0IENTUyBjdXN0b20gcHJvcGVydGllcyBjb3JyZWN0bHkuXG4gIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3dPYmouZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgY29uc3QgaGFzUHNldWRvVmFyQnVnID0gY29tcHV0ZWRTdHlsZSAhPT0gbnVsbCAmJiBjb21wdXRlZFN0eWxlLmJvcmRlclRvcFN0eWxlID09PSAnc29saWQnO1xuICBub2RlLnJlbW92ZSgpO1xuICByZXR1cm4gaGFzUHNldWRvVmFyQnVnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IVdpbmRvd30gd2luZG93T2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvd09iaiwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgbGV0IHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9PT0gJ2Jvb2xlYW4nICYmICFmb3JjZVJlZnJlc2gpIHtcbiAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXM7XG4gIH1cblxuICBjb25zdCBzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCA9IHdpbmRvd09iai5DU1MgJiYgdHlwZW9mIHdpbmRvd09iai5DU1Muc3VwcG9ydHMgPT09ICdmdW5jdGlvbic7XG4gIGlmICghc3VwcG9ydHNGdW5jdGlvblByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzID0gd2luZG93T2JqLkNTUy5zdXBwb3J0cygnLS1jc3MtdmFycycsICd5ZXMnKTtcbiAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU0NjY5XG4gIC8vIFNlZTogUkVBRE1FIHNlY3Rpb24gb24gU2FmYXJpXG4gIGNvbnN0IHdlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cyA9IChcbiAgICB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzKCcoLS1jc3MtdmFyczogeWVzKScpICYmXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnY29sb3InLCAnIzAwMDAwMDAwJylcbiAgKTtcblxuICBpZiAoZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyB8fCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMpIHtcbiAgICBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9ICFkZXRlY3RFZGdlUHNldWRvVmFyQnVnKHdpbmRvd09iaik7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXNfID0gc3VwcG9ydHNDc3NWYXJpYWJsZXM7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xufVxuXG4vL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3R9IEhUTUxFbGVtZW50UHJvdG90eXBlXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlKSB7XG4gIHJldHVybiBbXG4gICAgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdtYXRjaGVzJyxcbiAgXS5maWx0ZXIoKHApID0+IHAgaW4gSFRNTEVsZW1lbnRQcm90b3R5cGUpLnBvcCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUV2ZW50fSBldlxuICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwYWdlT2Zmc2V0XG4gKiBAcGFyYW0geyFDbGllbnRSZWN0fSBjbGllbnRSZWN0XG4gKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICovXG5mdW5jdGlvbiBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoZXYsIHBhZ2VPZmZzZXQsIGNsaWVudFJlY3QpIHtcbiAgY29uc3Qge3gsIHl9ID0gcGFnZU9mZnNldDtcbiAgY29uc3QgZG9jdW1lbnRYID0geCArIGNsaWVudFJlY3QubGVmdDtcbiAgY29uc3QgZG9jdW1lbnRZID0geSArIGNsaWVudFJlY3QudG9wO1xuXG4gIGxldCBub3JtYWxpemVkWDtcbiAgbGV0IG5vcm1hbGl6ZWRZO1xuICAvLyBEZXRlcm1pbmUgdG91Y2ggcG9pbnQgcmVsYXRpdmUgdG8gdGhlIHJpcHBsZSBjb250YWluZXIuXG4gIGlmIChldi50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBub3JtYWxpemVkWCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgIG5vcm1hbGl6ZWRZID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBkb2N1bWVudFk7XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9XG5cbiAgcmV0dXJuIHt4OiBub3JtYWxpemVkWCwgeTogbm9ybWFsaXplZFl9O1xufVxuXG5leHBvcnQge3N1cHBvcnRzQ3NzVmFyaWFibGVzLCBhcHBseVBhc3NpdmUsIGdldE1hdGNoZXNQcm9wZXJ0eSwgZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Z2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzQWN0aXZhdGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgYWN0aXZhdGlvbkV2ZW50OiBFdmVudCxcbiAqICAgaXNQcm9ncmFtbWF0aWM6IChib29sZWFufHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBBY3RpdmF0aW9uU3RhdGVUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGRlYWN0aXZhdGU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgZm9jdXM6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgYmx1cjogKHN0cmluZ3x1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgTGlzdGVuZXJJbmZvVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZm9jdXM6IGZ1bmN0aW9uKCksXG4gKiAgIGJsdXI6IGZ1bmN0aW9uKClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lcnNUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHg6IG51bWJlcixcbiAqICAgeTogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgUG9pbnRUeXBlO1xuXG4vLyBBY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIHRoZSByb290IGVsZW1lbnQgb2YgZWFjaCBpbnN0YW5jZSBmb3IgYWN0aXZhdGlvblxuY29uc3QgQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nLCAna2V5ZG93biddO1xuXG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbmNvbnN0IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gWyd0b3VjaGVuZCcsICdwb2ludGVydXAnLCAnbW91c2V1cCddO1xuXG4vLyBUcmFja3MgYWN0aXZhdGlvbnMgdGhhdCBoYXZlIG9jY3VycmVkIG9uIHRoZSBjdXJyZW50IGZyYW1lLCB0byBhdm9pZCBzaW11bHRhbmVvdXMgbmVzdGVkIGFjdGl2YXRpb25zXG4vKiogQHR5cGUgeyFBcnJheTwhRXZlbnRUYXJnZXQ+fSAqL1xubGV0IGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmlwcGxlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gLyogYm9vbGVhbiAtIGNhY2hlZCAqLyB7fSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKC8qIHRhcmdldDogIUV2ZW50VGFyZ2V0ICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyB7fSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IC8qIHt4OiBudW1iZXIsIHk6IG51bWJlcn0gKi8ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUNsaWVudFJlY3R9ICovXG4gICAgdGhpcy5mcmFtZV8gPSAvKiogQHR5cGUgeyFDbGllbnRSZWN0fSAqLyAoe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5hY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5kZWFjdGl2YXRlXyhlKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgKCkgPT4gdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRClcbiAgICApO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbig/RXZlbnQ9KX0gKi9cbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICgpID0+IHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpXG4gICAgKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuXG4gICAgLyoqIEBwcml2YXRlIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyfX0gKi9cbiAgICB0aGlzLnVuYm91bmRlZENvb3Jkc18gPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmZnU2NhbGVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IHRydWU7XG4gICAgICB0aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpO1xuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUgez9FdmVudH0gKi9cbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2UgY29tcHV0ZSB0aGlzIHByb3BlcnR5IHNvIHRoYXQgd2UgYXJlIG5vdCBxdWVyeWluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2xpZW50XG4gICAqIHVudGlsIHRoZSBwb2ludCBpbiB0aW1lIHdoZXJlIHRoZSBmb3VuZGF0aW9uIHJlcXVlc3RzIGl0LiBUaGlzIHByZXZlbnRzIHNjZW5hcmlvcyB3aGVyZVxuICAgKiBjbGllbnQtc2lkZSBmZWF0dXJlLWRldGVjdGlvbiBtYXkgaGFwcGVuIHRvbyBlYXJseSwgc3VjaCBhcyB3aGVuIGNvbXBvbmVudHMgYXJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXJcbiAgICogYW5kIHRoZW4gaW5pdGlhbGl6ZWQgYXQgbW91bnQgdGltZSBvbiB0aGUgY2xpZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNTdXBwb3J0ZWRfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQWN0aXZhdGlvblN0YXRlVHlwZX1cbiAgICovXG4gIGRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0FjdGl2YXRlZDogZmFsc2UsXG4gICAgICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogZmFsc2UsXG4gICAgICB3YXNBY3RpdmF0ZWRCeVBvaW50ZXI6IGZhbHNlLFxuICAgICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IGZhbHNlLFxuICAgICAgYWN0aXZhdGlvbkV2ZW50OiBudWxsLFxuICAgICAgaXNQcm9ncmFtbWF0aWM6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZF8oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpO1xuXG4gICAgY29uc3Qge1JPT1QsIFVOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoUk9PVCk7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoVU5CT1VOREVEKTtcbiAgICAgICAgLy8gVW5ib3VuZGVkIHJpcHBsZXMgbmVlZCBsYXlvdXQgbG9naWMgYXBwbGllZCBpbW1lZGlhdGVseSB0byBzZXQgY29vcmRpbmF0ZXMgZm9yIGJvdGggc2hhZGUgYW5kIHJpcHBsZVxuICAgICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hY3RpdmF0aW9uVGltZXJfKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXJfKTtcbiAgICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyXyA9IDA7XG4gICAgICBjb25zdCB7RkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgIH1cblxuICAgIHRoaXMuZGVyZWdpc3RlclJvb3RIYW5kbGVyc18oKTtcbiAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKTtcblxuICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFJPT1QpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgdGhpcy5yZW1vdmVDc3NWYXJzXygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpIHtcbiAgICBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oZSkge1xuICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBkZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpIHtcbiAgICBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVtb3ZlQ3NzVmFyc18oKSB7XG4gICAgY29uc3Qge3N0cmluZ3N9ID0gTURDUmlwcGxlRm91bmRhdGlvbjtcbiAgICBPYmplY3Qua2V5cyhzdHJpbmdzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBpZiAoay5pbmRleE9mKCdWQVJfJykgPT09IDApIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShzdHJpbmdzW2tdLCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWN0aXZhdGVfKGUpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1N1cmZhY2VEaXNhYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCByZWFjdGluZyB0byBmb2xsb3ctb24gZXZlbnRzIGZpcmVkIGJ5IHRvdWNoIGRldmljZSBhZnRlciBhbiBhbHJlYWR5LXByb2Nlc3NlZCB1c2VyIGludGVyYWN0aW9uXG4gICAgY29uc3QgcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgPSB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XztcbiAgICBjb25zdCBpc1NhbWVJbnRlcmFjdGlvbiA9IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ICYmIGUgJiYgcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQudHlwZSAhPT0gZS50eXBlO1xuICAgIGlmIChpc1NhbWVJbnRlcmFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCA9IHRydWU7XG4gICAgYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljID0gZSA9PT0gbnVsbDtcbiAgICBhY3RpdmF0aW9uU3RhdGUuYWN0aXZhdGlvbkV2ZW50ID0gZTtcbiAgICBhY3RpdmF0aW9uU3RhdGUud2FzQWN0aXZhdGVkQnlQb2ludGVyID0gYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljID8gZmFsc2UgOiAoXG4gICAgICBlLnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGUudHlwZSA9PT0gJ3BvaW50ZXJkb3duJ1xuICAgICk7XG5cbiAgICBjb25zdCBoYXNBY3RpdmF0ZWRDaGlsZCA9XG4gICAgICBlICYmIGFjdGl2YXRlZFRhcmdldHMubGVuZ3RoID4gMCAmJiBhY3RpdmF0ZWRUYXJnZXRzLnNvbWUoKHRhcmdldCkgPT4gdGhpcy5hZGFwdGVyXy5jb250YWluc0V2ZW50VGFyZ2V0KHRhcmdldCkpO1xuICAgIGlmIChoYXNBY3RpdmF0ZWRDaGlsZCkge1xuICAgICAgLy8gSW1tZWRpYXRlbHkgcmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSwgd2hpbGUgcHJlc2VydmluZyBsb2dpYyB0aGF0IHByZXZlbnRzIHRvdWNoIGZvbGxvdy1vbiBldmVudHNcbiAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGUpIHtcbiAgICAgIGFjdGl2YXRlZFRhcmdldHMucHVzaCgvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKGUudGFyZ2V0KSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKGUpO1xuICAgIH1cblxuICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IHRoaXMuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSk7XG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgdGhpcy5hbmltYXRlQWN0aXZhdGlvbl8oKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgLy8gUmVzZXQgYXJyYXkgb24gbmV4dCBmcmFtZSBhZnRlciB0aGUgY3VycmVudCBldmVudCBoYXMgaGFkIGEgY2hhbmNlIHRvIGJ1YmJsZSB0byBwcmV2ZW50IGFuY2VzdG9yIHJpcHBsZXNcbiAgICAgIGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcblxuICAgICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgJiYgKGUua2V5ID09PSAnICcgfHwgZS5rZXlDb2RlID09PSAzMikpIHtcbiAgICAgICAgLy8gSWYgc3BhY2Ugd2FzIHByZXNzZWQsIHRyeSBhZ2FpbiB3aXRoaW4gYW4gckFGIGNhbGwgdG8gZGV0ZWN0IDphY3RpdmUsIGJlY2F1c2UgZGlmZmVyZW50IFVBcyByZXBvcnRcbiAgICAgICAgLy8gYWN0aXZlIHN0YXRlcyBpbmNvbnNpc3RlbnRseSB3aGVuIHRoZXkncmUgY2FsbGVkIHdpdGhpbiBldmVudCBoYW5kbGluZyBjb2RlOlxuICAgICAgICAvLyAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYzNTk3MVxuICAgICAgICAvLyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTM3NDFcbiAgICAgICAgLy8gV2UgdHJ5IGZpcnN0IG91dHNpZGUgckFGIHRvIHN1cHBvcnQgRWRnZSwgd2hpY2ggZG9lcyBub3QgZXhoaWJpdCB0aGlzIHByb2JsZW0sIGJ1dCB3aWxsIGNyYXNoIGlmIGEgQ1NTXG4gICAgICAgIC8vIHZhcmlhYmxlIGlzIHNldCB3aXRoaW4gYSByQUYgY2FsbGJhY2sgZm9yIGEgc3VibWl0IGJ1dHRvbiBpbnRlcmFjdGlvbiAoIzIyNDEpLlxuICAgICAgICBhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgPSB0aGlzLmNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpO1xuICAgICAgICBpZiAoYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRlQWN0aXZhdGlvbl8oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgICAvLyBSZXNldCBhY3RpdmF0aW9uIHN0YXRlIGltbWVkaWF0ZWx5IGlmIGVsZW1lbnQgd2FzIG5vdCBtYWRlIGFjdGl2ZS5cbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKSB7XG4gICAgcmV0dXJuIChlICYmIGUudHlwZSA9PT0gJ2tleWRvd24nKSA/IHRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlQWN0aXZlKCkgOiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50PX0gZXZlbnQgT3B0aW9uYWwgZXZlbnQgY29udGFpbmluZyBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGFjdGl2YXRlKGV2ZW50ID0gbnVsbCkge1xuICAgIHRoaXMuYWN0aXZhdGVfKGV2ZW50KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBhbmltYXRlQWN0aXZhdGlvbl8oKSB7XG4gICAgY29uc3Qge1ZBUl9GR19UUkFOU0xBVEVfU1RBUlQsIFZBUl9GR19UUkFOU0xBVEVfRU5EfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uc3RyaW5ncztcbiAgICBjb25zdCB7RkdfREVBQ1RJVkFUSU9OLCBGR19BQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBjb25zdCB7REVBQ1RJVkFUSU9OX1RJTUVPVVRfTVN9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzO1xuXG4gICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcblxuICAgIGxldCB0cmFuc2xhdGVTdGFydCA9ICcnO1xuICAgIGxldCB0cmFuc2xhdGVFbmQgPSAnJztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICBjb25zdCB7c3RhcnRQb2ludCwgZW5kUG9pbnR9ID0gdGhpcy5nZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCk7XG4gICAgICB0cmFuc2xhdGVTdGFydCA9IGAke3N0YXJ0UG9pbnQueH1weCwgJHtzdGFydFBvaW50Lnl9cHhgO1xuICAgICAgdHJhbnNsYXRlRW5kID0gYCR7ZW5kUG9pbnQueH1weCwgJHtlbmRQb2ludC55fXB4YDtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19UUkFOU0xBVEVfU1RBUlQsIHRyYW5zbGF0ZVN0YXJ0KTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19UUkFOU0xBVEVfRU5ELCB0cmFuc2xhdGVFbmQpO1xuICAgIC8vIENhbmNlbCBhbnkgb25nb2luZyBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiBhbmltYXRpb25zXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfKTtcbiAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcblxuICAgIC8vIEZvcmNlIGxheW91dCBpbiBvcmRlciB0byByZS10cmlnZ2VyIHRoZSBhbmltYXRpb24uXG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfKCksIERFQUNUSVZBVElPTl9USU1FT1VUX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHt7c3RhcnRQb2ludDogUG9pbnRUeXBlLCBlbmRQb2ludDogUG9pbnRUeXBlfX1cbiAgICovXG4gIGdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18oKSB7XG4gICAgY29uc3Qge2FjdGl2YXRpb25FdmVudCwgd2FzQWN0aXZhdGVkQnlQb2ludGVyfSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcblxuICAgIGxldCBzdGFydFBvaW50O1xuICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIpIHtcbiAgICAgIHN0YXJ0UG9pbnQgPSBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoXG4gICAgICAgIC8qKiBAdHlwZSB7IUV2ZW50fSAqLyAoYWN0aXZhdGlvbkV2ZW50KSxcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5nZXRXaW5kb3dQYWdlT2Zmc2V0KCksIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBvaW50ID0ge1xuICAgICAgICB4OiB0aGlzLmZyYW1lXy53aWR0aCAvIDIsXG4gICAgICAgIHk6IHRoaXMuZnJhbWVfLmhlaWdodCAvIDIsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBDZW50ZXIgdGhlIGVsZW1lbnQgYXJvdW5kIHRoZSBzdGFydCBwb2ludC5cbiAgICBzdGFydFBvaW50ID0ge1xuICAgICAgeDogc3RhcnRQb2ludC54IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgICB5OiBzdGFydFBvaW50LnkgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICB9O1xuXG4gICAgY29uc3QgZW5kUG9pbnQgPSB7XG4gICAgICB4OiAodGhpcy5mcmFtZV8ud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogKHRoaXMuZnJhbWVfLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIHJldHVybiB7c3RhcnRQb2ludCwgZW5kUG9pbnR9O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYm90aCB3aGVuIGEgcG9pbnRpbmcgZGV2aWNlIGlzIHJlbGVhc2VkLCBhbmQgd2hlbiB0aGUgYWN0aXZhdGlvbiBhbmltYXRpb24gZW5kcy5cbiAgICAvLyBUaGUgZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBzaG91bGQgb25seSBydW4gYWZ0ZXIgYm90aCBvZiB0aG9zZSBvY2N1ci5cbiAgICBjb25zdCB7RkdfREVBQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBjb25zdCB7aGFzRGVhY3RpdmF0aW9uVVhSdW4sIGlzQWN0aXZhdGVkfSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICBjb25zdCBhY3RpdmF0aW9uSGFzRW5kZWQgPSBoYXNEZWFjdGl2YXRpb25VWFJ1biB8fCAhaXNBY3RpdmF0ZWQ7XG5cbiAgICBpZiAoYWN0aXZhdGlvbkhhc0VuZGVkICYmIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXykge1xuICAgICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgIH0sIG51bWJlcnMuRkdfREVBQ1RJVkFUSU9OX01TKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCkge1xuICAgIGNvbnN0IHtGR19BQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICB9XG5cbiAgcmVzZXRBY3RpdmF0aW9uU3RhdGVfKCkge1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfLmFjdGl2YXRpb25FdmVudDtcbiAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8gPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgLy8gVG91Y2ggZGV2aWNlcyBtYXkgZmlyZSBhZGRpdGlvbmFsIGV2ZW50cyBmb3IgdGhlIHNhbWUgaW50ZXJhY3Rpb24gd2l0aGluIGEgc2hvcnQgdGltZS5cbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXMgZXZlbnQgdW50aWwgaXQncyBzYWZlIHRvIGFzc3VtZSB0aGF0IHN1YnNlcXVlbnQgZXZlbnRzIGFyZSBmb3IgbmV3IGludGVyYWN0aW9ucy5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gbnVsbCwgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlRBUF9ERUxBWV9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlYWN0aXZhdGVfKGUpIHtcbiAgICBjb25zdCBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIHNjZW5hcmlvcyBzdWNoIGFzIHdoZW4geW91IGhhdmUgYSBrZXl1cCBldmVudCB0aGF0IGJsdXJzIHRoZSBlbGVtZW50LlxuICAgIGlmICghYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSAvKiogQHR5cGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqLyAoT2JqZWN0LmFzc2lnbih7fSwgYWN0aXZhdGlvblN0YXRlKSk7XG5cbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljKSB7XG4gICAgICBjb25zdCBldnRPYmplY3QgPSBudWxsO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbl8oZXZ0T2JqZWN0LCBzdGF0ZSkpO1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8uaGFzRGVhY3RpdmF0aW9uVVhSdW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKGUsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBkZWFjdGl2YXRlKGV2ZW50ID0gbnVsbCkge1xuICAgIHRoaXMuZGVhY3RpdmF0ZV8oZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYW5pbWF0ZURlYWN0aXZhdGlvbl8oZSwge3dhc0FjdGl2YXRlZEJ5UG9pbnRlciwgd2FzRWxlbWVudE1hZGVBY3RpdmV9KSB7XG4gICAgaWYgKHdhc0FjdGl2YXRlZEJ5UG9pbnRlciB8fCB3YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0RnJhbWVfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxheW91dEZyYW1lXyk7XG4gICAgfVxuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgbGF5b3V0SW50ZXJuYWxfKCkge1xuICAgIHRoaXMuZnJhbWVfID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgodGhpcy5mcmFtZV8uaGVpZ2h0LCB0aGlzLmZyYW1lXy53aWR0aCk7XG5cbiAgICAvLyBTdXJmYWNlIGRpYW1ldGVyIGlzIHRyZWF0ZWQgZGlmZmVyZW50bHkgZm9yIHVuYm91bmRlZCB2cy4gYm91bmRlZCByaXBwbGVzLlxuICAgIC8vIFVuYm91bmRlZCByaXBwbGUgZGlhbWV0ZXIgaXMgY2FsY3VsYXRlZCBzbWFsbGVyIHNpbmNlIHRoZSBzdXJmYWNlIGlzIGV4cGVjdGVkIHRvIGFscmVhZHkgYmUgcGFkZGVkIGFwcHJvcHJpYXRlbHlcbiAgICAvLyB0byBleHRlbmQgdGhlIGhpdGJveCwgYW5kIHRoZSByaXBwbGUgaXMgZXhwZWN0ZWQgdG8gbWVldCB0aGUgZWRnZXMgb2YgdGhlIHBhZGRlZCBoaXRib3ggKHdoaWNoIGlzIHR5cGljYWxseVxuICAgIC8vIHNxdWFyZSkuIEJvdW5kZWQgcmlwcGxlcywgb24gdGhlIG90aGVyIGhhbmQsIGFyZSBmdWxseSBleHBlY3RlZCB0byBleHBhbmQgYmV5b25kIHRoZSBzdXJmYWNlJ3MgbG9uZ2VzdCBkaWFtZXRlclxuICAgIC8vIChjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkaWFnb25hbCBwbHVzIGEgY29uc3RhbnQgcGFkZGluZyksIGFuZCBhcmUgY2xpcHBlZCBhdCB0aGUgc3VyZmFjZSdzIGJvcmRlciB2aWFcbiAgICAvLyBgb3ZlcmZsb3c6IGhpZGRlbmAuXG4gICAgY29uc3QgZ2V0Qm91bmRlZFJhZGl1cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGh5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5mcmFtZV8ud2lkdGgsIDIpICsgTWF0aC5wb3codGhpcy5mcmFtZV8uaGVpZ2h0LCAyKSk7XG4gICAgICByZXR1cm4gaHlwb3RlbnVzZSArIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5QQURESU5HO1xuICAgIH07XG5cbiAgICB0aGlzLm1heFJhZGl1c18gPSB0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkgPyBtYXhEaW0gOiBnZXRCb3VuZGVkUmFkaXVzKCk7XG5cbiAgICAvLyBSaXBwbGUgaXMgc2l6ZWQgYXMgYSBmcmFjdGlvbiBvZiB0aGUgbGFyZ2VzdCBkaW1lbnNpb24gb2YgdGhlIHN1cmZhY2UsIHRoZW4gc2NhbGVzIHVwIHVzaW5nIGEgQ1NTIHNjYWxlIHRyYW5zZm9ybVxuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gbWF4RGltICogTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLklOSVRJQUxfT1JJR0lOX1NDQUxFO1xuICAgIHRoaXMuZmdTY2FsZV8gPSB0aGlzLm1heFJhZGl1c18gLyB0aGlzLmluaXRpYWxTaXplXztcblxuICAgIHRoaXMudXBkYXRlTGF5b3V0Q3NzVmFyc18oKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1cGRhdGVMYXlvdXRDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7XG4gICAgICBWQVJfRkdfU0laRSwgVkFSX0xFRlQsIFZBUl9UT1AsIFZBUl9GR19TQ0FMRSxcbiAgICB9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0laRSwgYCR7dGhpcy5pbml0aWFsU2l6ZV99cHhgKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19TQ0FMRSwgdGhpcy5mZ1NjYWxlXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLnVuYm91bmRlZENvb3Jkc18gPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSksXG4gICAgICAgIHRvcDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZV8uaGVpZ2h0IC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9MRUZULCBgJHt0aGlzLnVuYm91bmRlZENvb3Jkc18ubGVmdH1weGApO1xuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfVE9QLCBgJHt0aGlzLnVuYm91bmRlZENvb3Jkc18udG9wfXB4YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdW5ib3VuZGVkICovXG4gIHNldFVuYm91bmRlZCh1bmJvdW5kZWQpIHtcbiAgICBjb25zdCB7VU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAodW5ib3VuZGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoVU5CT1VOREVEKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlRm91bmRhdGlvbjtcbiIsImltcG9ydCBNRENSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUvZm91bmRhdGlvbi5qcydcbmltcG9ydCB7XG4gIHN1cHBvcnRzQ3NzVmFyaWFibGVzLFxuICBnZXRNYXRjaGVzUHJvcGVydHksXG4gIGFwcGx5UGFzc2l2ZVxufSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL3V0aWwnXG5cbmV4cG9ydCBjbGFzcyBSaXBwbGVCYXNlIGV4dGVuZHMgTURDUmlwcGxlRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgTUFUQ0hFUygpIHtcbiAgICAvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbiAgICByZXR1cm4gKFxuICAgICAgUmlwcGxlQmFzZS5fbWF0Y2hlcyB8fFxuICAgICAgKFJpcHBsZUJhc2UuX21hdGNoZXMgPSBnZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlKSlcbiAgICApXG4gIH1cblxuICBzdGF0aWMgaXNTdXJmYWNlQWN0aXZlKHJlZikge1xuICAgIHJldHVybiByZWZbUmlwcGxlQmFzZS5NQVRDSEVTXSgnOmFjdGl2ZScpXG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2bSwgb3B0aW9ucykge1xuICAgIHN1cGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3cpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc1VuYm91bmRlZDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2bS4kZWxbUmlwcGxlQmFzZS5NQVRDSEVTXSgnOmFjdGl2ZScpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc1N1cmZhY2VEaXNhYmxlZDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZtLmRpc2FibGVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZGRDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZtLiRzZXQodm0uY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2bS4kZGVsZXRlKHZtLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6IHRhcmdldCA9PiB2bS4kZWwuY29udGFpbnModGFyZ2V0KSxcbiAgICAgICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgdm0uJGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHZtLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBldnRUeXBlLFxuICAgICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgICBhcHBseVBhc3NpdmUoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgIGV2dFR5cGUsXG4gICAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICAgIGFwcGx5UGFzc2l2ZSgpXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKHZhck5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2bS4kc2V0KHZtLnN0eWxlcywgdmFyTmFtZSwgdmFsdWUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdm0uJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiB3aW5kb3cucGFnZVhPZmZzZXQsIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBSaXBwbGVNaXhpbiA9IHtcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBcbiAgICA6bGluaz1cImxpbmtcIlxyXG4gICAgOmNsYXNzPVwiW2NsYXNzZXMsIGl0ZW1DbGFzc2VzXVwiXHJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1kcmF3ZXItaXRlbSBtZGMtbGlzdC1pdGVtXCJcclxuICAgIHYtb249XCJteWxpc3RlbmVyc1wiPlxyXG4gICAgPHNwYW4gXG4gICAgICB2LWlmPVwiaGFzU3RhcnREZXRhaWxcIiBcbiAgICAgIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fZ3JhcGhpY1wiPlxyXG4gICAgICA8c2xvdCBuYW1lPVwic3RhcnQtZGV0YWlsXCI+XHJcbiAgICAgICAgPGkgXG4gICAgICAgICAgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiIFxuICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnt7IHN0YXJ0SWNvbiB9fTwvaT5cclxuICAgICAgPC9zbG90PlxyXG4gICAgPC9zcGFuPlxyXG4gICAgPHNsb3QvPlxyXG4gIDwvY3VzdG9tLWxpbms+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUxpbmtNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXHJcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1kcmF3ZXItaXRlbScsXHJcbiAgaW5qZWN0OiBbJ21kY0RyYXdlciddLFxyXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgc3RhcnRJY29uOiBTdHJpbmcsXHJcbiAgICB0ZW1wb3JhcnlDbG9zZToge1xyXG4gICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICB9LFxyXG4gICAgYWN0aXZhdGVkOiBCb29sZWFuLFxyXG4gICAgZXhhY3RBY3RpdmVDbGFzczoge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIGRlZmF1bHQ6ICdtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWQnXHJcbiAgICB9XHJcbiAgfSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge30sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBteWxpc3RlbmVycygpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi50aGlzLiRsaXN0ZW5lcnMsXHJcbiAgICAgICAgY2xpY2s6IGUgPT4ge1xyXG4gICAgICAgICAgdGhpcy5tZGNEcmF3ZXIuaXNUZW1wb3JhcnkgJiZcclxuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlDbG9zZSAmJlxyXG4gICAgICAgICAgICB0aGlzLm1kY0RyYXdlci5jbG9zZURyYXdlcigpXHJcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpdGVtQ2xhc3NlcygpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGhhc1N0YXJ0RGV0YWlsKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zdGFydEljb24gfHwgdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkKCkge1xyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxyXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgICB0aGlzLnJpcHBsZSA9IG51bGxcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgPGhyIGNsYXNzPVwibWRjLWxpc3QtZGl2aWRlclwiPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItZGl2aWRlcidcbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRHJhd2VyIGZyb20gJy4vbWRjLWRyYXdlci52dWUnXG5pbXBvcnQgbWRjRHJhd2VyTGF5b3V0IGZyb20gJy4vbWRjLWRyYXdlci1sYXlvdXQudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckhlYWRlciBmcm9tICcuL21kYy1kcmF3ZXItaGVhZGVyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJMaXN0IGZyb20gJy4vbWRjLWRyYXdlci1saXN0LnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJJdGVtIGZyb20gJy4vbWRjLWRyYXdlci1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJEaXZpZGVyIGZyb20gJy4vbWRjLWRyYXdlci1kaXZpZGVyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjRHJhd2VyLFxuICBtZGNEcmF3ZXJMYXlvdXQsXG4gIG1kY0RyYXdlckhlYWRlcixcbiAgbWRjRHJhd2VyTGlzdCxcbiAgbWRjRHJhd2VySXRlbSxcbiAgbWRjRHJhd2VyRGl2aWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRHJhd2VyLFxuICBtZGNEcmF3ZXJMYXlvdXQsXG4gIG1kY0RyYXdlckhlYWRlcixcbiAgbWRjRHJhd2VyTGlzdCxcbiAgbWRjRHJhd2VySXRlbSxcbiAgbWRjRHJhd2VyRGl2aWRlclxufSlcbiIsImltcG9ydCAnLi9zdHlsZXMuc2NzcydcbmltcG9ydCB7IGF1dG9Jbml0IH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBwbHVnaW4gZnJvbSAnLi9pbmRleC5qcydcbmV4cG9ydCBkZWZhdWx0IHBsdWdpblxuXG5hdXRvSW5pdChwbHVnaW4pXG4iXSwibmFtZXMiOlsiYXV0b0luaXQiLCJwbHVnaW4iLCJfVnVlIiwid2luZG93IiwiVnVlIiwiZ2xvYmFsIiwidXNlIiwiQmFzZVBsdWdpbiIsImNvbXBvbmVudHMiLCJ2ZXJzaW9uIiwiaW5zdGFsbCIsImtleSIsImNvbXBvbmVudCIsInZtIiwibmFtZSIsIkN1c3RvbUxpbmsiLCJmdW5jdGlvbmFsIiwicHJvcHMiLCJ0YWciLCJ0eXBlIiwiU3RyaW5nIiwiZGVmYXVsdCIsImxpbmsiLCJPYmplY3QiLCJyZW5kZXIiLCJoIiwiY29udGV4dCIsImVsZW1lbnQiLCJkYXRhIiwiYmFiZWxIZWxwZXJzLmV4dGVuZHMiLCJwYXJlbnQiLCIkcm91dGVyIiwiJHJvb3QiLCIkb3B0aW9ucyIsIm9uIiwiY2xpY2siLCJuYXRpdmVPbiIsImNoaWxkcmVuIiwiQ3VzdG9tTGlua01peGluIiwidG8iLCJleGFjdCIsIkJvb2xlYW4iLCJhcHBlbmQiLCJyZXBsYWNlIiwiYWN0aXZlQ2xhc3MiLCJleGFjdEFjdGl2ZUNsYXNzIiwiY29tcHV0ZWQiLCJEaXNwYXRjaEV2ZW50TWl4aW4iLCJldmVudCIsIkFycmF5IiwibWV0aG9kcyIsImRpc3BhdGNoRXZlbnQiLCJldnQiLCIkZW1pdCIsInRhcmdldCIsImV2ZW50VGFyZ2V0IiwiYXJncyIsImV2ZW50QXJncyIsImxpc3RlbmVycyIsIiRsaXN0ZW5lcnMiLCJlIiwiRk9DVVNBQkxFX0VMRU1FTlRTIiwiTURDRm91bmRhdGlvbiIsImFkYXB0ZXIiLCJhZGFwdGVyXyIsIk1EQ0NvbXBvbmVudCIsInJvb3QiLCJmb3VuZGF0aW9uIiwidW5kZWZpbmVkIiwicm9vdF8iLCJpbml0aWFsaXplIiwiZm91bmRhdGlvbl8iLCJnZXREZWZhdWx0Rm91bmRhdGlvbiIsImluaXQiLCJpbml0aWFsU3luY1dpdGhET00iLCJFcnJvciIsImRlc3Ryb3kiLCJldnRUeXBlIiwiaGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZ0RGF0YSIsInNob3VsZEJ1YmJsZSIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiYnViYmxlcyIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24iLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwiaGFzQ2xhc3MiLCJoYXNOZWNlc3NhcnlEb20iLCJyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyIiwiZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyIiwicmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIiLCJzZXRUcmFuc2xhdGVYIiwiZ2V0Rm9jdXNhYmxlRWxlbWVudHMiLCJzYXZlRWxlbWVudFRhYlN0YXRlIiwicmVzdG9yZUVsZW1lbnRUYWJTdGF0ZSIsIm1ha2VFbGVtZW50VW50YWJiYWJsZSIsIm5vdGlmeU9wZW4iLCJub3RpZnlDbG9zZSIsImlzUnRsIiwiZ2V0RHJhd2VyV2lkdGgiLCJyb290Q3NzQ2xhc3MiLCJhbmltYXRpbmdDc3NDbGFzcyIsIm9wZW5Dc3NDbGFzcyIsImRlZmF1bHRBZGFwdGVyIiwicm9vdENzc0NsYXNzXyIsImFuaW1hdGluZ0Nzc0NsYXNzXyIsIm9wZW5Dc3NDbGFzc18iLCJ0cmFuc2l0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVUcmFuc2l0aW9uRW5kXyIsImluZXJ0XyIsImNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyIsImhhbmRsZVRvdWNoU3RhcnRfIiwiY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8iLCJoYW5kbGVUb3VjaE1vdmVfIiwiY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyIsImhhbmRsZVRvdWNoRW5kXyIsImRvY3VtZW50S2V5ZG93bkhhbmRsZXJfIiwia2V5Q29kZSIsImNsb3NlIiwiUk9PVCIsIk9QRU4iLCJpc09wZW5fIiwiZGV0YWJpbmF0ZV8iLCJyZXRhYmluYXRlXyIsImVsZW1lbnRzIiwiaSIsImxlbmd0aCIsInBvaW50ZXJUeXBlIiwiZGlyZWN0aW9uXyIsImRyYXdlcldpZHRoXyIsInN0YXJ0WF8iLCJ0b3VjaGVzIiwicGFnZVgiLCJjdXJyZW50WF8iLCJ1cGRhdGVSYWZfIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlRHJhd2VyXyIsImJpbmQiLCJwcmVwYXJlRm9yVG91Y2hFbmRfIiwiTWF0aCIsImFicyIsIm5ld1Bvc2l0aW9uXyIsIm9wZW4iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8iLCJuZXdQb3MiLCJtaW4iLCJtYXgiLCJjc3NDbGFzc2VzIiwiQU5JTUFUSU5HIiwic3RyaW5ncyIsIkRSQVdFUl9TRUxFQ1RPUiIsIk9QRU5fRVZFTlQiLCJDTE9TRV9FVkVOVCIsIk1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uIiwiaXNEcmF3ZXIiLCJlbCIsIlRBQl9EQVRBIiwiVEFCX0RBVEFfSEFORExFRCIsInN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8iLCJzdXBwb3J0c1Bhc3NpdmVfIiwicmVtYXBFdmVudCIsImV2ZW50TmFtZSIsImdsb2JhbE9iaiIsImdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSIsImZvcmNlUmVmcmVzaCIsImNyZWF0ZUVsZW1lbnQiLCJ0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJzdHlsZSIsInN1cHBvcnRzQ3NzQ3VzdG9tUHJvcGVydGllcyIsIkNTUyIsInN1cHBvcnRzIiwiYXBwbHlQYXNzaXZlIiwiaXNTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwibW9kZWwiLCJwcm9wIiwiY2xhc3NlcyIsIndhdGNoIiwibW91bnRlZCIsIiRzZXQiLCJjbGFzc05hbWUiLCIkZGVsZXRlIiwiJGVsIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCIkcmVmcyIsImRyYXdlciIsInV0aWwiLCJvZmZzZXRXaWR0aCIsInNldFByb3BlcnR5IiwidmFsdWUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJfcmVmcmVzaCIsImJlZm9yZURlc3Ryb3kiLCJTQ1JPTExfTE9DSyIsIk9QQUNJVFlfVkFSX05BTUUiLCJNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uIiwiYWRkQm9keUNsYXNzIiwicmVtb3ZlQm9keUNsYXNzIiwidXBkYXRlQ3NzVmFyaWFibGUiLCJldmVudFRhcmdldEhhc0NsYXNzIiwiY29tcG9uZW50Q2xpY2tIYW5kbGVyXyIsImVuYWJsZVNjcm9sbF8iLCJkaXNhYmxlU2Nyb2xsXyIsIm5ld09wYWNpdHkiLCJib2R5IiwiYWRkIiwicmVtb3ZlIiwibWVkaWEiLCJfc21hbGwiLCJtYXRjaE1lZGlhIiwiX2xhcmdlIiwibWRjUGVybWFuZW50RHJhd2VyIiwibWRjUGVyc2lzdGVudERyYXdlciIsIm1kY1RlbXBvcmFyeURyYXdlciIsInBlcm1hbmVudCIsInBlcnNpc3RlbnQiLCJ0ZW1wb3JhcnkiLCJkcmF3ZXJUeXBlIiwidmFsaWRhdG9yIiwidmFsIiwidG9vbGJhclNwYWNlciIsInRvZ2dsZU9uIiwidG9nZ2xlT25Tb3VyY2UiLCJyZXF1aXJlZCIsIm9wZW5PbiIsIm9wZW5PblNvdXJjZSIsImNsb3NlT24iLCJjbG9zZU9uU291cmNlIiwicHJvdmlkZSIsIm1kY0RyYXdlciIsInNtYWxsIiwibGFyZ2UiLCJvcGVuXyIsImlzUGVybWFuZW50IiwiaXNQZXJzaXN0ZW50IiwiaXNUZW1wb3JhcnkiLCJpc1Jlc3BvbnNpdmUiLCJjcmVhdGVkIiwibWF0Y2hlcyIsInRvZ2dsZU9uRXZlbnRTb3VyY2UiLCIkb24iLCJ0b2dnbGVEcmF3ZXIiLCJvcGVuT25FdmVudFNvdXJjZSIsIm9wZW5EcmF3ZXIiLCJjbG9zZU9uRXZlbnRTb3VyY2UiLCJjbG9zZURyYXdlciIsImFkZExpc3RlbmVyIiwicmVmcmVzaE1lZGlhIiwiJG5leHRUaWNrIiwicmVtb3ZlTGlzdGVuZXIiLCIkb2ZmIiwib25PcGVuXyIsIm9uQ2hhbmdlIiwiaXNPcGVuIiwiaW5qZWN0Iiwic2hvdyIsImRlbnNlIiwiTURDUmlwcGxlQWRhcHRlciIsInZhck5hbWUiLCJVTkJPVU5ERUQiLCJCR19GT0NVU0VEIiwiRkdfQUNUSVZBVElPTiIsIkZHX0RFQUNUSVZBVElPTiIsIlZBUl9MRUZUIiwiVkFSX1RPUCIsIlZBUl9GR19TSVpFIiwiVkFSX0ZHX1NDQUxFIiwiVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCIsIlZBUl9GR19UUkFOU0xBVEVfRU5EIiwibnVtYmVycyIsIlBBRERJTkciLCJJTklUSUFMX09SSUdJTl9TQ0FMRSIsIkRFQUNUSVZBVElPTl9USU1FT1VUX01TIiwiRkdfREVBQ1RJVkFUSU9OX01TIiwiVEFQX0RFTEFZX01TIiwic3VwcG9ydHNDc3NWYXJpYWJsZXNfIiwiZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1ZyIsIndpbmRvd09iaiIsIm5vZGUiLCJhcHBlbmRDaGlsZCIsImNvbXB1dGVkU3R5bGUiLCJoYXNQc2V1ZG9WYXJCdWciLCJib3JkZXJUb3BTdHlsZSIsInN1cHBvcnRzQ3NzVmFyaWFibGVzIiwic3VwcG9ydHNGdW5jdGlvblByZXNlbnQiLCJleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzIiwid2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzIiwiZ2V0TWF0Y2hlc1Byb3BlcnR5IiwiSFRNTEVsZW1lbnRQcm90b3R5cGUiLCJmaWx0ZXIiLCJwIiwicG9wIiwiZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzIiwiZXYiLCJwYWdlT2Zmc2V0IiwiY2xpZW50UmVjdCIsIngiLCJ5IiwiZG9jdW1lbnRYIiwibGVmdCIsImRvY3VtZW50WSIsInRvcCIsIm5vcm1hbGl6ZWRYIiwibm9ybWFsaXplZFkiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VZIiwiQUNUSVZBVElPTl9FVkVOVF9UWVBFUyIsIlBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiYWN0aXZhdGVkVGFyZ2V0cyIsIk1EQ1JpcHBsZUZvdW5kYXRpb24iLCJicm93c2VyU3VwcG9ydHNDc3NWYXJzIiwiaXNVbmJvdW5kZWQiLCJpc1N1cmZhY2VBY3RpdmUiLCJpc1N1cmZhY2VEaXNhYmxlZCIsImNvbnRhaW5zRXZlbnRUYXJnZXQiLCJyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwiZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIiLCJjb21wdXRlQm91bmRpbmdSZWN0IiwiZ2V0V2luZG93UGFnZU9mZnNldCIsImxheW91dEZyYW1lXyIsImZyYW1lXyIsIndpZHRoIiwiaGVpZ2h0IiwiYWN0aXZhdGlvblN0YXRlXyIsImRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfIiwiaW5pdGlhbFNpemVfIiwibWF4UmFkaXVzXyIsImFjdGl2YXRlSGFuZGxlcl8iLCJhY3RpdmF0ZV8iLCJkZWFjdGl2YXRlSGFuZGxlcl8iLCJkZWFjdGl2YXRlXyIsImZvY3VzSGFuZGxlcl8iLCJibHVySGFuZGxlcl8iLCJyZXNpemVIYW5kbGVyXyIsImxheW91dCIsInVuYm91bmRlZENvb3Jkc18iLCJmZ1NjYWxlXyIsImFjdGl2YXRpb25UaW1lcl8iLCJmZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8iLCJhY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfIiwiYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfIiwicnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfIiwicHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfIiwiaXNBY3RpdmF0ZWQiLCJoYXNEZWFjdGl2YXRpb25VWFJ1biIsIndhc0FjdGl2YXRlZEJ5UG9pbnRlciIsIndhc0VsZW1lbnRNYWRlQWN0aXZlIiwiYWN0aXZhdGlvbkV2ZW50IiwiaXNQcm9ncmFtbWF0aWMiLCJpc1N1cHBvcnRlZF8iLCJyZWdpc3RlclJvb3RIYW5kbGVyc18iLCJsYXlvdXRJbnRlcm5hbF8iLCJjbGVhclRpbWVvdXQiLCJkZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsImRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18iLCJyZW1vdmVDc3NWYXJzXyIsImZvckVhY2giLCJrZXlzIiwiayIsImluZGV4T2YiLCJhY3RpdmF0aW9uU3RhdGUiLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudCIsImlzU2FtZUludGVyYWN0aW9uIiwiaGFzQWN0aXZhdGVkQ2hpbGQiLCJzb21lIiwicmVzZXRBY3RpdmF0aW9uU3RhdGVfIiwicHVzaCIsInJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfIiwiY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8iLCJhbmltYXRlQWN0aXZhdGlvbl8iLCJ0cmFuc2xhdGVTdGFydCIsInRyYW5zbGF0ZUVuZCIsImdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18iLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18iLCJzZXRUaW1lb3V0IiwiYWN0aXZhdGlvbkhhc0VuZGVkIiwic3RhdGUiLCJldnRPYmplY3QiLCJhbmltYXRlRGVhY3RpdmF0aW9uXyIsIm1heERpbSIsImdldEJvdW5kZWRSYWRpdXMiLCJoeXBvdGVudXNlIiwic3FydCIsInBvdyIsInVwZGF0ZUxheW91dENzc1ZhcnNfIiwicm91bmQiLCJ1bmJvdW5kZWQiLCJSaXBwbGVCYXNlIiwicmVmIiwiTUFUQ0hFUyIsIl9tYXRjaGVzIiwiSFRNTEVsZW1lbnQiLCJwcm90b3R5cGUiLCJvcHRpb25zIiwiZGlzYWJsZWQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZXMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwibWl4aW5zIiwic3RhcnRJY29uIiwidGVtcG9yYXJ5Q2xvc2UiLCJhY3RpdmF0ZWQiLCJteWxpc3RlbmVycyIsIml0ZW1DbGFzc2VzIiwiaGFzU3RhcnREZXRhaWwiLCIkc2xvdHMiLCJyaXBwbGUiLCJtZGNEcmF3ZXJMYXlvdXQiLCJtZGNEcmF3ZXJIZWFkZXIiLCJtZGNEcmF3ZXJMaXN0IiwibWRjRHJhd2VySXRlbSIsIm1kY0RyYXdlckRpdmlkZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBTyxTQUFTQSxRQUFULENBQWtCQyxNQUFsQixFQUEwQjtJQUMvQjtJQUNBLE1BQUlDLE9BQU8sSUFBWDtJQUNBLE1BQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQztJQUNqQ0QsV0FBT0MsT0FBT0MsR0FBZDtJQUNELEdBRkQsTUFFTyxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7SUFDeEM7SUFDQUgsV0FBT0csT0FBT0QsR0FBZDtJQUNEO0lBQ0QsTUFBSUYsSUFBSixFQUFVO0lBQ1JBLFNBQUtJLEdBQUwsQ0FBU0wsTUFBVDtJQUNEO0lBQ0Y7O0lDWk0sU0FBU00sVUFBVCxDQUFvQkMsVUFBcEIsRUFBZ0M7SUFDckMsU0FBTztJQUNMQyxhQUFTLFFBREo7SUFFTEMsYUFBUyxxQkFBTTtJQUNiLFdBQUssSUFBSUMsR0FBVCxJQUFnQkgsVUFBaEIsRUFBNEI7SUFDMUIsWUFBSUksWUFBWUosV0FBV0csR0FBWCxDQUFoQjtJQUNBRSxXQUFHRCxTQUFILENBQWFBLFVBQVVFLElBQXZCLEVBQTZCRixTQUE3QjtJQUNEO0lBQ0YsS0FQSTtJQVFMSjtJQVJLLEdBQVA7SUFVRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDWE0sSUFBTU8sYUFBYTtJQUN4QkQsUUFBTSxhQURrQjtJQUV4QkUsY0FBWSxJQUZZO0lBR3hCQyxTQUFPO0lBQ0xDLFNBQUssRUFBRUMsTUFBTUMsTUFBUixFQUFnQkMsU0FBUyxHQUF6QixFQURBO0lBRUxDLFVBQU1DO0lBRkQsR0FIaUI7SUFPeEJDLFFB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
