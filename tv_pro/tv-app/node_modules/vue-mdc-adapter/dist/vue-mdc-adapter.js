/**
* @module vue-mdc-adapter 0.15.4
* @exports VueMDCAdapter
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.35.2"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.VueMDCAdapter = factory());
}(this, (function () { 'use strict';

  var supportsPassive_ = void 0;

  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = { passive: true };
          }
        });
      } catch (e) {
        //empty
      }

      supportsPassive_ = isSupported;
    }

    return supportsPassive_;
  }

  function autoInit(plugin) {
    // Auto-install
    var _Vue = null;
    if (typeof window !== 'undefined') {
      _Vue = window.Vue;
    } else if (typeof global !== 'undefined') {
      /*global global*/
      _Vue = global.Vue;
    }
    if (_Vue) {
      _Vue.use(plugin);
    }
  }

  function BasePlugin(components) {
    return {
      version: '0.15.4',
      install: function install(vm) {
        for (var key in components) {
          var component = components[key];
          vm.component(component.name, component);
        }
      },
      components: components
    };
  }

  var CustomElement = {
    functional: true,
    render: function render(createElement, context) {
      return createElement(context.props.is || context.props.tag || 'div', context.data, context.children);
    }
  };

  var CustomElementMixin = {
    components: {
      CustomElement: CustomElement
    }
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var CustomLink = {
    name: 'custom-link',
    functional: true,
    props: {
      tag: { type: String, default: 'a' },
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else {
        // element fallback
        element = context.props.tag;
      }

      return h(element, data, context.children);
    }
  };

  var CustomLinkMixin = {
    props: {
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomLink: CustomLink
    }
  };

  /* global CustomEvent */

  function emitCustomEvent(el, evtType, evtData) {
    var shouldBubble = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var evt = void 0;
    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }
    el.dispatchEvent(evt);
  }

  var CustomButton = {
    name: 'custom-button',
    functional: true,
    props: {
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        data.attrs.role = 'button';
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else if (data.attrs && data.attrs.href) {
        // href case
        element = 'a';
        data.attrs.role = 'button';
      } else {
        // button fallback
        element = 'button';
      }

      return h(element, data, context.children);
    }
  };

  var CustomButtonMixin = {
    props: {
      href: String,
      disabled: Boolean,
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomButton: CustomButton
    }
  };

  function extractIconProp(iconProp) {
    if (typeof iconProp === 'string') {
      return {
        classes: { 'material-icons': true },
        content: iconProp
      };
    } else if (iconProp instanceof Array) {
      return {
        classes: iconProp.reduce(function (result, value) {
          return _extends(result, defineProperty({}, value, true));
        }, {})
      };
    } else if ((typeof iconProp === 'undefined' ? 'undefined' : _typeof(iconProp)) === 'object') {
      return {
        classes: iconProp.className.split(' ').reduce(function (result, value) {
          return _extends(result, defineProperty({}, value, true));
        }, {}),
        content: iconProp.textContent
      };
    }
  }

  var DispatchEventMixin = {
    props: {
      event: String,
      'event-target': Object,
      'event-args': Array
    },
    methods: {
      dispatchEvent: function dispatchEvent(evt) {
        evt && this.$emit(evt.type, evt);
        if (this.event) {
          var target = this.eventTarget || this.$root;
          var args = this.eventArgs || [];
          target.$emit.apply(target, [this.event].concat(toConsumableArray(args)));
        }
      }
    },
    computed: {
      listeners: function listeners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          click: function click(e) {
            return _this.dispatchEvent(e);
          }
        });
      }
    }
  };

  var DispatchFocusMixin = {
    data: function data() {
      return { hasFocus: false };
    },

    methods: {
      onMouseDown: function onMouseDown() {
        this._active = true;
      },
      onMouseUp: function onMouseUp() {
        this._active = false;
      },
      onFocusEvent: function onFocusEvent() {
        var _this = this;

        // dispatch async to let time to other focus event to propagate
        setTimeout(function () {
          return _this.dispatchFocusEvent();
        }, 0);
      },
      onBlurEvent: function onBlurEvent() {
        var _this2 = this;

        // dispatch async to let time to other focus event to propagate
        // also filtur blur if mousedown
        this._active || setTimeout(function () {
          return _this2.dispatchFocusEvent();
        }, 0);
      },
      dispatchFocusEvent: function dispatchFocusEvent() {
        var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);
        if (hasFocus != this.hasFocus) {
          this.$emit(hasFocus ? 'focus' : 'blur');
          this.hasFocus = hasFocus;
        }
      }
    },
    mounted: function mounted() {
      this.$el.addEventListener('focusin', this.onFocusEvent);
      this.$el.addEventListener('focusout', this.onBlurEvent);
      this.$el.addEventListener('mousedown', this.onMouseDown);
      this.$el.addEventListener('mouseup', this.onMouseUp);
    },
    beforeDestroy: function beforeDestroy() {
      this.$el.removeEventListener('focusin', this.onFocusEvent);
      this.$el.removeEventListener('focusout', this.onBlurEvent);
      this.$el.removeEventListener('mousedown', this.onMouseDown);
      this.$el.removeEventListener('mouseup', this.onMouseUp);
    }
  };

  var uid_ = 0;

  var VMAUniqueIdMixin = {
    beforeCreate: function beforeCreate() {
      this.vma_uid_ = "_vma_" + uid_++;
    }
  };

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation = function () {
    createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }

      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }

      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }

      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get$$1() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }

      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    createClass(MDCFoundation, [{
      key: "init",
      value: function init() {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);
    return MDCFoundation;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter = function () {
    function MDCRippleAdapter() {
      classCallCheck(this, MDCRippleAdapter);
    }

    createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}

      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}

      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}

      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);
    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };

  var strings = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };

  var numbers = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_ = void 0;

  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */
  var supportsPassive_$1 = void 0;

  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */
  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node);

    // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }

  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */

  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var supportsCssVariables = supportsCssVariables_;
    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
    // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari
    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVariables;
    }
    return supportsCssVariables;
  }

  //
  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive$1() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$1 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$1 = isSupported;
    }

    return supportsPassive_$1 ? { passive: true } : false;
  }

  /**
   * @param {!Object} HTMLElementPrototype
   * @return {!Array<string>}
   */
  function getMatchesProperty(HTMLElementPrototype) {
    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
      return p in HTMLElementPrototype;
    }).pop();
  }

  /**
   * @param {!Event} ev
   * @param {{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {{x: number, y: number}}
   */
  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;

    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;

    var normalizedX = void 0;
    var normalizedY = void 0;
    // Determine touch point relative to the ripple container.
    if (ev.type === 'touchstart') {
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return { x: normalizedX, y: normalizedY };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Activation events registered on the root element of each instance for activation
  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

  // Deactivation events registered on documentElement when a pointer-related down event occurs
  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

  // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
  /** @type {!Array<!EventTarget>} */
  var activatedTargets = [];

  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation = function (_MDCFoundation) {
    inherits(MDCRippleFoundation, _MDCFoundation);
    createClass(MDCRippleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
          isUnbounded: function isUnbounded() /* boolean */{},
          isSurfaceActive: function isSurfaceActive() /* boolean */{},
          isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
          registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
          computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
          getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      classCallCheck(this, MDCRippleFoundation);

      /** @private {number} */
      var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

      _this.layoutFrame_ = 0;

      /** @private {!ClientRect} */
      _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

      /** @private {!ActivationStateType} */
      _this.activationState_ = _this.defaultActivationState_();

      /** @private {number} */
      _this.initialSize_ = 0;

      /** @private {number} */
      _this.maxRadius_ = 0;

      /** @private {function(!Event)} */
      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };

      /** @private {function(!Event)} */
      _this.deactivateHandler_ = function (e) {
        return _this.deactivate_(e);
      };

      /** @private {function(?Event=)} */
      _this.focusHandler_ = function () {
        return requestAnimationFrame(function () {
          return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      };

      /** @private {function(?Event=)} */
      _this.blurHandler_ = function () {
        return requestAnimationFrame(function () {
          return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      };

      /** @private {!Function} */
      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      /** @private {{left: number, top:number}} */
      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };

      /** @private {number} */
      _this.fgScale_ = 0;

      /** @private {number} */
      _this.activationTimer_ = 0;

      /** @private {number} */
      _this.fgDeactivationRemovalTimer_ = 0;

      /** @private {boolean} */
      _this.activationAnimationHasEnded_ = false;

      /** @private {!Function} */
      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;
        _this.runDeactivationUXLogicIfReady_();
      };

      /** @private {?Event} */
      _this.previousActivationEvent_ = null;
      return _this;
    }

    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    createClass(MDCRippleFoundation, [{
      key: 'isSupported_',
      value: function isSupported_() {
        return this.adapter_.browserSupportsCssVars();
      }

      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: 'defaultActivationState_',
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: null,
          isProgrammatic: false
        };
      }
    }, {
      key: 'init',
      value: function init() {
        var _this2 = this;

        if (!this.isSupported_()) {
          return;
        }
        this.registerRootHandlers_();

        var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$.ROOT,
            UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

        requestAnimationFrame(function () {
          _this2.adapter_.addClass(ROOT);
          if (_this2.adapter_.isUnbounded()) {
            _this2.adapter_.addClass(UNBOUNDED);
            // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
            _this2.layoutInternal_();
          }
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        if (!this.isSupported_()) {
          return;
        }

        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

          this.adapter_.removeClass(FG_ACTIVATION);
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();

        var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$2.ROOT,
            UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(ROOT);
          _this3.adapter_.removeClass(UNBOUNDED);
          _this3.removeCssVars_();
        });
      }

      /** @private */

    }, {
      key: 'registerRootHandlers_',
      value: function registerRootHandlers_() {
        var _this4 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
        });
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }

      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: 'registerDeactivationHandlers_',
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }

      /** @private */

    }, {
      key: 'deregisterRootHandlers_',
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }

      /** @private */

    }, {
      key: 'deregisterDeactivationHandlers_',
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }

      /** @private */

    }, {
      key: 'removeCssVars_',
      value: function removeCssVars_() {
        var _this8 = this;

        var strings$$1 = MDCRippleFoundation.strings;

        Object.keys(strings$$1).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings$$1[k], null);
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'activate_',
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;
        if (activationState.isActivated) {
          return;
        }

        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === null;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

        var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });
        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e) {
          activatedTargets.push( /** @type {!EventTarget} */e.target);
          this.registerDeactivationHandlers_(e);
        }

        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }

        requestAnimationFrame(function () {
          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];

          if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
            // If space was pressed, try again within an rAF call to detect :active, because different UAs report
            // active states inconsistently when they're called within event handling code:
            // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
            // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
            // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
            // variable is set within a rAF callback for a submit button interaction (#2241).
            activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);
            if (activationState.wasElementMadeActive) {
              _this9.animateActivation_();
            }
          }

          if (!activationState.wasElementMadeActive) {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'checkElementMadeActive_',
      value: function checkElementMadeActive_(e) {
        return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'activate',
      value: function activate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.activate_(event);
      }

      /** @private */

    }, {
      key: 'animateActivation_',
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


        this.layoutInternal_();

        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
              startPoint = _getFgTranslationCoor.startPoint,
              endPoint = _getFgTranslationCoor.endPoint;

          translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
          translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        // Cancel any ongoing activation/deactivation animations
        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION);

        // Force layout in order to re-trigger the animation.
        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }

      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: 'getFgTranslationCoordinates_',
      value: function getFgTranslationCoordinates_() {
        var _activationState_ = this.activationState_,
            activationEvent = _activationState_.activationEvent,
            wasActivatedByPointer = _activationState_.wasActivatedByPointer;


        var startPoint = void 0;
        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        }
        // Center the element around the start point.
        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };

        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };

        return { startPoint: startPoint, endPoint: endPoint };
      }

      /** @private */

    }, {
      key: 'runDeactivationUXLogicIfReady_',
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _activationState_2 = this.activationState_,
            hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
            isActivated = _activationState_2.isActivated;

        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers.FG_DEACTIVATION_MS);
        }
      }

      /** @private */

    }, {
      key: 'rmBoundedActivationClasses_',
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: 'resetActivationState_',
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_();
        // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.
        setTimeout(function () {
          return _this12.previousActivationEvent_ = null;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'deactivate_',
      value: function deactivate_(e) {
        var _this13 = this;

        var activationState = this.activationState_;
        // This can happen in scenarios such as when you have a keyup event that blurs the element.
        if (!activationState.isActivated) {
          return;
        }

        var state = /** @type {!ActivationStateType} */_extends({}, activationState);

        if (activationState.isProgrammatic) {
          var evtObject = null;
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(evtObject, state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;
            _this13.animateDeactivation_(e, state);
            _this13.resetActivationState_();
          });
        }
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.deactivate_(event);
      }

      /**
       * @param {Event} e
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: 'animateDeactivation_',
      value: function animateDeactivation_(e, _ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();
          _this14.layoutFrame_ = 0;
        });
      }

      /** @private */

    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width);

        // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.
        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
        this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
        this.fgScale_ = this.maxRadius_ / this.initialSize_;

        this.updateLayoutCssVars_();
      }

      /** @private */

    }, {
      key: 'updateLayoutCssVars_',
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


        this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };

          this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
          this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
        }
      }

      /** @param {boolean} unbounded */

    }, {
      key: 'setUnbounded',
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }]);
    return MDCRippleFoundation;
  }(MDCFoundation);

  var RippleBase = function (_MDCRippleFoundation) {
    inherits(RippleBase, _MDCRippleFoundation);
    createClass(RippleBase, null, [{
      key: 'isSurfaceActive',
      value: function isSurfaceActive(ref) {
        return ref[RippleBase.MATCHES](':active');
      }
    }, {
      key: 'MATCHES',
      get: function get$$1() {
        /* global HTMLElement */
        return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
      }
    }]);

    function RippleBase(vm, options) {
      classCallCheck(this, RippleBase);
      return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return false;
        },
        isSurfaceActive: function isSurfaceActive() {
          return vm.$el[RippleBase.MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return vm.disabled;
        },
        addClass: function addClass(className) {
          vm.$set(vm.classes, className, true);
        },
        removeClass: function removeClass(className) {
          vm.$delete(vm.classes, className);
        },

        containsEventTarget: function containsEventTarget(target) {
          return vm.$el.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          vm.$el.addEventListener(evt, handler, applyPassive$1());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          vm.$el.removeEventListener(evt, handler, applyPassive$1());
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          vm.$set(vm.styles, varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return vm.$el.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        }
      }, options)));
    }

    return RippleBase;
  }(MDCRippleFoundation);

  var RippleMixin = {
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  var mdcRipple = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-ripple", attrs: { "tag": _vm.tag, "classes": _vm.classes, "styles": _vm.styles } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-ripple',
    mixins: [CustomElementMixin, RippleMixin],
    props: {
      tag: String
    }
  };

  var VueMDCRipple = BasePlugin({
    mdcRipple: mdcRipple
  });

  var mdcButtonBase = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', _vm._g({ ref: "root", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link, "disabled": _vm.disabled } }, _vm.listeners), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-button-base',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  var mdcButton = {
    name: 'mdc-button',
    extends: mdcButtonBase,
    props: {
      raised: Boolean,
      unelevated: Boolean,
      outlined: Boolean,
      dense: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-button--raised': this.raised,
          'mdc-button--unelevated': this.unelevated,
          'mdc-button--outlined': this.outlined,
          'mdc-button--dense': this.dense
        }
      };
    },

    watch: {
      raised: function raised() {
        this.$set(this.classes, 'mdc-button--raised', this.raised);
      },
      unelevated: function unelevated() {
        this.$set(this.classes, 'mdc-button--unelevated', this.unelevated);
      },
      outlined: function outlined() {
        this.$set(this.classes, 'mdc-button--outlined', this.outlined);
      },
      dense: function dense() {
        this.$set(this.classes, 'mdc-button--dense', this.dense);
      }
    }
  };

  var VueMDCButton = BasePlugin({
    mdcButton: mdcButton
  });

  var mdcCard = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card", class: { 'mdc-card--outlined': _vm.outlined } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card',
    props: {
      outlined: Boolean
    }
  };

  var mdcCardPrimaryAction = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', _vm._g({ staticClass: "mdc-card-primary-action mdc-card__primary-action", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link } }, _vm.listeners), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-primary-action',
    mixins: [DispatchEventMixin, CustomLinkMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  var mdcCardMedia = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-media mdc-card__media", class: _vm.classes, style: _vm.styles }, [_vm.$slots.default ? _c('div', { staticClass: "mdc-card__media-content" }, [_vm._t("default")], 2) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-card-media',
    props: {
      src: String,
      square: Boolean
    },
    computed: {
      styles: function styles() {
        var styles = {
          backgroundImage: 'url(' + this.src + ')'
        };

        return styles;
      },
      classes: function classes() {
        return this.square ? 'mdc-card__media--square' : 'mdc-card__media--16-9';
      }
    }
  };

  var mdcCardHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-header mdc-card__primary" }, [_vm._t("default", [_vm.title ? _c('h1', { staticClass: "mdc-card__title", class: { 'mdc-card__title--large': _vm.largeTitle } }, [_vm._v(" " + _vm._s(_vm.title) + " ")]) : _vm._e(), _vm._v(" "), _vm.subtitle ? _c('h2', { staticClass: "mdc-card__subtitle" }, [_vm._v(" " + _vm._s(_vm.subtitle) + " ")]) : _vm._e()])], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-header',
    props: {
      title: String,
      subtitle: String,
      'large-title': { type: Boolean, default: true }
    }
  };

  var mdcCardTitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h1', { staticClass: "mdc-card-title mdc-card__title", class: { 'mdc-card__title--large': _vm.large } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-title',
    props: {
      large: Boolean
    }
  };

  var mdcCardSubtitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h2', { staticClass: "mdc-card-subtitle mdc-card__subtitle" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-subtitle'
  };

  var mdcCardText = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-text mdc-card__supporting-text" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-text'
  };

  var mdcCardActions = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-actions mdc-card__actions", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-actions',
    props: {
      fullBleed: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-card__actions--full-bleed': this.fullBleed
        };
      }
    }
  };

  var mdcCardActionButtons = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-buttons mdc-card__action-buttons" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-action-buttons'
  };

  var mdcCardActionButton = {
    name: 'mdc-card-action-button',
    extends: mdcButtonBase,
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-card__action': true,
          'mdc-card-action-button': true
        }
      };
    }
  };

  var mdcCardActionIcons = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-icons mdc-card__action-icons" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-action-icons'
  };

  var mdcCardActionIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', _vm._g({ class: _vm.classes, style: _vm.styles }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-action-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    },
    data: function data() {
      return {
        classes: {
          'mdc-card-action-icon': true,
          'material-icons': !!this.icon,
          'mdc-card__action': true,
          'mdc-card__action--icon': true,
          'mdc-icon-toggle': true
        },
        styles: {}
      };
    },

    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', !!this.icon);
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  var VueMDCCard = BasePlugin({
    mdcCard: mdcCard,
    mdcCardPrimaryAction: mdcCardPrimaryAction,
    mdcCardMedia: mdcCardMedia,
    mdcCardHeader: mdcCardHeader,
    mdcCardTitle: mdcCardTitle,
    mdcCardSubtitle: mdcCardSubtitle,
    mdcCardText: mdcCardText,
    mdcCardActions: mdcCardActions,
    mdcCardActionButtons: mdcCardActionButtons,
    mdcCardActionButton: mdcCardActionButton,
    mdcCardActionIcons: mdcCardActionIcons,
    mdcCardActionIcon: mdcCardActionIcon
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template F
   */

  var MDCComponent = function () {
    createClass(MDCComponent, null, [{
      key: 'attachTo',

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }

      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args);
      // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.
      /** @protected {!F} */
      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    createClass(MDCComponent, [{
      key: 'initialize',
      value: function initialize() /* ...args */{}
      // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.


      /**
       * @return {!F} foundation
       */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        // Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }

      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'listen',
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }

      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'unlisten',
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }

      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: 'emit',
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var evt = void 0;
        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);
    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends MDCComponent<!MDCRippleFoundation>
   */

  var MDCRipple = function (_MDCComponent) {
    inherits(MDCRipple, _MDCComponent);

    /** @param {...?} args */
    function MDCRipple() {
      var _ref;

      classCallCheck(this, MDCRipple);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      /** @type {boolean} */
      var _this = possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));

      _this.disabled = false;

      /** @private {boolean} */
      _this.unbounded_;
      return _this;
    }

    /**
     * @param {!Element} root
     * @param {{isUnbounded: (boolean|undefined)}=} options
     * @return {!MDCRipple}
     */


    createClass(MDCRipple, [{
      key: 'setUnbounded_',


      /**
       * Closure Compiler throws an access control error when directly accessing a
       * protected or private property inside a getter/setter, like unbounded above.
       * By accessing the protected property inside a method, we solve that problem.
       * That's why this function exists.
       * @private
       */
      value: function setUnbounded_() {
        this.foundation_.setUnbounded(this.unbounded_);
      }
    }, {
      key: 'activate',
      value: function activate() {
        this.foundation_.activate();
      }
    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.foundation_.deactivate();
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.foundation_.layout();
      }

      /** @return {!MDCRippleFoundation} */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        return new MDCRippleFoundation(MDCRipple.createAdapter(this));
      }
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
      }
    }, {
      key: 'unbounded',


      /** @return {boolean} */
      get: function get$$1() {
        return this.unbounded_;
      }

      /** @param {boolean} unbounded */
      ,
      set: function set$$1(unbounded) {
        this.unbounded_ = Boolean(unbounded);
        this.setUnbounded_();
      }
    }], [{
      key: 'attachTo',
      value: function attachTo(root) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref2$isUnbounded = _ref2.isUnbounded,
            isUnbounded = _ref2$isUnbounded === undefined ? undefined : _ref2$isUnbounded;

        var ripple = new MDCRipple(root);
        // Only override unbounded behavior if option is explicitly specified
        if (isUnbounded !== undefined) {
          ripple.unbounded = /** @type {boolean} */isUnbounded;
        }
        return ripple;
      }

      /**
       * @param {!RippleCapableSurface} instance
       * @return {!MDCRippleAdapter}
       */

    }, {
      key: 'createAdapter',
      value: function createAdapter(instance) {
        var MATCHES = getMatchesProperty(HTMLElement.prototype);

        return {
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return instance.unbounded;
          },
          isSurfaceActive: function isSurfaceActive() {
            return instance.root_[MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return instance.disabled;
          },
          addClass: function addClass(className) {
            return instance.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return instance.root_.classList.remove(className);
          },
          containsEventTarget: function containsEventTarget(target) {
            return instance.root_.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return instance.root_.addEventListener(evtType, handler, applyPassive$1());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return instance.root_.removeEventListener(evtType, handler, applyPassive$1());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            return instance.root_.style.setProperty(varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return instance.root_.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return { x: window.pageXOffset, y: window.pageYOffset };
          }
        };
      }
    }]);
    return MDCRipple;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @record
   */

  var MDCSelectionControl = function () {
    function MDCSelectionControl() {
      classCallCheck(this, MDCSelectionControl);
    }

    createClass(MDCSelectionControl, [{
      key: 'ripple',

      /** @return {?MDCRipple} */
      get: function get$$1() {}
    }]);
    return MDCSelectionControl;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Checkbox. Provides an interface for managing
   * - classes
   * - dom
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCCheckboxAdapter = function () {
    function MDCCheckboxAdapter() {
      classCallCheck(this, MDCCheckboxAdapter);
    }

    createClass(MDCCheckboxAdapter, [{
      key: 'addClass',

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /**
       * Sets an attribute with a given value on the input element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: 'setNativeControlAttr',
      value: function setNativeControlAttr(attr, value) {}

      /**
       * Removes an attribute from the input element.
       * @param {string} attr
       */

    }, {
      key: 'removeNativeControlAttr',
      value: function removeNativeControlAttr(attr) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'registerAnimationEndHandler',
      value: function registerAnimationEndHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'deregisterAnimationEndHandler',
      value: function deregisterAnimationEndHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'registerChangeHandler',
      value: function registerChangeHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'deregisterChangeHandler',
      value: function deregisterChangeHandler(handler) {}

      /** @return {!MDCSelectionControlState} */

    }, {
      key: 'getNativeControl',
      value: function getNativeControl() {}
    }, {
      key: 'forceLayout',
      value: function forceLayout() {}

      /** @return {boolean} */

    }, {
      key: 'isAttachedToDOM',
      value: function isAttachedToDOM() {}
    }]);
    return MDCCheckboxAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {string} */
  var ROOT = 'mdc-checkbox';

  /** @enum {string} */
  var cssClasses$1 = {
    UPGRADED: 'mdc-checkbox--upgraded',
    CHECKED: 'mdc-checkbox--checked',
    INDETERMINATE: 'mdc-checkbox--indeterminate',
    DISABLED: 'mdc-checkbox--disabled',
    ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
    ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
    ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
    ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
    ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
    ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
  };

  /** @enum {string} */
  var strings$1 = {
    NATIVE_CONTROL_SELECTOR: '.' + ROOT + '__native-control',
    TRANSITION_STATE_INIT: 'init',
    TRANSITION_STATE_CHECKED: 'checked',
    TRANSITION_STATE_UNCHECKED: 'unchecked',
    TRANSITION_STATE_INDETERMINATE: 'indeterminate',
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed'
  };

  /** @enum {number} */
  var numbers$1 = {
    ANIM_END_LATCH_MS: 250
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {!Array<string>} */
  var CB_PROTO_PROPS = ['checked', 'indeterminate'];

  /**
   * @extends {MDCFoundation<!MDCCheckboxAdapter>}
   */

  var MDCCheckboxFoundation = function (_MDCFoundation) {
    inherits(MDCCheckboxFoundation, _MDCFoundation);
    createClass(MDCCheckboxFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$1;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$1;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$1;
      }

      /** @return {!MDCCheckboxAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCCheckboxAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            setNativeControlAttr: function setNativeControlAttr() /* attr: string, value: string */{},
            removeNativeControlAttr: function removeNativeControlAttr() /* attr: string */{},
            registerAnimationEndHandler: function registerAnimationEndHandler() /* handler: EventListener */{},
            deregisterAnimationEndHandler: function deregisterAnimationEndHandler() /* handler: EventListener */{},
            registerChangeHandler: function registerChangeHandler() /* handler: EventListener */{},
            deregisterChangeHandler: function deregisterChangeHandler() /* handler: EventListener */{},
            getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{},
            forceLayout: function forceLayout() {},
            isAttachedToDOM: function isAttachedToDOM() /* boolean */{}
          }
        );
      }
    }]);

    function MDCCheckboxFoundation(adapter) {
      classCallCheck(this, MDCCheckboxFoundation);

      /** @private {string} */
      var _this = possibleConstructorReturn(this, (MDCCheckboxFoundation.__proto__ || Object.getPrototypeOf(MDCCheckboxFoundation)).call(this, _extends(MDCCheckboxFoundation.defaultAdapter, adapter)));

      _this.currentCheckState_ = strings$1.TRANSITION_STATE_INIT;

      /** @private {string} */
      _this.currentAnimationClass_ = '';

      /** @private {number} */
      _this.animEndLatchTimer_ = 0;

      _this.animEndHandler_ = /** @private {!EventListener} */function () {
        return _this.handleAnimationEnd();
      };

      _this.changeHandler_ = /** @private {!EventListener} */function () {
        return _this.handleChange();
      };
      return _this;
    }

    createClass(MDCCheckboxFoundation, [{
      key: 'init',
      value: function init() {
        this.currentCheckState_ = this.determineCheckState_(this.getNativeControl_());
        this.updateAriaChecked_();
        this.adapter_.addClass(cssClasses$1.UPGRADED);
        this.adapter_.registerChangeHandler(this.changeHandler_);
        this.installPropertyChangeHooks_();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterChangeHandler(this.changeHandler_);
        this.uninstallPropertyChangeHooks_();
      }

      /** @return {boolean} */

    }, {
      key: 'isChecked',
      value: function isChecked() {
        return this.getNativeControl_().checked;
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.getNativeControl_().checked = checked;
      }

      /** @return {boolean} */

    }, {
      key: 'isIndeterminate',
      value: function isIndeterminate() {
        return this.getNativeControl_().indeterminate;
      }

      /** @param {boolean} indeterminate */

    }, {
      key: 'setIndeterminate',
      value: function setIndeterminate(indeterminate) {
        this.getNativeControl_().indeterminate = indeterminate;
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeControl_().disabled;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.getNativeControl_().disabled = disabled;
        if (disabled) {
          this.adapter_.addClass(cssClasses$1.DISABLED);
        } else {
          this.adapter_.removeClass(cssClasses$1.DISABLED);
        }
      }

      /** @return {?string} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeControl_().value;
      }

      /** @param {?string} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeControl_().value = value;
      }

      /**
       * Handles the animationend event for the checkbox
       */

    }, {
      key: 'handleAnimationEnd',
      value: function handleAnimationEnd() {
        var _this2 = this;

        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function () {
          _this2.adapter_.removeClass(_this2.currentAnimationClass_);
          _this2.adapter_.deregisterAnimationEndHandler(_this2.animEndHandler_);
        }, numbers$1.ANIM_END_LATCH_MS);
      }

      /**
       * Handles the change event for the checkbox
       */

    }, {
      key: 'handleChange',
      value: function handleChange() {
        this.transitionCheckState_();
      }

      /** @private */

    }, {
      key: 'installPropertyChangeHooks_',
      value: function installPropertyChangeHooks_() {
        var _this3 = this;

        var nativeCb = this.getNativeControl_();
        var cbProto = Object.getPrototypeOf(nativeCb);

        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
          // We have to check for this descriptor, since some browsers (Safari) don't support its return.
          // See: https://bugs.webkit.org/show_bug.cgi?id=49739
          if (validDescriptor(desc)) {
            var nativeCbDesc = /** @type {!ObjectPropertyDescriptor} */{
              get: desc.get,
              set: function set$$1(state) {
                desc.set.call(nativeCb, state);
                _this3.transitionCheckState_();
              },
              configurable: desc.configurable,
              enumerable: desc.enumerable
            };
            Object.defineProperty(nativeCb, controlState, nativeCbDesc);
          }
        });
      }

      /** @private */

    }, {
      key: 'uninstallPropertyChangeHooks_',
      value: function uninstallPropertyChangeHooks_() {
        var nativeCb = this.getNativeControl_();
        var cbProto = Object.getPrototypeOf(nativeCb);

        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = /** @type {!ObjectPropertyDescriptor} */Object.getOwnPropertyDescriptor(cbProto, controlState);
          if (validDescriptor(desc)) {
            Object.defineProperty(nativeCb, controlState, desc);
          }
        });
      }

      /** @private */

    }, {
      key: 'transitionCheckState_',
      value: function transitionCheckState_() {
        var nativeCb = this.adapter_.getNativeControl();
        if (!nativeCb) {
          return;
        }
        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_(nativeCb);
        if (oldState === newState) {
          return;
        }

        this.updateAriaChecked_();

        // Check to ensure that there isn't a previously existing animation class, in case for example
        // the user interacted with the checkbox before the animation was finished.
        if (this.currentAnimationClass_.length > 0) {
          clearTimeout(this.animEndLatchTimer_);
          this.adapter_.forceLayout();
          this.adapter_.removeClass(this.currentAnimationClass_);
        }

        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState;

        // Check for parentNode so that animations are only run when the element is attached
        // to the DOM.
        if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
          this.adapter_.addClass(this.currentAnimationClass_);
          this.adapter_.registerAnimationEndHandler(this.animEndHandler_);
        }
      }

      /**
       * @param {!MDCSelectionControlState} nativeCb
       * @return {string}
       * @private
       */

    }, {
      key: 'determineCheckState_',
      value: function determineCheckState_(nativeCb) {
        var TRANSITION_STATE_INDETERMINATE = strings$1.TRANSITION_STATE_INDETERMINATE,
            TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;


        if (nativeCb.indeterminate) {
          return TRANSITION_STATE_INDETERMINATE;
        }
        return nativeCb.checked ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
      }

      /**
       * @param {string} oldState
       * @param {string} newState
       * @return {string}
       */

    }, {
      key: 'getTransitionAnimationClass_',
      value: function getTransitionAnimationClass_(oldState, newState) {
        var TRANSITION_STATE_INIT = strings$1.TRANSITION_STATE_INIT,
            TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;
        var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
            ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
            ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
            ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
            ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
            ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
            ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;


        switch (oldState) {
          case TRANSITION_STATE_INIT:
            if (newState === TRANSITION_STATE_UNCHECKED) {
              return '';
            }
          // fallthrough
          case TRANSITION_STATE_UNCHECKED:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
          case TRANSITION_STATE_CHECKED:
            return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
          // TRANSITION_STATE_INDETERMINATE
          default:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
      }
    }, {
      key: 'updateAriaChecked_',
      value: function updateAriaChecked_() {
        // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
        if (this.isIndeterminate()) {
          this.adapter_.setNativeControlAttr(strings$1.ARIA_CHECKED_ATTR, strings$1.ARIA_CHECKED_INDETERMINATE_VALUE);
        } else {
          this.adapter_.removeNativeControlAttr(strings$1.ARIA_CHECKED_ATTR);
        }
      }

      /**
       * @return {!MDCSelectionControlState}
       * @private
       */

    }, {
      key: 'getNativeControl_',
      value: function getNativeControl_() {
        return this.adapter_.getNativeControl() || {
          checked: false,
          indeterminate: false,
          disabled: false,
          value: null
        };
      }
    }]);
    return MDCCheckboxFoundation;
  }(MDCFoundation);

  /**
   * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
   * @return {boolean}
   */


  function validDescriptor(inputPropDesc) {
    return !!inputPropDesc && typeof inputPropDesc.set === 'function';
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Form Field. Provides an interface for managing
   * - event handlers
   * - ripple activation
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCFormFieldAdapter = function () {
    function MDCFormFieldAdapter() {
      classCallCheck(this, MDCFormFieldAdapter);
    }

    createClass(MDCFormFieldAdapter, [{
      key: "registerInteractionHandler",

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}
    }, {
      key: "activateInputRipple",
      value: function activateInputRipple() {}
    }, {
      key: "deactivateInputRipple",
      value: function deactivateInputRipple() {}
    }]);
    return MDCFormFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$2 = {
    ROOT: 'mdc-form-field'
  };

  /** @enum {string} */
  var strings$2 = {
    LABEL_SELECTOR: '.mdc-form-field > label'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCFormFieldAdapter>}
   */

  var MDCFormFieldFoundation = function (_MDCFoundation) {
    inherits(MDCFormFieldFoundation, _MDCFoundation);
    createClass(MDCFormFieldFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$2;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$2;
      }

      /** @return {!MDCFormFieldAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          activateInputRipple: function activateInputRipple() {},
          deactivateInputRipple: function deactivateInputRipple() {}
        };
      }
    }]);

    function MDCFormFieldFoundation(adapter) {
      classCallCheck(this, MDCFormFieldFoundation);

      /** @private {!EventListener} */
      var _this = possibleConstructorReturn(this, (MDCFormFieldFoundation.__proto__ || Object.getPrototypeOf(MDCFormFieldFoundation)).call(this, _extends(MDCFormFieldFoundation.defaultAdapter, adapter)));

      _this.clickHandler_ = /** @type {!EventListener} */function () {
        return _this.handleClick_();
      };
      return _this;
    }

    createClass(MDCFormFieldFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      }

      /** @private */

    }, {
      key: 'handleClick_',
      value: function handleClick_() {
        var _this2 = this;

        this.adapter_.activateInputRipple();
        requestAnimationFrame(function () {
          return _this2.adapter_.deactivateInputRipple();
        });
      }
    }]);
    return MDCFormFieldFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {Object<string, !VendorPropertyMapType>} */
  var eventTypeMap = {
    'animationstart': {
      noPrefix: 'animationstart',
      webkitPrefix: 'webkitAnimationStart',
      styleProperty: 'animation'
    },
    'animationend': {
      noPrefix: 'animationend',
      webkitPrefix: 'webkitAnimationEnd',
      styleProperty: 'animation'
    },
    'animationiteration': {
      noPrefix: 'animationiteration',
      webkitPrefix: 'webkitAnimationIteration',
      styleProperty: 'animation'
    },
    'transitionend': {
      noPrefix: 'transitionend',
      webkitPrefix: 'webkitTransitionEnd',
      styleProperty: 'transition'
    }
  };

  /** @const {Object<string, !VendorPropertyMapType>} */
  var cssPropertyMap = {
    'animation': {
      noPrefix: 'animation',
      webkitPrefix: '-webkit-animation'
    },
    'transform': {
      noPrefix: 'transform',
      webkitPrefix: '-webkit-transform'
    },
    'transition': {
      noPrefix: 'transition',
      webkitPrefix: '-webkit-transition'
    }
  };

  /**
   * @param {!Object} windowObj
   * @return {boolean}
   */
  function hasProperShape(windowObj) {
    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
  }

  /**
   * @param {string} eventType
   * @return {boolean}
   */
  function eventFoundInMaps(eventType) {
    return eventType in eventTypeMap || eventType in cssPropertyMap;
  }

  /**
   * @param {string} eventType
   * @param {!Object<string, !VendorPropertyMapType>} map
   * @param {!Element} el
   * @return {string}
   */
  function getJavaScriptEventName(eventType, map, el) {
    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  /**
   * Helper function to determine browser prefix for CSS3 animation events
   * and property names.
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getAnimationName(windowObj, eventType) {
    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
      return eventType;
    }

    var map = /** @type {!Object<string, !VendorPropertyMapType>} */eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
    var el = windowObj['document']['createElement']('div');
    var eventName = '';

    if (map === eventTypeMap) {
      eventName = getJavaScriptEventName(eventType, map, el);
    } else {
      eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }

    return eventName;
  }

  // Public functions to access getAnimationName() for JavaScript events or CSS
  // property names.

  var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectEventName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectPropertyName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  var mdcCheckbox = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-checkbox-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-checkbox", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-checkbox__native-control", attrs: { "id": _vm.vma_uid_, "name": _vm.name, "type": "checkbox" }, domProps: { "value": _vm.value }, on: { "change": _vm.onChange } }), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__background" }, [_c('svg', { staticClass: "mdc-checkbox__checkmark", attrs: { "viewBox": "0 0 24 24" } }, [_c('path', { staticClass: "mdc-checkbox__checkmark-path", attrs: { "fill": "none", "stroke": "white", "d": "M1.73,12.91 8.1,19.28 22.79,4.59" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__mixedmark" })])]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-checkbox',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: [Boolean, Array],
      indeterminate: Boolean,
      disabled: Boolean,
      label: String,
      'align-end': Boolean,
      value: {
        type: [String, Number],
        default: function _default() {
          return 'on';
        }
      },
      name: String
    },
    data: function data() {
      return {
        styles: {},
        classes: {}
      };
    },

    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      },
      formFieldClasses: function formFieldClasses() {
        return {
          'mdc-form-field': this.hasLabel,
          'mdc-form-field--align-end': this.hasLabel && this.alignEnd
        };
      }
    },
    watch: {
      checked: 'setChecked',
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      },
      indeterminate: function indeterminate(value) {
        this.foundation.setIndeterminate(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCCheckboxFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setNativeControlAttr: function setNativeControlAttr(attr, value) {
          _this.$refs.control.setAttribute(attr, value);
        },
        removeNativeControlAttr: function removeNativeControlAttr(attr) {
          _this.$refs.control.removeAttribute(attr);
        },
        registerAnimationEndHandler: function registerAnimationEndHandler(handler) {
          return _this.$refs.root.addEventListener(getCorrectEventName(window, 'animationend'), handler);
        },
        deregisterAnimationEndHandler: function deregisterAnimationEndHandler(handler) {
          return _this.$refs.root.removeEventListener(getCorrectEventName(window, 'animationend'), handler);
        },
        registerChangeHandler: function registerChangeHandler(handler) {
          return _this.$refs.control.addEventListener('change', handler);
        },
        deregisterChangeHandler: function deregisterChangeHandler(handler) {
          return _this.$refs.control.removeEventListener('change', handler);
        },
        getNativeControl: function getNativeControl() {
          return _this.$refs.control;
        },
        forceLayout: function forceLayout() {
          return _this.$refs.root.offsetWidth;
        },
        isAttachedToDOM: function isAttachedToDOM() {
          return Boolean(_this.$el.parentNode);
        }
      });

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return RippleBase.isSurfaceActive(_this.$refs.control);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler, applyPassive());
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });

      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });

      this.foundation.init();
      this.ripple.init();
      this.formField.init();
      this.setChecked(this.checked);
      this.foundation.setDisabled(this.disabled);
      this.foundation.setIndeterminate(this.indeterminate);
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      setChecked: function setChecked(checked) {
        this.foundation.setChecked(Array.isArray(checked) ? checked.indexOf(this.value) > -1 : checked);
      },
      onChange: function onChange() {
        this.$emit('update:indeterminate', this.foundation.isIndeterminate());
        var isChecked = this.foundation.isChecked();

        if (Array.isArray(this.checked)) {
          var idx = this.checked.indexOf(this.value);
          if (isChecked) {
            idx < 0 && this.$emit('change', this.checked.concat(this.value));
          } else {
            idx > -1 && this.$emit('change', this.checked.slice(0, idx).concat(this.checked.slice(idx + 1)));
          }
        } else {
          this.$emit('change', isChecked);
        }
      }
    }
  };

  var VueMDCCheckbox = BasePlugin({
    mdcCheckbox: mdcCheckbox
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCChipAdapter = function () {
    function MDCChipAdapter() {
      classCallCheck(this, MDCChipAdapter);
    }

    createClass(MDCChipAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Adds a class to the leading icon element.
       * @param {string} className
       */

    }, {
      key: "addClassToLeadingIcon",
      value: function addClassToLeadingIcon(className) {}

      /**
       * Removes a class from the leading icon element.
       * @param {string} className
       */

    }, {
      key: "removeClassFromLeadingIcon",
      value: function removeClassFromLeadingIcon(className) {}

      /**
       * Returns true if target has className, false otherwise.
       * @param {!EventTarget} target
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "eventTargetHasClass",
      value: function eventTargetHasClass(target, className) {}

      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}

      /**
       * Registers an event listener on the trailing icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerTrailingIconInteractionHandler",
      value: function registerTrailingIconInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the trailing icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterTrailingIconInteractionHandler",
      value: function deregisterTrailingIconInteractionHandler(evtType, handler) {}

      /**
       * Emits a custom "MDCChip:interaction" event denoting the chip has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyInteraction",
      value: function notifyInteraction() {}

      /**
       * Emits a custom "MDCChip:trailingIconInteraction" event denoting the trailing icon has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyTrailingIconInteraction",
      value: function notifyTrailingIconInteraction() {}

      /**
       * Emits a custom event "MDCChip:removal" denoting the chip will be removed.
       */

    }, {
      key: "notifyRemoval",
      value: function notifyRemoval() {}

      /**
       * Returns the computed property value of the given style property on the root element.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getComputedStyleValue",
      value: function getComputedStyleValue(propertyName) {}

      /**
       * Sets the property value of the given style property on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyleProperty",
      value: function setStyleProperty(propertyName, value) {}
    }]);
    return MDCChipAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$3 = {
    ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
    INTERACTION_EVENT: 'MDCChip:interaction',
    TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
    REMOVAL_EVENT: 'MDCChip:removal',
    CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
    LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
    TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
  };

  /** @enum {string} */
  var cssClasses$3 = {
    CHECKMARK: 'mdc-chip__checkmark',
    CHIP: 'mdc-chip',
    CHIP_EXIT: 'mdc-chip--exit',
    HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
    LEADING_ICON: 'mdc-chip__icon--leading',
    TRAILING_ICON: 'mdc-chip__icon--trailing',
    SELECTED: 'mdc-chip--selected',
    TEXT: 'mdc-chip__text'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCChipAdapter>}
   * @final
   */

  var MDCChipFoundation = function (_MDCFoundation) {
    inherits(MDCChipFoundation, _MDCFoundation);
    createClass(MDCChipFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$3;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$3;
      }

      /**
       * {@see MDCChipAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCChipAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            addClassToLeadingIcon: function addClassToLeadingIcon() {},
            removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {},
            eventTargetHasClass: function eventTargetHasClass() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {},
            registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler() {},
            deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler() {},
            notifyInteraction: function notifyInteraction() {},
            notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {},
            notifyRemoval: function notifyRemoval() {},
            getComputedStyleValue: function getComputedStyleValue() {},
            setStyleProperty: function setStyleProperty() {}
          }
        );
      }

      /**
       * @param {!MDCChipAdapter} adapter
       */

    }]);

    function MDCChipFoundation(adapter) {
      classCallCheck(this, MDCChipFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCChipFoundation.__proto__ || Object.getPrototypeOf(MDCChipFoundation)).call(this, _extends(MDCChipFoundation.defaultAdapter, adapter)));

      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction_(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.trailingIconInteractionHandler_ = function (evt) {
        return _this.handleTrailingIconInteraction_(evt);
      };
      return _this;
    }

    createClass(MDCChipFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerEventHandler(evtType, _this2.interactionHandler_);
        });
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach(function (evtType) {
          _this2.adapter_.registerTrailingIconInteractionHandler(evtType, _this2.trailingIconInteractionHandler_);
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterEventHandler(evtType, _this3.interactionHandler_);
        });
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach(function (evtType) {
          _this3.adapter_.deregisterTrailingIconInteractionHandler(evtType, _this3.trailingIconInteractionHandler_);
        });
      }

      /**
       * @return {boolean}
       */

    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.adapter_.hasClass(cssClasses$3.SELECTED);
      }

      /**
       * @param {boolean} selected
       */

    }, {
      key: 'setSelected',
      value: function setSelected(selected) {
        if (selected) {
          this.adapter_.addClass(cssClasses$3.SELECTED);
        } else {
          this.adapter_.removeClass(cssClasses$3.SELECTED);
        }
      }

      /**
       * Handles an interaction event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: 'handleInteraction_',
      value: function handleInteraction_(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyInteraction();
        }
      }

      /**
       * Handles a transition end event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        var _this4 = this;

        // Handle transition end event on the chip when it is about to be removed.
        if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$3.CHIP_EXIT)) {
          if (evt.propertyName === 'width') {
            this.adapter_.notifyRemoval();
          } else if (evt.propertyName === 'opacity') {
            // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
            var chipWidth = this.adapter_.getComputedStyleValue('width');

            // On the next frame (once we get the computed width), explicitly set the chip's width
            // to its current pixel width, so we aren't transitioning out of 'auto'.
            requestAnimationFrame(function () {
              _this4.adapter_.setStyleProperty('width', chipWidth);

              // To mitigate jitter, start transitioning padding and margin before width.
              _this4.adapter_.setStyleProperty('padding', '0');
              _this4.adapter_.setStyleProperty('margin', '0');

              // On the next frame (once width is explicitly set), transition width to 0.
              requestAnimationFrame(function () {
                _this4.adapter_.setStyleProperty('width', '0');
              });
            });
          }
          return;
        }

        // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.
        if (evt.propertyName !== 'opacity') {
          return;
        }
        if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$3.LEADING_ICON) && this.adapter_.hasClass(cssClasses$3.SELECTED)) {
          this.adapter_.addClassToLeadingIcon(cssClasses$3.HIDDEN_LEADING_ICON);
        } else if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$3.CHECKMARK) && !this.adapter_.hasClass(cssClasses$3.SELECTED)) {
          this.adapter_.removeClassFromLeadingIcon(cssClasses$3.HIDDEN_LEADING_ICON);
        }
      }

      /**
       * Handles an interaction event on the trailing icon element. This is used to
       * prevent the ripple from activating on interaction with the trailing icon.
       * @param {!Event} evt
       */

    }, {
      key: 'handleTrailingIconInteraction_',
      value: function handleTrailingIconInteraction_(evt) {
        evt.stopPropagation();
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyTrailingIconInteraction();
          this.adapter_.addClass(cssClasses$3.CHIP_EXIT);
        }
      }
    }]);
    return MDCChipFoundation;
  }(MDCFoundation);

  var mdcChip = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', _vm._g({ class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "0" } }, _vm.$listeners), [_vm.haveleadingIcon ? _c('i', { ref: "leadingIcon", staticClass: "mdc-chip__icon mdc-chip__icon--leading", class: _vm.leadingClasses }, [_vm._v(_vm._s(_vm.leadingIcon))]) : _vm._e(), _vm._v(" "), _vm.isFilter ? _c('div', { staticClass: "mdc-chip__checkmark" }, [_c('svg', { staticClass: "mdc-chip__checkmark-svg", attrs: { "viewBox": "-2 -3 30 30" } }, [_c('path', { staticClass: "mdc-chip__checkmark-path", attrs: { "fill": "none", "stroke": "black", "d": "M1.73,12.91 8.1,19.28 22.79,4.59" } })])]) : _vm._e(), _vm._v(" "), _c('div', { staticClass: "mdc-chip__text" }, [_vm._t("default")], 2), _vm._v(" "), _vm.havetrailingIcon ? _c('i', { ref: "trailingIcon", staticClass: "mdc-chip__icon mdc-chip__icon--trailing", class: _vm.trailingClasses, attrs: { "tabindex": "0", "role": "button" } }, [_vm._v(_vm._s(_vm.trailingIcon))]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-chip',
    mixins: [CustomLinkMixin],
    props: {
      leadingIcon: [String],
      trailingIcon: [String],
      leadingIconClasses: [Object],
      trailingIconClasses: [Object]
    },
    inject: ['mdcChipSet'],
    data: function data() {
      return {
        classes: {
          'mdc-chip': true
        },
        styles: {}
      };
    },

    computed: {
      isFilter: function isFilter() {
        return this.mdcChipSet && this.mdcChipSet.filter;
      },
      haveleadingIcon: function haveleadingIcon() {
        return !!this.leadingIcon || this.leadingIconClasses;
      },
      havetrailingIcon: function havetrailingIcon() {
        return !!this.trailingIcon || this.trailingIconClasses;
      },
      leadingClasses: function leadingClasses() {
        return _extends({}, {
          'material-icons': !!this.leadingIcon
        }, this.leadingIconClasses);
      },
      trailingClasses: function trailingClasses() {
        return _extends({}, {
          'material-icons': !!this.trailingIcon
        }, this.trailingIconClasses);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClassToLeadingIcon: function addClassToLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.add(className);
          }
        },
        removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.remove(className);
          }
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          return _this.$el.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          return _this.$el.removeEventListener(evtType, handler);
        },
        notifyInteraction: function notifyInteraction() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.INTERACTION_EVENT, {
            chip: _this
          }, true);
        },
        notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
          _this.$emit('trailingIconClick');
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.TRAILING_ICON_INTERACTION_EVENT, {
            chip: _this
          }, true);
        },

        registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler(evtType, handler) {
          if (_this.$refs.trailingIcon) {
            _this.$refs.trailingIcon.addEventListener(evtType, handler, applyPassive());
          }
        },
        deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler(evtType, handler) {
          if (_this.$refs.trailingIcon) {
            _this.$refs.trailingIcon.removeEventListener(evtType, handler, applyPassive());
          }
        },
        notifyRemoval: function notifyRemoval() {
          return _this.emit(MDCChipFoundation.strings.REMOVAL_EVENT, { chip: _this }, true);
        },
        getComputedStyleValue: function getComputedStyleValue(propertyName) {
          return window.getComputedStyle(_this.$el).getPropertyValue(propertyName);
        },
        setStyleProperty: function setStyleProperty(property, value) {
          return _this.$set(_this.styles, property, value);
        }
      });

      this.foundation.init();

      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      toggleSelected: function toggleSelected() {
        this.foundation.toggleSelected();
      },
      isSelected: function isSelected() {
        return this.foundation.isSelected();
      }
    }
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip Set.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip Set into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCChipSetAdapter = function () {
    function MDCChipSetAdapter() {
      classCallCheck(this, MDCChipSetAdapter);
    }

    createClass(MDCChipSetAdapter, [{
      key: "hasClass",

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * Appends and returns a new chip element with the given text, leading icon, and trailing icon.
       * @param {string} text
       * @param {?Element} leadingIcon
       * @param {?Element} trailingIcon
       * @return {!Element}
       */

    }, {
      key: "appendChip",
      value: function appendChip(text, leadingIcon, trailingIcon) {}

      /**
       * Removes the chip object from the chip set.
       * @param {!Object} chip
       */

    }, {
      key: "removeChip",
      value: function removeChip(chip) {}
    }]);
    return MDCChipSetAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$4 = {
    CHIP_SELECTOR: '.mdc-chip'
  };

  /** @enum {string} */
  var cssClasses$4 = {
    CHOICE: 'mdc-chip-set--choice',
    FILTER: 'mdc-chip-set--filter'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCChipSetAdapter>}
   * @final
   */

  var MDCChipSetFoundation = function (_MDCFoundation) {
    inherits(MDCChipSetFoundation, _MDCFoundation);
    createClass(MDCChipSetFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$4;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$4;
      }

      /**
       * {@see MDCChipSetAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipSetAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCChipSetAdapter} */{
            hasClass: function hasClass() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            appendChip: function appendChip() {},
            removeChip: function removeChip() {}
          }
        );
      }

      /**
       * @param {!MDCChipSetAdapter} adapter
       */

    }]);

    function MDCChipSetFoundation(adapter) {
      classCallCheck(this, MDCChipSetFoundation);

      /**
       * The selected chips in the set. Only used for choice chip set or filter chip set.
       * @private {!Array<!MDCChipFoundation>}
       */
      var _this = possibleConstructorReturn(this, (MDCChipSetFoundation.__proto__ || Object.getPrototypeOf(MDCChipSetFoundation)).call(this, _extends(MDCChipSetFoundation.defaultAdapter, adapter)));

      _this.selectedChips_ = [];

      /** @private {function(!Event): undefined} */
      _this.chipInteractionHandler_ = function (evt) {
        return _this.handleChipInteraction_(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.chipRemovalHandler_ = function (evt) {
        return _this.handleChipRemoval_(evt);
      };
      return _this;
    }

    createClass(MDCChipSetFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler(MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
        this.adapter_.registerInteractionHandler(MDCChipFoundation.strings.REMOVAL_EVENT, this.chipRemovalHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler(MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
        this.adapter_.deregisterInteractionHandler(MDCChipFoundation.strings.REMOVAL_EVENT, this.chipRemovalHandler_);
      }

      /**
       * Returns a new chip element with the given text, leading icon, and trailing icon,
       * added to the root chip set element.
       * @param {string} text
       * @param {?Element} leadingIcon
       * @param {?Element} trailingIcon
       * @return {!Element}
       */

    }, {
      key: 'addChip',
      value: function addChip(text, leadingIcon, trailingIcon) {
        var chipEl = this.adapter_.appendChip(text, leadingIcon, trailingIcon);
        return chipEl;
      }

      /**
       * Selects the given chip. Deselects all other chips if the chip set is of the choice variant.
       * @param {!MDCChipFoundation} chipFoundation
       */

    }, {
      key: 'select',
      value: function select(chipFoundation) {
        if (this.adapter_.hasClass(cssClasses$4.CHOICE)) {
          this.deselectAll_();
        }
        chipFoundation.setSelected(true);
        this.selectedChips_.push(chipFoundation);
      }

      /**
       * Deselects the given chip.
       * @param {!MDCChipFoundation} chipFoundation
       */

    }, {
      key: 'deselect',
      value: function deselect(chipFoundation) {
        var index = this.selectedChips_.indexOf(chipFoundation);
        if (index >= 0) {
          this.selectedChips_.splice(index, 1);
        }
        chipFoundation.setSelected(false);
      }

      /** Deselects all selected chips. */

    }, {
      key: 'deselectAll_',
      value: function deselectAll_() {
        this.selectedChips_.forEach(function (chipFoundation) {
          chipFoundation.setSelected(false);
        });
        this.selectedChips_.length = 0;
      }

      /**
       * Handles a chip interaction event
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleChipInteraction_',
      value: function handleChipInteraction_(evt) {
        var chipFoundation = evt.detail.chip.foundation;
        if (this.adapter_.hasClass(cssClasses$4.CHOICE) || this.adapter_.hasClass(cssClasses$4.FILTER)) {
          if (chipFoundation.isSelected()) {
            this.deselect(chipFoundation);
          } else {
            this.select(chipFoundation);
          }
        }
      }

      /**
       * Handles the event when a chip is removed.
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleChipRemoval_',
      value: function handleChipRemoval_(evt) {
        var chip = evt.detail.chip;

        this.deselect(chip.foundation);
        this.adapter_.removeChip(chip);
      }
    }]);
    return MDCChipSetFoundation;
  }(MDCFoundation);

  var mdcChipSet = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', _vm._g({ class: _vm.classes }, _vm.$listeners), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-chip-set',
    props: {
      choice: [Boolean],
      filter: [Boolean],
      input: [Boolean]
    },
    provide: function provide() {
      return { mdcChipSet: this };
    },
    data: function data() {
      return {
        classes: {
          'mdc-chip-set': true,
          'mdc-chip-set--choice': this.choice,
          'mdc-chip-set--filter': this.filter,
          'mdc-chip-set--input': this.input
        }
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipSetFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        },
        appendChip: function appendChip(text, leadingIcon, trailingIcon) {
          var chipTextEl = document.createElement('div');
          chipTextEl.classList.add(MDCChipFoundation.cssClasses.TEXT);
          chipTextEl.appendChild(document.createTextNode(text));

          var chipEl = document.createElement('div');
          chipEl.classList.add(MDCChipFoundation.cssClasses.CHIP);
          if (leadingIcon) {
            chipEl.appendChild(leadingIcon);
          }
          chipEl.appendChild(chipTextEl);
          if (trailingIcon) {
            chipEl.appendChild(trailingIcon);
          }
          _this.root_.appendChild(chipEl);
          return chipEl;
        },
        removeChip: function removeChip(chip) {
          var index = _this.chips.indexOf(chip);
          _this.chips.splice(index, 1);
          chip.remove();
        }
      });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },

    methods: {}
  };

  var VueMDCChipSet = BasePlugin({
    mdcChip: mdcChip,
    mdcChipSet: mdcChipSet
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$5 = {
    ROOT: 'mdc-dialog',
    OPEN: 'mdc-dialog--open',
    ANIMATING: 'mdc-dialog--animating',
    BACKDROP: 'mdc-dialog__backdrop',
    SCROLL_LOCK: 'mdc-dialog-scroll-lock',
    ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
    CANCEL_BTN: 'mdc-dialog__footer__button--cancel'
  };

  var strings$5 = {
    OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
    DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
    ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
    ACCEPT_EVENT: 'MDCDialog:accept',
    CANCEL_EVENT: 'MDCDialog:cancel'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCDialogFoundation = function (_MDCFoundation) {
    inherits(MDCDialogFoundation, _MDCFoundation);
    createClass(MDCDialogFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$5;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$5;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          notifyAccept: function notifyAccept() {},
          notifyCancel: function notifyCancel() {},
          trapFocusOnSurface: function trapFocusOnSurface() {},
          untrapFocusOnSurface: function untrapFocusOnSurface() {},
          isDialog: function isDialog() {
            return (/* el: Element */ /* boolean */false
            );
          }
        };
      }
    }]);

    function MDCDialogFoundation(adapter) {
      classCallCheck(this, MDCDialogFoundation);

      var _this = possibleConstructorReturn(this, (MDCDialogFoundation.__proto__ || Object.getPrototypeOf(MDCDialogFoundation)).call(this, _extends(MDCDialogFoundation.defaultAdapter, adapter)));

      _this.isOpen_ = false;
      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$5.BACKDROP)) {
          _this.cancel(true);
        }
      };
      _this.dialogClickHandler_ = function (evt) {
        return _this.handleDialogClick_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.cancel(true);
        }
      };
      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };
      return _this;
    }

    createClass(MDCDialogFoundation, [{
      key: 'destroy',
      value: function destroy() {
        // Ensure that dialog is cleaned up when destroyed
        if (this.isOpen_) {
          this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
          this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
          this.adapter_.untrapFocusOnSurface();
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
          this.enableScroll_();
        }
      }
    }, {
      key: 'open',
      value: function open() {
        this.isOpen_ = true;
        this.disableScroll_();
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
      }
    }, {
      key: 'close',
      value: function close() {
        this.isOpen_ = false;
        this.enableScroll_();
        this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.untrapFocusOnSurface();
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }
    }, {
      key: 'accept',
      value: function accept(shouldNotify) {
        if (shouldNotify) {
          this.adapter_.notifyAccept();
        }

        this.close();
      }
    }, {
      key: 'cancel',
      value: function cancel(shouldNotify) {
        if (shouldNotify) {
          this.adapter_.notifyCancel();
        }

        this.close();
      }
    }, {
      key: 'handleDialogClick_',
      value: function handleDialogClick_(evt) {
        var target = evt.target;

        if (this.adapter_.eventTargetHasClass(target, cssClasses$5.ACCEPT_BTN)) {
          this.accept(true);
        } else if (this.adapter_.eventTargetHasClass(target, cssClasses$5.CANCEL_BTN)) {
          this.cancel(true);
        }
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (this.adapter_.isDialog(evt.target)) {
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
          if (this.isOpen_) {
            this.adapter_.trapFocusOnSurface();
          }      }    }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$5.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$5.SCROLL_LOCK);
      }
    }]);
    return MDCDialogFoundation;
  }(MDCFoundation);

  var tabbable = function (el, options) {
    options = options || {};

    var elementDocument = el.ownerDocument || el;
    var basicTabbables = [];
    var orderedTabbables = [];

    // A node is "available" if
    // - it's computed style
    var isUnavailable = createIsUnavailable(elementDocument);

    var candidateSelectors = ['input', 'select', 'a[href]', 'textarea', 'button', '[tabindex]'];

    var candidates = el.querySelectorAll(candidateSelectors.join(','));

    if (options.includeContainer) {
      var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

      if (candidateSelectors.some(function (candidateSelector) {
        return matches.call(el, candidateSelector);
      })) {
        candidates = Array.prototype.slice.apply(candidates);
        candidates.unshift(el);
      }
    }

    var candidate, candidateIndexAttr, candidateIndex;
    for (var i = 0, l = candidates.length; i < l; i++) {
      candidate = candidates[i];
      candidateIndexAttr = parseInt(candidate.getAttribute('tabindex'), 10);
      candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;

      if (candidateIndex < 0 || candidate.tagName === 'INPUT' && candidate.type === 'hidden' || candidate.disabled || isUnavailable(candidate, elementDocument)) {
        continue;
      }

      if (candidateIndex === 0) {
        basicTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          index: i,
          tabIndex: candidateIndex,
          node: candidate
        });
      }
    }

    var tabbableNodes = orderedTabbables.sort(function (a, b) {
      return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
    }).map(function (a) {
      return a.node;
    });

    Array.prototype.push.apply(tabbableNodes, basicTabbables);

    return tabbableNodes;
  };

  function createIsUnavailable(elementDocument) {
    // Node cache must be refreshed on every check, in case
    // the content of the element has changed
    var isOffCache = [];

    // "off" means `display: none;`, as opposed to "hidden",
    // which means `visibility: hidden;`. getComputedStyle
    // accurately reflects visiblity in context but not
    // "off" state, so we need to recursively check parents.

    function isOff(node, nodeComputedStyle) {
      if (node === elementDocument.documentElement) return false;

      // Find the cached node (Array.prototype.find not available in IE9)
      for (var i = 0, length = isOffCache.length; i < length; i++) {
        if (isOffCache[i][0] === node) return isOffCache[i][1];
      }

      nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

      var result = false;

      if (nodeComputedStyle.display === 'none') {
        result = true;
      } else if (node.parentNode) {
        result = isOff(node.parentNode);
      }

      isOffCache.push([node, result]);

      return result;
    }

    return function isUnavailable(node) {
      if (node === elementDocument.documentElement) return false;

      var computedStyle = elementDocument.defaultView.getComputedStyle(node);

      if (isOff(node, computedStyle)) return true;

      return computedStyle.visibility === 'hidden';
    };
  }

  var tabbable$1 = /*#__PURE__*/Object.freeze({
    default: tabbable,
    __moduleExports: tabbable
  });

  var tabbable$2 = ( tabbable$1 && tabbable ) || tabbable$1;

  var listeningFocusTrap = null;

  function focusTrap(element, userOptions) {
    var tabbableNodes = [];
    var firstTabbableNode = null;
    var lastTabbableNode = null;
    var nodeFocusedBeforeActivation = null;
    var active = false;
    var paused = false;
    var tabEvent = null;

    var container = typeof element === 'string' ? document.querySelector(element) : element;

    var config = userOptions || {};
    config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== undefined ? userOptions.returnFocusOnDeactivate : true;
    config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== undefined ? userOptions.escapeDeactivates : true;

    var trap = {
      activate: activate,
      deactivate: deactivate,
      pause: pause,
      unpause: unpause
    };

    return trap;

    function activate(activateOptions) {
      if (active) return;

      var defaultedActivateOptions = {
        onActivate: activateOptions && activateOptions.onActivate !== undefined ? activateOptions.onActivate : config.onActivate
      };

      active = true;
      paused = false;
      nodeFocusedBeforeActivation = document.activeElement;

      if (defaultedActivateOptions.onActivate) {
        defaultedActivateOptions.onActivate();
      }

      addListeners();
      return trap;
    }

    function deactivate(deactivateOptions) {
      if (!active) return;

      var defaultedDeactivateOptions = {
        returnFocus: deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
        onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate
      };

      removeListeners();

      if (defaultedDeactivateOptions.onDeactivate) {
        defaultedDeactivateOptions.onDeactivate();
      }

      if (defaultedDeactivateOptions.returnFocus) {
        setTimeout(function () {
          tryFocus(nodeFocusedBeforeActivation);
        }, 0);
      }

      active = false;
      paused = false;
      return this;
    }

    function pause() {
      if (paused || !active) return;
      paused = true;
      removeListeners();
    }

    function unpause() {
      if (!paused || !active) return;
      paused = false;
      addListeners();
    }

    function addListeners() {
      if (!active) return;

      // There can be only one listening focus trap at a time
      if (listeningFocusTrap) {
        listeningFocusTrap.pause();
      }
      listeningFocusTrap = trap;

      updateTabbableNodes();
      tryFocus(firstFocusNode());
      document.addEventListener('focus', checkFocus, true);
      document.addEventListener('click', checkClick, true);
      document.addEventListener('mousedown', checkPointerDown, true);
      document.addEventListener('touchstart', checkPointerDown, true);
      document.addEventListener('keydown', checkKey, true);

      return trap;
    }

    function removeListeners() {
      if (!active || listeningFocusTrap !== trap) return;

      document.removeEventListener('focus', checkFocus, true);
      document.removeEventListener('click', checkClick, true);
      document.removeEventListener('mousedown', checkPointerDown, true);
      document.removeEventListener('touchstart', checkPointerDown, true);
      document.removeEventListener('keydown', checkKey, true);

      listeningFocusTrap = null;

      return trap;
    }

    function getNodeForOption(optionName) {
      var optionValue = config[optionName];
      var node = optionValue;
      if (!optionValue) {
        return null;
      }
      if (typeof optionValue === 'string') {
        node = document.querySelector(optionValue);
        if (!node) {
          throw new Error('`' + optionName + '` refers to no known node');
        }
      }
      if (typeof optionValue === 'function') {
        node = optionValue();
        if (!node) {
          throw new Error('`' + optionName + '` did not return a node');
        }
      }
      return node;
    }

    function firstFocusNode() {
      var node;
      if (getNodeForOption('initialFocus') !== null) {
        node = getNodeForOption('initialFocus');
      } else if (container.contains(document.activeElement)) {
        node = document.activeElement;
      } else {
        node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
      }

      if (!node) {
        throw new Error('You can\'t have a focus-trap without at least one focusable element');
      }

      return node;
    }

    // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event
    function checkPointerDown(e) {
      if (config.clickOutsideDeactivates && !container.contains(e.target)) {
        deactivate({ returnFocus: false });
      }
    }

    function checkClick(e) {
      if (config.clickOutsideDeactivates) return;
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
    }

    function checkFocus(e) {
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      // Checking for a blur method here resolves a Firefox issue (#15)
      if (typeof e.target.blur === 'function') e.target.blur();

      if (tabEvent) {
        readjustFocus(tabEvent);
      }
    }

    function checkKey(e) {
      if (e.key === 'Tab' || e.keyCode === 9) {
        handleTab(e);
      }

      if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
        deactivate();
      }
    }

    function handleTab(e) {
      updateTabbableNodes();

      if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
        return tabEvent = e;
      }

      e.preventDefault();
      var currentFocusIndex = tabbableNodes.indexOf(e.target);

      if (e.shiftKey) {
        if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
          return tryFocus(lastTabbableNode);
        }
        return tryFocus(tabbableNodes[currentFocusIndex - 1]);
      }

      if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

      tryFocus(tabbableNodes[currentFocusIndex + 1]);
    }

    function updateTabbableNodes() {
      tabbableNodes = tabbable$2(container);
      firstTabbableNode = tabbableNodes[0];
      lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
    }

    function readjustFocus(e) {
      if (e.shiftKey) return tryFocus(lastTabbableNode);

      tryFocus(firstTabbableNode);
    }
  }

  function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
  }

  function tryFocus(node) {
    if (!node || !node.focus) return;
    if (node === document.activeElement) return;

    node.focus();
    if (node.tagName.toLowerCase() === 'input') {
      node.select();
    }
  }

  var focusTrap_1 = focusTrap;

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  function createFocusTrapInstance(surfaceEl, acceptButtonEl) {
    var focusTrapFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : focusTrap_1;

    return focusTrapFactory(surfaceEl, {
      initialFocus: acceptButtonEl,
      clickOutsideDeactivates: true
    });
  }

  var mdcDialog = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { ref: "root", staticClass: "mdc-dialog", class: _vm.classes, style: _vm.styles, attrs: { "aria-labelledby": 'label' + _vm.vma_uid_, "aria-describedby": 'desc' + _vm.vma_uid_, "role": "alertdialog" } }, [_c('div', { ref: "surface", staticClass: "mdc-dialog__surface", class: _vm.surfaceClasses }, [_c('header', { staticClass: "mdc-dialog__header" }, [_c('h2', { staticClass: "mdc-dialog__header__title", attrs: { "id": 'label' + _vm.vma_uid_ } }, [_vm._v(" " + _vm._s(_vm.title) + " ")])]), _vm._v(" "), _c('section', { staticClass: "mdc-dialog__body", class: _vm.bodyClasses, attrs: { "id": 'desc' + _vm.vma_uid_ } }, [_vm._t("default")], 2), _vm._v(" "), _c('footer', { staticClass: "mdc-dialog__footer" }, [_vm.cancel ? _c('mdcButton', { ref: "cancel", staticClass: "mdc-dialog__footer__button mdc-dialog__footer__button--cancel", class: { 'mdc-dialog__action': _vm.accent }, on: { "click": _vm.onCancel } }, [_vm._v(_vm._s(_vm.cancel))]) : _vm._e(), _vm._v(" "), _c('mdcButton', { ref: "accept", staticClass: "mdc-dialog__footer__button mdc-dialog__footer__button--accept", class: { 'mdc-dialog__action': _vm.accent }, attrs: { "disabled": _vm.acceptDisabled }, on: { "click": _vm.onAccept } }, [_vm._v(_vm._s(_vm.accept))])], 1)]), _vm._v(" "), _c('div', { staticClass: "mdc-dialog__backdrop" })]);
    }, staticRenderFns: [],
    name: 'mdc-dialog',
    components: {
      mdcButton: mdcButton
    },
    mixins: [VMAUniqueIdMixin],
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      title: { type: String, required: true },
      accept: { type: String, default: 'Ok' },
      acceptDisabled: Boolean,
      cancel: { type: String, default: 'Cancel' },
      accent: Boolean,
      scrollable: Boolean,
      open: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-theme--dark': this.dark
        },
        styles: {},
        surfaceClasses: {},
        bodyClasses: {
          'mdc-dialog__body--scrollable': this.scrollable
        }
      };
    },

    watch: { open: 'onOpen_' },
    mounted: function mounted() {
      var _this = this;

      this.focusTrap = createFocusTrapInstance(this.$refs.surface, this.$refs.accept);

      this.foundation = new MDCDialogFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$refs.root.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$refs.root.removeEventListener(evt, handler);
        },
        registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /*evt, handler*/{
          // VMA_HACK: handle button clicks ourselves
          // this.$refs.surface.addEventListener(evt, handler)
        },
        deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /*evt, handler*/{
          // VMA_HACK: handle button clicks ourselves
          // this.$refs.surface.removeEventListener(evt, handler)
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          return document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          return document.removeEventListener('keydown', handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          return _this.$refs.surface.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          return _this.$refs.surface.removeEventListener('transitionend', handler);
        },
        notifyAccept: function notifyAccept() {
          _this.$emit('change', false);
          _this.$emit('accept');
        },
        notifyCancel: function notifyCancel() {
          _this.$emit('change', false);
          _this.$emit('cancel');
        },
        trapFocusOnSurface: function trapFocusOnSurface() {
          return _this.focusTrap.activate();
        },
        untrapFocusOnSurface: function untrapFocusOnSurface() {
          return _this.focusTrap.deactivate();
        },
        isDialog: function isDialog(el) {
          return _this.$refs.surface === el;
        }
      });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },

    methods: {
      onOpen_: function onOpen_(value) {
        if (value) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      onCancel: function onCancel() {
        this.foundation.cancel(true);
      },
      onAccept: function onAccept() {
        var _this2 = this;

        if (this.$listeners['validate']) {
          this.$emit('validate', {
            accept: function accept() {
              var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              // if notify = false, the dialog will close
              // but the notifyAccept method will not be called
              // so we need to notify listeners the open state
              // is changing.
              if (!notify) {
                _this2.$emit('change', false);
              }
              _this2.foundation.accept(notify);
            }
          });
        } else {
          this.foundation.accept(true);
        }
      },
      show: function show() {
        this.foundation.open();
      },
      close: function close() {
        this.foundation.close();
      }
    }
  };

  var VueMDCDialog = BasePlugin({
    mdcDialog: mdcDialog
  });

  var mdcPermanentDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-permanent-drawer mdc-drawer--permanent mdc-typography" }, [_c('nav', { staticClass: "mdc-drawer__content" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-permanent-drawer',
    props: {
      'toolbar-spacer': Boolean
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
    inherits(MDCSlidableDrawerFoundation, _MDCFoundation);
    createClass(MDCSlidableDrawerFoundation, null, [{
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          hasClass: function hasClass() /* className: string */{},
          hasNecessaryDom: function hasNecessaryDom() {
            return (/* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          setTranslateX: function setTranslateX() /* value: number | null */{},
          getFocusableElements: function getFocusableElements() /* NodeList */{},
          saveElementTabState: function saveElementTabState() /* el: Element */{},
          restoreElementTabState: function restoreElementTabState() /* el: Element */{},
          makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
          notifyOpen: function notifyOpen() {},
          notifyClose: function notifyClose() {},
          isRtl: function isRtl() {
            return (/* boolean */false
            );
          },
          getDrawerWidth: function getDrawerWidth() {
            return (/* number */0
            );
          }
        };
      }
    }]);

    function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
      classCallCheck(this, MDCSlidableDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, _extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

      _this.rootCssClass_ = rootCssClass;
      _this.animatingCssClass_ = animatingCssClass;
      _this.openCssClass_ = openCssClass;

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };

      _this.inert_ = false;

      _this.componentTouchStartHandler_ = function (evt) {
        return _this.handleTouchStart_(evt);
      };
      _this.componentTouchMoveHandler_ = function (evt) {
        return _this.handleTouchMove_(evt);
      };
      _this.componentTouchEndHandler_ = function (evt) {
        return _this.handleTouchEnd_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.close();
        }
      };
      return _this;
    }

    createClass(MDCSlidableDrawerFoundation, [{
      key: 'init',
      value: function init() {
        var ROOT = this.rootCssClass_;
        var OPEN = this.openCssClass_;

        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        } else {
          this.detabinate_();
          this.isOpen_ = false;
        }

        this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
        // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.addClass(this.openCssClass_);
        this.retabinate_();
        // Debounce multiple calls
        if (!this.isOpen_) {
          this.adapter_.notifyOpen();
        }
        this.isOpen_ = true;
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.removeClass(this.openCssClass_);
        this.detabinate_();
        // Debounce multiple calls
        if (this.isOpen_) {
          this.adapter_.notifyClose();
        }
        this.isOpen_ = false;
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /**
       *  Render all children of the drawer inert when it's closed.
       */

    }, {
      key: 'detabinate_',
      value: function detabinate_() {
        if (this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.saveElementTabState(elements[i]);
            this.adapter_.makeElementUntabbable(elements[i]);
          }
        }

        this.inert_ = true;
      }

      /**
       *  Make all children of the drawer tabbable again when it's open.
       */

    }, {
      key: 'retabinate_',
      value: function retabinate_() {
        if (!this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.restoreElementTabState(elements[i]);
          }
        }

        this.inert_ = false;
      }
    }, {
      key: 'handleTouchStart_',
      value: function handleTouchStart_(evt) {
        if (!this.adapter_.hasClass(this.openCssClass_)) {
          return;
        }
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.direction_ = this.adapter_.isRtl() ? -1 : 1;
        this.drawerWidth_ = this.adapter_.getDrawerWidth();
        this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
        this.currentX_ = this.startX_;

        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
      }
    }, {
      key: 'handleTouchMove_',
      value: function handleTouchMove_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
      }
    }, {
      key: 'handleTouchEnd_',
      value: function handleTouchEnd_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.prepareForTouchEnd_();

        // Did the user close the drawer by more than 50%?
        if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
          this.close();
        } else {
          // Triggering an open here means we'll get a nice animation back to the fully open state.
          this.open();
        }
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        cancelAnimationFrame(this.updateRaf_);
        this.adapter_.setTranslateX(null);
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
        this.adapter_.setTranslateX(this.newPosition_);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_() {
        // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
        // if the event target is the root event target currently transitioning.
        return false;
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (this.isRootTransitioningEventTarget_(evt.target)) {
          this.adapter_.removeClass(this.animatingCssClass_);
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        }
      }
    }, {
      key: 'newPosition_',
      get: function get$$1() {
        var newPos = null;

        if (this.direction_ === 1) {
          newPos = Math.min(0, this.currentX_ - this.startX_);
        } else {
          newPos = Math.max(0, this.currentX_ - this.startX_);
        }

        return newPos;
      }
    }]);
    return MDCSlidableDrawerFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$6 = {
    ROOT: 'mdc-drawer--persistent',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating'
  };

  var strings$6 = {
    DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCPersistentDrawer:open',
    CLOSE_EVENT: 'MDCPersistentDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCPersistentDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$6;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$6;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          isDrawer: function isDrawer() {
            return false;
          }
        });
      }
    }]);

    function MDCPersistentDrawerFoundation(adapter) {
      classCallCheck(this, MDCPersistentDrawerFoundation);
      return possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, _extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
    }

    createClass(MDCPersistentDrawerFoundation, [{
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }]);
    return MDCPersistentDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var TAB_DATA = 'data-mdc-tabindex';
  var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

  var storedTransformPropertyName_ = void 0;
  var supportsPassive_$2 = void 0;

  // Remap touch events to pointer events, if the browser doesn't support touch events.
  function remapEvent(eventName) {
    var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

    if (!('ontouchstart' in globalObj.document)) {
      switch (eventName) {
        case 'touchstart':
          return 'pointerdown';
        case 'touchmove':
          return 'pointermove';
        case 'touchend':
          return 'pointerup';
        default:
          return eventName;
      }
    }

    return eventName;
  }

  // Choose the correct transform property to use on the current browser.
  function getTransformPropertyName() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_ === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
      storedTransformPropertyName_ = transformPropertyName;
    }

    return storedTransformPropertyName_;
  }

  // Determine whether the current browser supports CSS properties.
  function supportsCssCustomProperties() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

    if ('CSS' in globalObj) {
      return globalObj.CSS.supports('(--color: red)');
    }
    return false;
  }

  // Determine whether the current browser supports passive event listeners, and if so, use them.
  function applyPassive$2() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$2 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$2 = isSupported;
    }

    return supportsPassive_$2 ? { passive: true } : false;
  }

  // Save the tab state for an element.
  function saveElementTabState(el) {
    if (el.hasAttribute('tabindex')) {
      el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
    }
    el.setAttribute(TAB_DATA_HANDLED, true);
  }

  // Restore the tab state for an element, if it was saved.
  function restoreElementTabState(el) {
    // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
    if (el.hasAttribute(TAB_DATA_HANDLED)) {
      if (el.hasAttribute(TAB_DATA)) {
        el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
        el.removeAttribute(TAB_DATA);
      } else {
        el.removeAttribute('tabindex');
      }
      el.removeAttribute(TAB_DATA_HANDLED);
    }
  }

  var mdcPersistentDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-persistent-drawer mdc-drawer--persistent mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-persistent-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      'toolbar-spacer': Boolean,
      open: Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: '_refresh'
    },
    mounted: function mounted() {
      var _this = this;

      var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


      this.foundation = new MDCPersistentDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    },

    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$7 = {
    ROOT: 'mdc-drawer--temporary',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating',
    SCROLL_LOCK: 'mdc-drawer-scroll-lock'
  };

  var strings$7 = {
    DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
    OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCTemporaryDrawer:open',
    CLOSE_EVENT: 'MDCTemporaryDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCTemporaryDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$7;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$7;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          isDrawer: function isDrawer() {
            return false;
          },
          updateCssVariable: function updateCssVariable() /* value: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          }
        });
      }
    }]);

    function MDCTemporaryDrawerFoundation(adapter) {
      classCallCheck(this, MDCTemporaryDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, _extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$7.ROOT)) {
          _this.close(true);
        }
      };
      return _this;
    }

    createClass(MDCTemporaryDrawerFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'init', this).call(this);

        // Make browser aware of custom property being used in this element.
        // Workaround for certain types of hard-to-reproduce heisenbugs.
        this.adapter_.updateCssVariable(0);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'destroy', this).call(this);

        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.enableScroll_();
      }
    }, {
      key: 'open',
      value: function open() {
        this.disableScroll_();
        // Make sure custom property values are cleared before starting.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'open', this).call(this);
      }
    }, {
      key: 'close',
      value: function close() {
        // Make sure custom property values are cleared before making any changes.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'close', this).call(this);
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'prepareForTouchEnd_', this).call(this);

        this.adapter_.updateCssVariable('');
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'updateDrawer_', this).call(this);

        var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
        this.adapter_.updateCssVariable(newOpacity);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'handleTransitionEnd_', this).call(this, evt);
        if (!this.isOpen_) {
          this.enableScroll_();
        }
      }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$7.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$7.SCROLL_LOCK);
      }
    }]);
    return MDCTemporaryDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  var mdcTemporaryDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-temporary-drawer mdc-drawer--temporary mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-temporary-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: Boolean,
      'toolbar-spacer': Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: '_refresh'
    },
    mounted: function mounted() {
      var _this = this;

      var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
          FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
          OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


      this.foundation = new MDCTemporaryDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        updateCssVariable: function updateCssVariable(value) {
          if (supportsCssCustomProperties()) {
            _this.$el.style.setProperty(OPACITY_VAR_NAME, value);
          }
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    },

    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    }
  };

  var media = new (function () {
    function _class() {
      classCallCheck(this, _class);
    }

    createClass(_class, [{
      key: 'small',
      get: function get$$1() {
        return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
      }
    }, {
      key: 'large',
      get: function get$$1() {
        return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
      }
    }]);
    return _class;
  }())();

  var mdcDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { ref: "drawer", tag: "component", staticClass: "mdc-drawer", attrs: { "toolbar-spacer": _vm.toolbarSpacer }, on: { "change": _vm.onChange, "open": function open($event) {
            _vm.$emit('open');
          }, "close": function close($event) {
            _vm.$emit('close');
          } }, model: { value: _vm.open_, callback: function callback($$v) {
            _vm.open_ = $$v;
          }, expression: "open_" } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer',
    components: {
      'mdc-permanent-drawer': mdcPermanentDrawer,
      'mdc-persistent-drawer': mdcPersistentDrawer,
      'mdc-temporary-drawer': mdcTemporaryDrawer
    },
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: Boolean,
      permanent: Boolean,
      persistent: Boolean,
      temporary: Boolean,
      drawerType: {
        type: String,
        validator: function validator(val) {
          return val in ['temporary', 'persistent', 'permanent'];
        }
      },
      toolbarSpacer: Boolean,
      toggleOn: String,
      toggleOnSource: { type: Object, required: false },
      openOn: String,
      openOnSource: { type: Object, required: false },
      closeOn: String,
      closeOnSource: { type: Object, required: false }
    },
    provide: function provide() {
      return { mdcDrawer: this };
    },
    data: function data() {
      return {
        small: false,
        large: false,
        open_: false
      };
    },

    computed: {
      type: function type() {
        if (this.permanent) {
          return 'mdc-permanent-drawer';
        } else if (this.persistent) {
          return 'mdc-persistent-drawer';
        } else if (this.temporary) {
          return 'mdc-temporary-drawer';
        } else {
          switch (this.drawerType) {
            case 'permanent':
              return 'mdc-permanent-drawer';
            case 'persistent':
              return 'mdc-persistent-drawer';
            case 'temporary':
              return 'mdc-temporary-drawer';
            default:
              return this.small ? 'mdc-temporary-drawer' : 'mdc-persistent-drawer';
          }
        }
      },
      isPermanent: function isPermanent() {
        return this.permanent || this.type === 'mdc-permanent-drawer';
      },
      isPersistent: function isPersistent() {
        return this.persistent || this.type === 'mdc-persistent-drawer';
      },
      isTemporary: function isTemporary() {
        return this.temporary || this.type === 'mdc-temporary-drawer';
      },
      isResponsive: function isResponsive() {
        return !(this.permanent || this.persistent || this.temporary || this.drawerType);
      }
    },
    watch: {
      open: 'onOpen_'
    },
    created: function created() {
      if (window && window.matchMedia) {
        this.small = media.small.matches;
        this.large = media.large.matches;
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.toggleOn) {
        this.toggleOnEventSource = this.toggleOnSource || this.$root;
        this.toggleOnEventSource.$on(this.toggleOn, this.toggleDrawer);
      }
      if (this.openOn) {
        this.openOnEventSource = this.openOnSource || this.$root;
        this.openOnEventSource.$on(this.openOn, this.openDrawer);
      }
      if (this.closeOn) {
        this.closeOnEventSource = this.closeOnSource || this.$root;
        this.closeOnEventSource.$on(this.closeOn, this.closeDrawer);
      }
      media.small.addListener(this.refreshMedia);
      media.large.addListener(this.refreshMedia);
      this.$nextTick(function () {
        return _this.refreshMedia();
      });
    },
    beforeDestroy: function beforeDestroy() {
      media.small.removeListener(this.refreshMedia);
      media.large.removeListener(this.refreshMedia);

      if (this.toggleOnEventSource) {
        this.toggleOnEventSource.$off(this.toggleOn, this.toggleDrawer);
      }
      if (this.openOnEventSource) {
        this.openOnEventSource.$off(this.openOn, this.openDrawer);
      }
      if (this.closeOnEventSource) {
        this.closeOnEventSource.$off(this.closeOn, this.closeDrawer);
      }
    },

    methods: {
      onOpen_: function onOpen_(value) {
        this.isPermanent || (this.open_ = value);
      },
      onChange: function onChange(event) {
        this.$emit('change', event);
        this.$root.$emit('vma:layout');
      },
      openDrawer: function openDrawer() {
        this.open_ = true;
      },
      closeDrawer: function closeDrawer() {
        this.isPermanent || (this.open_ = false);
      },
      toggleDrawer: function toggleDrawer() {
        this.isPermanent || (this.isOpen() ? this.closeDrawer() : this.openDrawer());
      },
      isOpen: function isOpen() {
        return this.isPermanent || this.open_;
      },
      refreshMedia: function refreshMedia() {
        this.small = media.small.matches;
        this.large = media.large.matches;
        if (this.isResponsive) {
          if (this.large) {
            this.openDrawer();
          } else {
            this.closeDrawer();
          }
        }
      }
    }
  };

  var mdcDrawerLayout = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-drawer-layout" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-layout'
  };

  var mdcDrawerHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.show ? _c('header', { staticClass: "mdc-drawer-header mdc-drawer__header" }, [_c('div', { staticClass: "mdc-drawer__header-content" }, [_vm._t("default")], 2)]) : _vm._e();
    }, staticRenderFns: [],
    name: 'mdc-drawer-header',
    props: {
      permanent: Boolean,
      persistent: Boolean,
      temporary: Boolean
    },
    inject: ['mdcDrawer'],
    computed: {
      show: function show() {
        if (this.temporary || this.persistent || this.permanent) {
          return this.temporary && this.mdcDrawer.isTemporary || this.persistent && this.mdcDrawer.isPersistent || this.permanent && this.mdcDrawer.isPermanent;
        } else {
          return true;
        }
      }
    }
  };

  var mdcDrawerList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-list',
    props: {
      dense: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-list--dense': this.dense
        }
      };
    }
  };

  var mdcDrawerItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', _vm._g({ staticClass: "mdc-drawer-item mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "link": _vm.link } }, _vm.mylisteners), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail", [_c('i', { staticClass: "material-icons", attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.startIcon))])])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-item',
    inject: ['mdcDrawer'],
    mixins: [DispatchEventMixin, CustomLinkMixin],
    props: {
      startIcon: String,
      temporaryClose: {
        type: Boolean,
        default: true
      },
      activated: Boolean,
      exactActiveClass: {
        type: String,
        default: 'mdc-list-item--activated'
      }
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      mylisteners: function mylisteners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          click: function click(e) {
            _this.mdcDrawer.isTemporary && _this.temporaryClose && _this.mdcDrawer.closeDrawer();
            _this.dispatchEvent(e);
          }
        });
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--activated': this.activated
        };
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple && this.ripple.destroy();
      this.ripple = null;
    }
  };

  var mdcDrawerDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-divider" });
    }, staticRenderFns: [],
    name: 'mdc-drawer-divider'
  };

  var VueMDCDrawer = BasePlugin({
    mdcDrawer: mdcDrawer,
    mdcDrawerLayout: mdcDrawerLayout,
    mdcDrawerHeader: mdcDrawerHeader,
    mdcDrawerList: mdcDrawerList,
    mdcDrawerItem: mdcDrawerItem,
    mdcDrawerDivider: mdcDrawerDivider
  });

  var mdcElevation = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-elevation" });
    }, staticRenderFns: [],
    name: 'mdc-elevation',
    props: {}
  };

  var VueMDCElevation = BasePlugin({
    mdcElevation: mdcElevation
  });

  var mdcFAB = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', _vm._g({ staticClass: "mdc-fab", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link } }, _vm.listeners), [_c('span', { staticClass: "mdc-fab__icon" }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-fab',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    props: {
      icon: String,
      mini: Boolean,
      absolute: Boolean,
      fixed: Boolean
    },
    data: function data() {
      return {
        classes: {
          'material-icons': this.icon,
          'mdc-fab--mini': this.mini,
          'mdc-fab--absolute': this.absolute,
          'mdc-fab--fixed': this.fixed
        },
        styles: {}
      };
    },

    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', this.icon);
      },
      mini: function mini() {
        this.$set(this.classes, 'mdc-fab--mini', this.mini);
      }
    }
  };

  var VueMDCFab = BasePlugin({
    mdcFAB: mdcFAB
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var strings$8 = {
    TILES_SELECTOR: '.mdc-grid-list__tiles',
    TILE_SELECTOR: '.mdc-grid-tile'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCGridListFoundation = function (_MDCFoundation) {
    inherits(MDCGridListFoundation, _MDCFoundation);
    createClass(MDCGridListFoundation, null, [{
      key: 'strings',
      get: function get$$1() {
        return strings$8;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          getNumberOfTiles: function getNumberOfTiles() {
            return (/* number */0
            );
          },
          getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          setStyleForTilesElement: function setStyleForTilesElement() /* property: string, value: string */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{}
        };
      }
    }]);

    function MDCGridListFoundation(adapter) {
      classCallCheck(this, MDCGridListFoundation);

      var _this = possibleConstructorReturn(this, (MDCGridListFoundation.__proto__ || Object.getPrototypeOf(MDCGridListFoundation)).call(this, _extends(MDCGridListFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.alignCenter();
      };
      _this.resizeFrame_ = 0;
      return _this;
    }

    createClass(MDCGridListFoundation, [{
      key: 'init',
      value: function init() {
        this.alignCenter();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'alignCenter',
      value: function alignCenter() {
        var _this2 = this;

        if (this.resizeFrame_ !== 0) {
          cancelAnimationFrame(this.resizeFrame_);
        }
        this.resizeFrame_ = requestAnimationFrame(function () {
          _this2.alignCenter_();
          _this2.resizeFrame_ = 0;
        });
      }
    }, {
      key: 'alignCenter_',
      value: function alignCenter_() {
        if (this.adapter_.getNumberOfTiles() == 0) {
          return;
        }
        var gridWidth = this.adapter_.getOffsetWidth();
        var itemWidth = this.adapter_.getOffsetWidthForTileAtIndex(0);
        var tilesWidth = itemWidth * Math.floor(gridWidth / itemWidth);
        this.adapter_.setStyleForTilesElement('width', tilesWidth + 'px');
      }
    }]);
    return MDCGridListFoundation;
  }(MDCFoundation);

  var mdcGridList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-grid-list" }, [_c('ul', { staticClass: "mdc-grid-list__tiles", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-grid-list',
    props: {
      width: [String, Number],
      ratio: String,
      'narrow-gutter': Boolean,
      'header-caption': Boolean,
      'icon-align-start': Boolean,
      'icon-align-end': Boolean,
      'with-support-text': Boolean,
      interactive: Boolean
    },
    provide: function provide() {
      return { mdcGrid: this };
    },

    computed: {
      classes: function classes() {
        var classes = {};

        classes['mdc-grid-list--tile-gutter-1'] = this.narrowGutter;
        classes['mdc-grid-list--header-caption'] = this.headerCaption;
        classes['mdc-grid-list--tile-aspect-' + this.ratio] = this.ratio;
        classes['mdc-grid-list--with-icon-align-start'] = this.iconAlignStart;
        classes['mdc-grid-list--with-icon-align-end'] = this.iconAlignEnd;
        classes['mdc-grid-list--twoline-caption'] = this.withSupportText;
        classes['mdc-grid-list--non-interactive'] = !this.interactive;

        return classes;
      },
      styles: function styles() {
        var defaultWidth = 200;
        return {
          '--mdc-grid-list-tile-width': (this.width || defaultWidth) + 'px'
        };
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCGridListFoundation({
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getNumberOfTiles: function getNumberOfTiles() {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR).length;
        },
        getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex(index) {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR)[index].offsetWidth;
        },
        setStyleForTilesElement: function setStyleForTilesElement(property, value) {
          _this.$el.querySelector(MDCGridListFoundation.strings.TILES_SELECTOR).style[property] = value;
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcGridTile = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-grid-tile", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined } }, _vm.isInteractive ? _vm.listeners : _vm.clickListener), [_vm.cover ? _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('div', { staticClass: "mdc-grid-tile__primary-content", style: { backgroundImage: 'url(' + _vm.src + ')' } })]) : _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('img', { staticClass: "mdc-grid-tile__primary-content", attrs: { "src": _vm.src } })]), _vm._v(" "), _vm.title || _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__secondary" }, [_vm.icon ? _c('i', { staticClass: "mdc-grid-tile__icon material-icons" }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), _vm.title ? _c('span', { staticClass: "mdc-grid-tile__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._v(" "), _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__support-text" }, [_vm._v(_vm._s(_vm.supportText))]) : _vm._e()]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-grid-tile',
    inject: ['mdcGrid'],
    mixins: [DispatchEventMixin],
    props: {
      src: String,
      cover: Boolean,
      icon: String,
      title: String,
      'support-text': String,
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      clickListener: function clickListener() {
        var _this = this;

        return { click: function click(e) {
            return _this.dispatchEvent(e);
          } };
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-grid-tile--selected': this.selected,
          'mdc-grid-tile--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcGrid && this.mdcGrid.interactive;
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      },
      hasEndDetail: function hasEndDetail() {
        return this.endIcon || this.$slots['end-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },

    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }
  };

  var VueMDCGridList = BasePlugin({
    mdcGridList: mdcGridList,
    mdcGridTile: mdcGridTile
  });

  var mdcIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon mdc-icon--material", class: { 'material-icons': !!_vm.icon } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-icon',
    props: {
      icon: String
    }
  };

  var VueMDCIcon = BasePlugin({
    mdcIcon: mdcIcon
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Icon Toggle. Provides an interface for managing
   * - classes
   * - dom
   * - inner text
   * - event handlers
   * - event dispatch
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCIconToggleAdapter = function () {
    function MDCIconToggleAdapter() {
      classCallCheck(this, MDCIconToggleAdapter);
    }

    createClass(MDCIconToggleAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /** @param {string} text */

    }, {
      key: "setText",
      value: function setText(text) {}

      /** @return {number} */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /** @param {number} tabIndex */

    }, {
      key: "setTabIndex",
      value: function setTabIndex(tabIndex) {}

      /**
       * @param {string} name
       * @return {string}
       */

    }, {
      key: "getAttr",
      value: function getAttr(name) {}

      /**
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(name, value) {}

      /** @param {string} name */

    }, {
      key: "rmAttr",
      value: function rmAttr(name) {}

      /** @param {!IconToggleEvent} evtData */

    }, {
      key: "notifyChange",
      value: function notifyChange(evtData) {}
    }]);
    return MDCIconToggleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$8 = {
    ROOT: 'mdc-icon-toggle',
    DISABLED: 'mdc-icon-toggle--disabled'
  };

  /** @enum {string} */
  var strings$9 = {
    DATA_TOGGLE_ON: 'data-toggle-on',
    DATA_TOGGLE_OFF: 'data-toggle-off',
    ARIA_PRESSED: 'aria-pressed',
    ARIA_DISABLED: 'aria-disabled',
    ARIA_LABEL: 'aria-label',
    CHANGE_EVENT: 'MDCIconToggle:change'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCIconToggleAdapter>}
   */

  var MDCIconToggleFoundation = function (_MDCFoundation) {
    inherits(MDCIconToggleFoundation, _MDCFoundation);
    createClass(MDCIconToggleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$8;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$9;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          setText: function setText() /* text: string */{},
          getTabIndex: function getTabIndex() {
            return (/* number */0
            );
          },
          setTabIndex: function setTabIndex() /* tabIndex: number */{},
          getAttr: function getAttr() {
            return (/* name: string */ /* string */''
            );
          },
          setAttr: function setAttr() /* name: string, value: string */{},
          rmAttr: function rmAttr() /* name: string */{},
          notifyChange: function notifyChange() /* evtData: IconToggleEvent */{}
        };
      }
    }]);

    function MDCIconToggleFoundation(adapter) {
      classCallCheck(this, MDCIconToggleFoundation);

      /** @private {boolean} */
      var _this = possibleConstructorReturn(this, (MDCIconToggleFoundation.__proto__ || Object.getPrototypeOf(MDCIconToggleFoundation)).call(this, _extends(MDCIconToggleFoundation.defaultAdapter, adapter)));

      _this.on_ = false;

      /** @private {boolean} */
      _this.disabled_ = false;

      /** @private {number} */
      _this.savedTabIndex_ = -1;

      /** @private {?IconToggleState} */
      _this.toggleOnData_ = null;

      /** @private {?IconToggleState} */
      _this.toggleOffData_ = null;

      _this.clickHandler_ = /** @private {!EventListener} */function () {
        return _this.toggleFromEvt_();
      };

      /** @private {boolean} */
      _this.isHandlingKeydown_ = false;

      _this.keydownHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = true;
          return evt.preventDefault();
        }
      };

      _this.keyupHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = false;
          _this.toggleFromEvt_();
        }
      };
      return _this;
    }

    createClass(MDCIconToggleFoundation, [{
      key: 'init',
      value: function init() {
        this.refreshToggleData();
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
      }
    }, {
      key: 'refreshToggleData',
      value: function refreshToggleData() {
        var _MDCIconToggleFoundat = MDCIconToggleFoundation.strings,
            DATA_TOGGLE_ON = _MDCIconToggleFoundat.DATA_TOGGLE_ON,
            DATA_TOGGLE_OFF = _MDCIconToggleFoundat.DATA_TOGGLE_OFF;

        this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
        this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
      }

      /** @private */

    }, {
      key: 'toggleFromEvt_',
      value: function toggleFromEvt_() {
        this.toggle();
        var isOn = this.on_;

        this.adapter_.notifyChange( /** @type {!IconToggleEvent} */{ isOn: isOn });
      }

      /** @return {boolean} */

    }, {
      key: 'isOn',
      value: function isOn() {
        return this.on_;
      }

      /** @param {boolean=} isOn */

    }, {
      key: 'toggle',
      value: function toggle() {
        var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;

        this.on_ = isOn;

        var _MDCIconToggleFoundat2 = MDCIconToggleFoundation.strings,
            ARIA_LABEL = _MDCIconToggleFoundat2.ARIA_LABEL,
            ARIA_PRESSED = _MDCIconToggleFoundat2.ARIA_PRESSED;


        if (this.on_) {
          this.adapter_.setAttr(ARIA_PRESSED, 'true');
        } else {
          this.adapter_.setAttr(ARIA_PRESSED, 'false');
        }

        var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
            classToRemove = _ref.cssClass;

        if (classToRemove) {
          this.adapter_.removeClass(classToRemove);
        }

        var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
            content = _ref2.content,
            label = _ref2.label,
            cssClass = _ref2.cssClass;

        if (cssClass) {
          this.adapter_.addClass(cssClass);
        }
        if (content) {
          this.adapter_.setText(content);
        }
        if (label) {
          this.adapter_.setAttr(ARIA_LABEL, label);
        }
      }

      /**
       * @param {string} dataAttr
       * @return {!IconToggleState}
       */

    }, {
      key: 'parseJsonDataAttr_',
      value: function parseJsonDataAttr_(dataAttr) {
        var val = this.adapter_.getAttr(dataAttr);
        if (!val) {
          return {};
        }
        return (/** @type {!IconToggleState} */JSON.parse(val)
        );
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} isDisabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(isDisabled) {
        this.disabled_ = isDisabled;

        var DISABLED = MDCIconToggleFoundation.cssClasses.DISABLED;
        var ARIA_DISABLED = MDCIconToggleFoundation.strings.ARIA_DISABLED;


        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setTabIndex(-1);
          this.adapter_.setAttr(ARIA_DISABLED, 'true');
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.setTabIndex(this.savedTabIndex_);
          this.adapter_.rmAttr(ARIA_DISABLED);
          this.adapter_.removeClass(DISABLED);
        }
      }

      /** @return {boolean} */

    }, {
      key: 'isKeyboardActivated',
      value: function isKeyboardActivated() {
        return this.isHandlingKeydown_;
      }
    }]);
    return MDCIconToggleFoundation;
  }(MDCFoundation);

  /**
   * @param {!KeyboardKey} keyboardKey
   * @return {boolean}
   */
  function isSpace(keyboardKey) {
    return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
  }

  var mdcIConToggle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon-toggle", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": _vm.tabIndex, "data-toggle-on": _vm.toggleOnData, "data-toggle-off": _vm.toggleOffData, "role": "button", "aria-pressed": "false" } }, [_c('i', { class: _vm.iconClasses, attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.text))])]);
    }, staticRenderFns: [],
    name: 'mdc-icon-toggle',
    props: {
      toggleOn: [String, Object],
      toggleOff: [String, Object],
      value: Boolean,
      disabled: Boolean,
      accent: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-icon-toggle--accent': this.accent
        },
        styles: {},
        iconClasses: {},
        tabIndex: 0,
        text: ''
      };
    },

    computed: {
      toggleOnData: function toggleOnData() {
        var toggle = this.toggleOn;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      },
      toggleOffData: function toggleOffData() {
        var toggle = this.toggleOff;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      }
    },
    watch: {
      value: function value(_value) {
        this.foundation && this.foundation.toggle(_value);
      },
      disabled: function disabled(_disabled) {
        this.foundation && this.foundation.setDisabled(_disabled);
      },
      toggleOnData: function toggleOnData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      toggleOffData: function toggleOffData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      accent: function accent(value) {
        this.$set(this.classes, 'mdc-icon-toggle--secondary', value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCIconToggleFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.iconClasses, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.iconClasses, className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$el.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$el.removeEventListener(evt, handler);
        },
        setText: function setText(text) {
          _this.text = text;
        },
        getTabIndex: function getTabIndex() {
          return _this.tabIndex;
        },
        setTabIndex: function setTabIndex(tabIndex) {
          _this.tabIndex = tabIndex;
        },
        getAttr: function getAttr(name, value) {
          return _this.$el.getAttribute(name, value);
        },
        setAttr: function setAttr(name, value) {
          _this.$el.setAttribute(name, value);
        },
        rmAttr: function rmAttr(name) {
          _this.$el.removeAttribute(name);
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('input', evtData.isOn);
        }
      });
      this.foundation.init();
      this.foundation.toggle(this.value);
      this.foundation.setDisabled(this.disabled);

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return _this.foundation.isKeyboardActivated();
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    }
  };

  var VueMDCIconToggle = BasePlugin({
    mdcIConToggle: mdcIConToggle
  });

  var mdcLayoutApp = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-app" }, [_c('div', { staticClass: "mdc-layout-app--toolbar-wrapper" }, [_vm._t("toolbar")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--main-container" }, [_c('div', { staticClass: "mdc-layout-app--drawer-wrapper" }, [_vm._t("drawer")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--content-wrapper" }, [_vm._t("default")], 2)])]);
    }, staticRenderFns: [],
    name: 'mdc-layout-app'
  };

  var VueMDCLayoutApp = BasePlugin({
    mdcLayoutApp: mdcLayoutApp
  });

  var mdcLayoutGrid = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { class: _vm.classes }, [_c('div', { staticClass: "mdc-layout-grid__inner" }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-layout-grid',
    props: {
      'fixed-column-width': Boolean,
      'align-left': Boolean,
      'align-right': Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-layout-grid': true,
          'mdc-layout-grid--fixed-column-width': this.fixedColumnWidth,
          'mdc-layout-grid--align-left': this.alignLeft,
          'mdc-layout-grid--align-right': this.alignRight
        };
      }
    }
  };

  var spanOptions = {
    type: [String, Number],
    default: null,
    validator: function validator(value) {
      var num = Number(value);
      return isFinite(num) && num <= 12 && num > 0;
    }
  };

  var mdcLayoutCell = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-cell mdc-layout-grid__cell", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-layout-cell',
    props: {
      span: spanOptions,
      order: spanOptions,
      phone: spanOptions,
      tablet: spanOptions,
      desktop: spanOptions,
      align: {
        type: String,
        validator: function validator(value) {
          return ['top', 'bottom', 'middle'].indexOf(value) !== -1;
        }
      }
    },
    computed: {
      classes: function classes() {
        var classes = [];

        if (this.span) {
          classes.push("mdc-layout-grid__cell--span-" + this.span);
        }

        if (this.order) {
          classes.push("mdc-layout-grid__cell--order-" + this.order);
        }

        if (this.phone) {
          classes.push("mdc-layout-grid__cell--span-" + this.phone + "-phone");
        }

        if (this.tablet) {
          classes.push("mdc-layout-grid__cell--span-" + this.tablet + "-tablet");
        }

        if (this.desktop) {
          classes.push("mdc-layout-grid__cell--span-" + this.desktop + "-desktop");
        }

        if (this.align) {
          classes.push("mdc-layout-grid__cell--align-" + this.align);
        }

        return classes;
      }
    }
  };

  var mdcLayoutInnerGrid = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-inner-grid mdc-layout-grid__inner" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-layout-inner-grid'
  };

  var VueMDCLayoutGrid = BasePlugin({
    mdcLayoutGrid: mdcLayoutGrid,
    mdcLayoutCell: mdcLayoutCell,
    mdcLayoutInnerGrid: mdcLayoutInnerGrid
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$9 = {
    CLOSED_CLASS: 'mdc-linear-progress--closed',
    INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
    REVERSED_CLASS: 'mdc-linear-progress--reversed'
  };

  var strings$10 = {
    PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
    BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCLinearProgressFoundation = function (_MDCFoundation) {
    inherits(MDCLinearProgressFoundation, _MDCFoundation);
    createClass(MDCLinearProgressFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$9;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$10;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          getPrimaryBar: function getPrimaryBar() /* el: Element */{},
          getBuffer: function getBuffer() /* el: Element */{},
          hasClass: function hasClass() {
            return (/* className: string */false
            );
          },
          removeClass: function removeClass() /* className: string */{},
          setStyle: function setStyle() /* el: Element, styleProperty: string, value: string */{}
        };
      }
    }]);

    function MDCLinearProgressFoundation(adapter) {
      classCallCheck(this, MDCLinearProgressFoundation);
      return possibleConstructorReturn(this, (MDCLinearProgressFoundation.__proto__ || Object.getPrototypeOf(MDCLinearProgressFoundation)).call(this, _extends(MDCLinearProgressFoundation.defaultAdapter, adapter)));
    }

    createClass(MDCLinearProgressFoundation, [{
      key: 'init',
      value: function init() {
        this.determinate_ = !this.adapter_.hasClass(cssClasses$9.INDETERMINATE_CLASS);
        this.reverse_ = this.adapter_.hasClass(cssClasses$9.REVERSED_CLASS);
        this.progress_ = 0;
      }
    }, {
      key: 'setDeterminate',
      value: function setDeterminate(isDeterminate) {
        this.determinate_ = isDeterminate;
        if (this.determinate_) {
          this.adapter_.removeClass(cssClasses$9.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
        } else {
          this.adapter_.addClass(cssClasses$9.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), 1);
          this.setScale_(this.adapter_.getBuffer(), 1);
        }
      }
    }, {
      key: 'setProgress',
      value: function setProgress(value) {
        this.progress_ = value;
        if (this.determinate_) {
          this.setScale_(this.adapter_.getPrimaryBar(), value);
        }
      }
    }, {
      key: 'setBuffer',
      value: function setBuffer(value) {
        if (this.determinate_) {
          this.setScale_(this.adapter_.getBuffer(), value);
        }
      }
    }, {
      key: 'setReverse',
      value: function setReverse(isReversed) {
        this.reverse_ = isReversed;
        if (this.reverse_) {
          this.adapter_.addClass(cssClasses$9.REVERSED_CLASS);
        } else {
          this.adapter_.removeClass(cssClasses$9.REVERSED_CLASS);
        }
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.removeClass(cssClasses$9.CLOSED_CLASS);
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.addClass(cssClasses$9.CLOSED_CLASS);
      }
    }, {
      key: 'setScale_',
      value: function setScale_(el, scaleValue) {
        var _this2 = this;

        var value = 'scaleX(' + scaleValue + ')';
        transformStyleProperties.forEach(function (transformStyleProperty) {
          _this2.adapter_.setStyle(el, transformStyleProperty, value);
        });
      }
    }]);
    return MDCLinearProgressFoundation;
  }(MDCFoundation);

  var ProgressPropType = {
    type: [Number, String],
    validator: function validator(value) {
      return Number(value) >= 0 && Number(value) <= 1;
    }
  };

  var mdcLinearProgress = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress", class: _vm.classes, style: _vm.styles, attrs: { "role": "progressbar" } }, [_c('div', { staticClass: "mdc-linear-progress__buffering-dots" }), _vm._v(" "), _c('div', { ref: "buffer", staticClass: "mdc-linear-progress__buffer" }), _vm._v(" "), _c('div', { ref: "primary", staticClass: "mdc-linear-progress__bar mdc-linear-progress__primary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]), _vm._v(" "), _vm._m(0)]);
    }, staticRenderFns: [function () {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress__bar mdc-linear-progress__secondary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]);
    }],
    name: 'mdc-linear-progress',
    props: {
      open: { type: Boolean, default: true },
      indeterminate: Boolean,
      reverse: Boolean,
      accent: Boolean,
      progress: ProgressPropType,
      buffer: ProgressPropType
    },
    data: function data() {
      return {
        classes: { 'mdc-linear-progress--accent': this.accent },
        styles: {}
      };
    },

    watch: {
      open: function open() {
        if (this.open) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      progress: function progress() {
        this.foundation.setProgress(Number(this.progress));
      },
      buffer: function buffer() {
        this.foundation.setBuffer(Number(this.buffer));
      },
      indeterminate: function indeterminate() {
        this.foundation.setDeterminate(!this.indeterminate);
      },
      reverse: function reverse() {
        this.foundation.setReverse(this.reverse);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCLinearProgressFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        getPrimaryBar: function getPrimaryBar() /* el: Element */{
          return _this.$refs.primary;
        },
        getBuffer: function getBuffer() /* el: Element */{
          return _this.$refs.buffer;
        },
        hasClass: function hasClass(className) {
          _this.$el.classList.contains(className);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        setStyle: function setStyle(el, styleProperty, value) {
          el.style[styleProperty] = value;
        }
      });
      this.foundation.init();

      this.foundation.setReverse(this.reverse);
      this.foundation.setProgress(Number(this.progress));
      this.foundation.setBuffer(Number(this.buffer));
      this.foundation.setDeterminate(!this.indeterminate);
      if (this.open) {
        this.foundation.open();
      } else {
        this.foundation.close();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var VueMDCLinearProgress = BasePlugin({
    mdcLinearProgress: mdcLinearProgress
  });

  var mdcList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('ul', { staticClass: "mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list',
    props: {
      dense: Boolean,
      avatarList: Boolean,
      twoLine: Boolean,
      bordered: Boolean,
      interactive: Boolean
    },
    provide: function provide() {
      return { mdcList: this };
    },

    computed: {
      classes: function classes() {
        return {
          'mdc-list--dense': this.dense,
          'mdc-list--avatar-list': this.avatarList,
          'mdc-list--two-line': this.twoLine,
          'mdc-list--bordered': this.bordered,
          'mdc-list--non-interactive': !this.interactive
        };
      }
    }
  };

  var mdcListItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined } }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail")], 2) : _vm._e(), _vm._v(" "), _vm.hasSecondary ? _c('span', { staticClass: "mdc-list-item__text" }, [_vm._t("default"), _vm._v(" "), _c('span', { staticClass: "mdc-list-item__secondary-text" }, [_vm._t("secondary")], 2)], 2) : _vm._t("default"), _vm._v(" "), _vm.hasEndDetail ? _c('span', { staticClass: "mdc-list-item__meta" }, [_vm._t("end-detail")], 2) : _vm._e()], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-item',
    inject: ['mdcList'],
    props: {
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--selected': this.selected,
          'mdc-list-item--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcList && this.mdcList.interactive;
      },
      hasSecondary: function hasSecondary() {
        return this.$slots['secondary'] && this.mdcList && this.mdcList.twoLine;
      },
      hasEndDetail: function hasEndDetail() {
        return !!this.$slots['end-detail'];
      },
      hasStartDetail: function hasStartDetail() {
        return !!this.$slots['start-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },

    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }
  };

  var mdcListDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-list-divider", class: _vm.classes, attrs: { "role": "separator" } });
    }, staticRenderFns: [],
    name: 'mdc-list-divider',
    props: {
      inset: Boolean,
      padded: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-list-divider--inset': this.inset,
          'mdc-list-divider--padded': this.padded
        };
      }
    }
  };

  var mdcListGroup = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-list-group" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-group'
  };

  var mdcListGroupHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h3', { staticClass: "mdc-list-group-header mdc-list-group__subheader" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-group-header'
  };

  var mdcListGroupDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-group-divider mdc-list-divider" });
    }, staticRenderFns: [],
    name: 'mdc-list-group-divider'
  };

  var VueMDCList = BasePlugin({
    mdcList: mdcList,
    mdcListItem: mdcListItem,
    mdcListDivider: mdcListDivider,
    mdcListGroup: mdcListGroup,
    mdcListGroupHeader: mdcListGroupHeader,
    mdcListGroupDivider: mdcListGroupDivider
  });

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Menu. Provides an interface for managing
   * - classes
   * - dom
   * - focus
   * - position
   * - dimensions
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCMenuAdapter = function () {
    function MDCMenuAdapter() {
      classCallCheck(this, MDCMenuAdapter);
    }

    createClass(MDCMenuAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /** @return {boolean} */

    }, {
      key: "hasNecessaryDom",
      value: function hasNecessaryDom() {}

      /**
       * @param {EventTarget} target
       * @param {string} attributeName
       * @return {string}
       */

    }, {
      key: "getAttributeForEventTarget",
      value: function getAttributeForEventTarget(target, attributeName) {}

      /** @return {{ width: number, height: number }} */

    }, {
      key: "getInnerDimensions",
      value: function getInnerDimensions() {}

      /** @return {boolean} */

    }, {
      key: "hasAnchor",
      value: function hasAnchor() {}

      /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

    }, {
      key: "getAnchorDimensions",
      value: function getAnchorDimensions() {}

      /** @return {{ width: number, height: number }} */

    }, {
      key: "getWindowDimensions",
      value: function getWindowDimensions() {}

      /** @return {number} */

    }, {
      key: "getNumberOfItems",
      value: function getNumberOfItems() {}

      /**
       * @param {string} type
       * @param {function(!Event)} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {function(!Event)} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerBodyClickHandler",
      value: function registerBodyClickHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterBodyClickHandler",
      value: function deregisterBodyClickHandler(handler) {}

      /**
       * @param {EventTarget} target
       * @return {number}
       */

    }, {
      key: "getIndexForEventTarget",
      value: function getIndexForEventTarget(target) {}

      /** @param {{index: number}} evtData */

    }, {
      key: "notifySelected",
      value: function notifySelected(evtData) {}
    }, {
      key: "notifyCancel",
      value: function notifyCancel() {}
    }, {
      key: "saveFocus",
      value: function saveFocus() {}
    }, {
      key: "restoreFocus",
      value: function restoreFocus() {}

      /** @return {boolean} */

    }, {
      key: "isFocused",
      value: function isFocused() {}
    }, {
      key: "focus",
      value: function focus() {}

      /** @return {number} */

    }, {
      key: "getFocusedItemIndex",
      value: function getFocusedItemIndex() /* number */{}

      /** @param {number} index */

    }, {
      key: "focusItemAtIndex",
      value: function focusItemAtIndex(index) {}

      /** @return {boolean} */

    }, {
      key: "isRtl",
      value: function isRtl() {}

      /** @param {string} origin */

    }, {
      key: "setTransformOrigin",
      value: function setTransformOrigin(origin) {}

      /** @param {{
      *   top: (string|undefined),
      *   right: (string|undefined),
      *   bottom: (string|undefined),
      *   left: (string|undefined)
      * }} position */

    }, {
      key: "setPosition",
      value: function setPosition(position) {}

      /** @param {string} height */

    }, {
      key: "setMaxHeight",
      value: function setMaxHeight(height) {}

      /**
       * @param {number} index
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttrForOptionAtIndex",
      value: function setAttrForOptionAtIndex(index, attr, value) {}

      /**
       * @param {number} index
       * @param {string} attr
       */

    }, {
      key: "rmAttrForOptionAtIndex",
      value: function rmAttrForOptionAtIndex(index, attr) {}

      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "addClassForOptionAtIndex",
      value: function addClassForOptionAtIndex(index, className) {}

      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "rmClassForOptionAtIndex",
      value: function rmClassForOptionAtIndex(index, className) {}
    }]);
    return MDCMenuAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$10 = {
    ROOT: 'mdc-menu',
    OPEN: 'mdc-menu--open',
    ANIMATING_OPEN: 'mdc-menu--animating-open',
    ANIMATING_CLOSED: 'mdc-menu--animating-closed',
    SELECTED_LIST_ITEM: 'mdc-list-item--selected'
  };

  /** @enum {string} */
  var strings$11 = {
    ITEMS_SELECTOR: '.mdc-menu__items',
    SELECTED_EVENT: 'MDCMenu:selected',
    CANCEL_EVENT: 'MDCMenu:cancel',
    ARIA_DISABLED_ATTR: 'aria-disabled'
  };

  /** @enum {number} */
  var numbers$2 = {
    // Amount of time to wait before triggering a selected event on the menu. Note that this time
    // will most likely be bumped up once interactive lists are supported to allow for the ripple to
    // animate before closing the menu
    SELECTED_TRIGGER_DELAY: 50,
    // Total duration of menu open animation.
    TRANSITION_OPEN_DURATION: 120,
    // Total duration of menu close animation.
    TRANSITION_CLOSE_DURATION: 75,
    // Margin left to the edge of the viewport when menu is at maximum possible height.
    MARGIN_TO_EDGE: 32,
    // Ratio of anchor width to menu width for switching from corner positioning to center positioning.
    ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,
    // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.
    OFFSET_TO_MENU_HEIGHT_RATIO: 0.1
  };

  /**
   * Enum for bits in the {@see Corner) bitmap.
   * @enum {number}
   */
  var CornerBit = {
    BOTTOM: 1,
    CENTER: 2,
    RIGHT: 4,
    FLIP_RTL: 8
  };

  /**
   * Enum for representing an element corner for positioning the menu.
   *
   * The START constants map to LEFT if element directionality is left
   * to right and RIGHT if the directionality is right to left.
   * Likewise END maps to RIGHT or LEFT depending on the directionality.
   *
   * @enum {number}
   */
  var Corner = {
    TOP_LEFT: 0,
    TOP_RIGHT: CornerBit.RIGHT,
    BOTTOM_LEFT: CornerBit.BOTTOM,
    BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
    TOP_START: CornerBit.FLIP_RTL,
    TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
    BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
    BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCMenuAdapter>}
   */

  var MDCMenuFoundation = function (_MDCFoundation) {
    inherits(MDCMenuFoundation, _MDCFoundation);
    createClass(MDCMenuFoundation, null, [{
      key: 'cssClasses',

      /** @return enum{cssClasses} */
      get: function get$$1() {
        return cssClasses$10;
      }

      /** @return enum{strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$11;
      }

      /** @return enum{numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$2;
      }

      /** @return enum{number} */

    }, {
      key: 'Corner',
      get: function get$$1() {
        return Corner;
      }

      /**
       * {@see MDCMenuAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCMenuAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCMenuAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {
              return false;
            },
            hasNecessaryDom: function hasNecessaryDom() {
              return false;
            },
            getAttributeForEventTarget: function getAttributeForEventTarget() {},
            getInnerDimensions: function getInnerDimensions() {
              return {};
            },
            hasAnchor: function hasAnchor() {
              return false;
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return {};
            },
            getWindowDimensions: function getWindowDimensions() {
              return {};
            },
            getNumberOfItems: function getNumberOfItems() {
              return 0;
            },
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            registerBodyClickHandler: function registerBodyClickHandler() {},
            deregisterBodyClickHandler: function deregisterBodyClickHandler() {},
            getIndexForEventTarget: function getIndexForEventTarget() {
              return 0;
            },
            notifySelected: function notifySelected() {},
            notifyCancel: function notifyCancel() {},
            saveFocus: function saveFocus() {},
            restoreFocus: function restoreFocus() {},
            isFocused: function isFocused() {
              return false;
            },
            focus: function focus() {},
            getFocusedItemIndex: function getFocusedItemIndex() {
              return -1;
            },
            focusItemAtIndex: function focusItemAtIndex() {},
            isRtl: function isRtl() {
              return false;
            },
            setTransformOrigin: function setTransformOrigin() {},
            setPosition: function setPosition() {},
            setMaxHeight: function setMaxHeight() {},
            setAttrForOptionAtIndex: function setAttrForOptionAtIndex() {},
            rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() {},
            addClassForOptionAtIndex: function addClassForOptionAtIndex() {},
            rmClassForOptionAtIndex: function rmClassForOptionAtIndex() {}
          }
        );
      }

      /** @param {!MDCMenuAdapter} adapter */

    }]);

    function MDCMenuFoundation(adapter) {
      classCallCheck(this, MDCMenuFoundation);

      /** @private {function(!Event)} */
      var _this = possibleConstructorReturn(this, (MDCMenuFoundation.__proto__ || Object.getPrototypeOf(MDCMenuFoundation)).call(this, _extends(MDCMenuFoundation.defaultAdapter, adapter)));

      _this.clickHandler_ = function (evt) {
        return _this.handlePossibleSelected_(evt);
      };
      /** @private {function(!Event)} */
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeyboardDown_(evt);
      };
      /** @private {function(!Event)} */
      _this.keyupHandler_ = function (evt) {
        return _this.handleKeyboardUp_(evt);
      };
      /** @private {function(!Event)} */
      _this.documentClickHandler_ = function (evt) {
        return _this.handleDocumentClick_(evt);
      };
      /** @private {boolean} */
      _this.isOpen_ = false;
      /** @private {number} */
      _this.openAnimationEndTimerId_ = 0;
      /** @private {number} */
      _this.closeAnimationEndTimerId_ = 0;
      /** @private {number} */
      _this.selectedTriggerTimerId_ = 0;
      /** @private {number} */
      _this.animationRequestId_ = 0;
      /** @private {!{ width: number, height: number }} */
      _this.dimensions_;
      /** @private {number} */
      _this.itemHeight_;
      /** @private {Corner} */
      _this.anchorCorner_ = Corner.TOP_START;
      /** @private {AnchorMargin} */
      _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
      /** @private {?AutoLayoutMeasurements} */
      _this.measures_ = null;
      /** @private {number} */
      _this.selectedIndex_ = -1;
      /** @private {boolean} */
      _this.rememberSelection_ = false;
      /** @private {boolean} */
      _this.quickOpen_ = false;

      // A keyup event on the menu needs to have a corresponding keydown
      // event on the menu. If the user opens the menu with a keydown event on a
      // button, the menu will only get the key up event causing buggy behavior with selected elements.
      /** @private {boolean} */
      _this.keyDownWithinMenu_ = false;
      return _this;
    }

    createClass(MDCMenuFoundation, [{
      key: 'init',
      value: function init() {
        var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses,
            ROOT = _MDCMenuFoundation$cs.ROOT,
            OPEN = _MDCMenuFoundation$cs.OPEN;


        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        }

        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        clearTimeout(this.selectedTriggerTimerId_);
        clearTimeout(this.openAnimationEndTimerId_);
        clearTimeout(this.closeAnimationEndTimerId_);
        // Cancel any currently running animations.
        cancelAnimationFrame(this.animationRequestId_);
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);
      }

      /**
       * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.
       */

    }, {
      key: 'setAnchorCorner',
      value: function setAnchorCorner(corner) {
        this.anchorCorner_ = corner;
      }

      /**
       * @param {!AnchorMargin} margin 4-plet of margins from anchor.
       */

    }, {
      key: 'setAnchorMargin',
      value: function setAnchorMargin(margin) {
        this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
        this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
        this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
        this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
      }

      /** @param {boolean} rememberSelection */

    }, {
      key: 'setRememberSelection',
      value: function setRememberSelection(rememberSelection) {
        this.rememberSelection_ = rememberSelection;
        this.setSelectedIndex(-1);
      }

      /** @param {boolean} quickOpen */

    }, {
      key: 'setQuickOpen',
      value: function setQuickOpen(quickOpen) {
        this.quickOpen_ = quickOpen;
      }

      /**
       * @param {?number} focusIndex
       * @private
       */

    }, {
      key: 'focusOnOpen_',
      value: function focusOnOpen_(focusIndex) {
        if (focusIndex === null) {
          // If this instance of MDCMenu remembers selections, and the user has
          // made a selection, then focus the last selected item
          if (this.rememberSelection_ && this.selectedIndex_ >= 0) {
            this.adapter_.focusItemAtIndex(this.selectedIndex_);
            return;
          }

          this.adapter_.focus();
          // If that doesn't work, focus first item instead.
          if (!this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(0);
          }
        } else {
          this.adapter_.focusItemAtIndex(focusIndex);
        }
      }

      /**
       * Handle clicks and cancel the menu if not a child list-item
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDocumentClick_',
      value: function handleDocumentClick_(evt) {
        var el = evt.target;

        while (el && el !== document.documentElement) {
          if (this.adapter_.getIndexForEventTarget(el) !== -1) {
            return;
          }
          el = el.parentNode;
        }

        this.adapter_.notifyCancel();
        this.close(evt);
      }
    }, {
      key: 'handleKeyboardDown_',


      /**
       * Handle keys that we want to repeat on hold (tab and arrows).
       * @param {!Event} evt
       * @return {boolean}
       * @private
       */
      value: function handleKeyboardDown_(evt) {
        // Do nothing if Alt, Ctrl or Meta are pressed.
        if (evt.altKey || evt.ctrlKey || evt.metaKey) {
          return true;
        }

        var keyCode = evt.keyCode,
            key = evt.key,
            shiftKey = evt.shiftKey;

        var isTab = key === 'Tab' || keyCode === 9;
        var isArrowUp = key === 'ArrowUp' || keyCode === 38;
        var isArrowDown = key === 'ArrowDown' || keyCode === 40;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEnter = key === 'Enter' || keyCode === 13;
        // The menu needs to know if the keydown event was triggered on the menu
        this.keyDownWithinMenu_ = isEnter || isSpace;

        var focusedItemIndex = this.adapter_.getFocusedItemIndex();
        var lastItemIndex = this.adapter_.getNumberOfItems() - 1;

        if (shiftKey && isTab && focusedItemIndex === 0) {
          this.adapter_.focusItemAtIndex(lastItemIndex);
          evt.preventDefault();
          return false;
        }

        if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {
          this.adapter_.focusItemAtIndex(0);
          evt.preventDefault();
          return false;
        }

        // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling
        if (isArrowUp || isArrowDown || isSpace) {
          evt.preventDefault();
        }

        if (isArrowUp) {
          if (focusedItemIndex === 0 || this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(lastItemIndex);
          } else {
            this.adapter_.focusItemAtIndex(focusedItemIndex - 1);
          }
        } else if (isArrowDown) {
          if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(0);
          } else {
            this.adapter_.focusItemAtIndex(focusedItemIndex + 1);
          }
        }

        return true;
      }

      /**
       * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).
       * @param {!Event} evt
       * @return {boolean}
       * @private
       */

    }, {
      key: 'handleKeyboardUp_',
      value: function handleKeyboardUp_(evt) {
        // Do nothing if Alt, Ctrl or Meta are pressed.
        if (evt.altKey || evt.ctrlKey || evt.metaKey) {
          return true;
        }

        var keyCode = evt.keyCode,
            key = evt.key;

        var isEnter = key === 'Enter' || keyCode === 13;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEscape = key === 'Escape' || keyCode === 27;

        if (isEnter || isSpace) {
          // If the keydown event didn't occur on the menu, then it should
          // disregard the possible selected event.
          if (this.keyDownWithinMenu_) {
            this.handlePossibleSelected_(evt);
          }
          this.keyDownWithinMenu_ = false;
        }

        if (isEscape) {
          this.adapter_.notifyCancel();
          this.close();
        }

        return true;
      }

      /**
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handlePossibleSelected_',
      value: function handlePossibleSelected_(evt) {
        var _this2 = this;

        if (this.adapter_.getAttributeForEventTarget(evt.target, strings$11.ARIA_DISABLED_ATTR) === 'true') {
          return;
        }
        var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);
        if (targetIndex < 0) {
          return;
        }
        // Debounce multiple selections
        if (this.selectedTriggerTimerId_) {
          return;
        }
        this.selectedTriggerTimerId_ = setTimeout(function () {
          _this2.selectedTriggerTimerId_ = 0;
          _this2.close();
          if (_this2.rememberSelection_) {
            _this2.setSelectedIndex(targetIndex);
          }
          _this2.adapter_.notifySelected({ index: targetIndex });
        }, numbers$2.SELECTED_TRIGGER_DELAY);
      }

      /**
       * @return {AutoLayoutMeasurements} Measurements used to position menu popup.
       */

    }, {
      key: 'getAutoLayoutMeasurements_',
      value: function getAutoLayoutMeasurements_() {
        var anchorRect = this.adapter_.getAnchorDimensions();
        var viewport = this.adapter_.getWindowDimensions();

        return {
          viewport: viewport,
          viewportDistance: {
            top: anchorRect.top,
            right: viewport.width - anchorRect.right,
            left: anchorRect.left,
            bottom: viewport.height - anchorRect.bottom
          },
          anchorHeight: anchorRect.height,
          anchorWidth: anchorRect.width,
          menuHeight: this.dimensions_.height,
          menuWidth: this.dimensions_.width
        };
      }

      /**
       * Computes the corner of the anchor from which to animate and position the menu.
       * @return {Corner}
       * @private
       */

    }, {
      key: 'getOriginCorner_',
      value: function getOriginCorner_() {
        // Defaults: open from the top left.
        var corner = Corner.TOP_LEFT;

        var _measures_ = this.measures_,
            viewportDistance = _measures_.viewportDistance,
            anchorHeight = _measures_.anchorHeight,
            anchorWidth = _measures_.anchorWidth,
            menuHeight = _measures_.menuHeight,
            menuWidth = _measures_.menuWidth;

        var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
        var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;

        var topOverflow = menuHeight - availableTop;
        var bottomOverflow = menuHeight - availableBottom;
        if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
          corner |= CornerBit.BOTTOM;
        }

        var isRtl = this.adapter_.isRtl();
        var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
        var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
        var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;

        var leftOverflow = menuWidth - availableLeft;
        var rightOverflow = menuWidth - availableRight;

        if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
          corner |= CornerBit.RIGHT;
        }

        return corner;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: 'getHorizontalOriginOffset_',
      value: function getHorizontalOriginOffset_(corner) {
        var anchorWidth = this.measures_.anchorWidth;

        var isRightAligned = Boolean(corner & CornerBit.RIGHT);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var x = 0;
        if (isRightAligned) {
          var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;
          x = rightOffset;
        } else {
          var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
          x = leftOffset;
        }
        return x;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: 'getVerticalOriginOffset_',
      value: function getVerticalOriginOffset_(corner) {
        var _measures_2 = this.measures_,
            viewport = _measures_2.viewport,
            viewportDistance = _measures_2.viewportDistance,
            anchorHeight = _measures_2.anchorHeight,
            menuHeight = _measures_2.menuHeight;

        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
        var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;

        var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var canOverlapVertically = !avoidVerticalOverlap;
        var y = 0;

        if (isBottomAligned) {
          y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
          // adjust for when menu can overlap anchor, but too tall to be aligned to bottom
          // anchor corner. Bottom margin is ignored in such cases.
          if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {
            y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));
          }
        } else {
          y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
          // adjust for when menu can overlap anchor, but too tall to be aligned to top
          // anchor corners. Top margin is ignored in that case.
          if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {
            y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));
          }
        }
        return y;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.
       * @private
       */

    }, {
      key: 'getMenuMaxHeight_',
      value: function getMenuMaxHeight_(corner) {
        var maxHeight = 0;
        var viewportDistance = this.measures_.viewportDistance;

        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);

        // When maximum height is not specified, it is handled from css.
        if (this.anchorCorner_ & CornerBit.BOTTOM) {
          if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top;
          } else {
            maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;
          }
        }

        return maxHeight;
      }

      /** @private */

    }, {
      key: 'autoPosition_',
      value: function autoPosition_() {
        var _position;

        if (!this.adapter_.hasAnchor()) {
          return;
        }

        // Compute measurements for autoposition methods reuse.
        this.measures_ = this.getAutoLayoutMeasurements_();

        var corner = this.getOriginCorner_();
        var maxMenuHeight = this.getMenuMaxHeight_(corner);
        var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
        var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
        var horizontalOffset = this.getHorizontalOriginOffset_(corner);
        var verticalOffset = this.getVerticalOriginOffset_(corner);
        var position = (_position = {}, defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);
        var _measures_3 = this.measures_,
            anchorWidth = _measures_3.anchorWidth,
            menuHeight = _measures_3.menuHeight,
            menuWidth = _measures_3.menuWidth;
        // Center align when anchor width is comparable or greater than menu, otherwise keep corner.

        if (anchorWidth / menuWidth > numbers$2.ANCHOR_TO_MENU_WIDTH_RATIO) {
          horizontalAlignment = 'center';
        }

        // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that
        // scale animation is "anchored" on the anchor.
        if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers$2.OFFSET_TO_MENU_HEIGHT_RATIO) {
          var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;
          var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;
          verticalAlignment = Math.round(originPercent * 100) / 100 + '%';
        }

        this.adapter_.setTransformOrigin(horizontalAlignment + ' ' + verticalAlignment);
        this.adapter_.setPosition(position);
        this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : '');

        // Clear measures after positioning is complete.
        this.measures_ = null;
      }

      /**
       * Open the menu.
       * @param {{focusIndex: ?number}=} options
       */

    }, {
      key: 'open',
      value: function open() {
        var _this3 = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$focusIndex = _ref.focusIndex,
            focusIndex = _ref$focusIndex === undefined ? null : _ref$focusIndex;

        this.adapter_.saveFocus();

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
        }

        this.animationRequestId_ = requestAnimationFrame(function () {
          _this3.dimensions_ = _this3.adapter_.getInnerDimensions();
          _this3.autoPosition_();
          _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);
          _this3.focusOnOpen_(focusIndex);
          _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);
          if (!_this3.quickOpen_) {
            _this3.openAnimationEndTimerId_ = setTimeout(function () {
              _this3.openAnimationEndTimerId_ = 0;
              _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
            }, numbers$2.TRANSITION_OPEN_DURATION);
          }
        });
        this.isOpen_ = true;
      }

      /**
       * Closes the menu.
       * @param {Event=} evt
       */

    }, {
      key: 'close',
      value: function close() {
        var _this4 = this;

        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings$11.ARIA_DISABLED_ATTR) === 'true' : false;

        if (targetIsDisabled) {
          return;
        }

        this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
        }

        requestAnimationFrame(function () {
          _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);
          if (!_this4.quickOpen_) {
            _this4.closeAnimationEndTimerId_ = setTimeout(function () {
              _this4.closeAnimationEndTimerId_ = 0;
              _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
            }, numbers$2.TRANSITION_CLOSE_DURATION);
          }
        });
        this.isOpen_ = false;
        this.adapter_.restoreFocus();
      }

      /** @return {boolean} */

    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /** @return {number} */

    }, {
      key: 'getSelectedIndex',
      value: function getSelectedIndex() {
        return this.selectedIndex_;
      }

      /**
       * @param {number} index Index of the item to set as selected.
       */

    }, {
      key: 'setSelectedIndex',
      value: function setSelectedIndex(index) {
        if (index === this.selectedIndex_) {
          return;
        }

        var prevSelectedIndex = this.selectedIndex_;
        if (prevSelectedIndex >= 0) {
          this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');
          this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses$10.SELECTED_LIST_ITEM);
        }

        this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;
        if (this.selectedIndex_ >= 0) {
          this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
          this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses$10.SELECTED_LIST_ITEM);
        }
      }
    }]);
    return MDCMenuFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @type {string|undefined} */
  var storedTransformPropertyName_$1 = void 0;

  /**
   * Returns the name of the correct transform property to use on the current browser.
   * @param {!Window} globalObj
   * @param {boolean=} forceRefresh
   * @return {string}
   */
  function getTransformPropertyName$1(globalObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_$1 === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
      storedTransformPropertyName_$1 = transformPropertyName;
    }

    return storedTransformPropertyName_$1;
  }

  var mdcMenu = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-menu mdc-simple-menu", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "-1" } }, [_c('ul', { ref: "items", staticClass: "mdc-simple-menu__items mdc-list", attrs: { "role": "menu", "aria-hidden": "true" } }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-menu',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: [Boolean, Object],
      'quick-open': Boolean,
      'anchor-corner': [String, Number],
      'anchor-margin': Object
    },
    data: function data() {
      return {
        classes: {},
        styles: {},
        items: []
      };
    },

    watch: {
      open: 'onOpen_',
      quickOpen: function quickOpen(nv) {
        this.foundation.setQuickOpen(nv);
      },
      anchorCorner: function anchorCorner(nv) {
        this.foundation.setAnchorCorner(Number(nv));
      },
      anchorMargin: function anchorMargin(nv) {
        this.foundation.setAnchorMargin(nv);
      }
    },
    mounted: function mounted() {
      var _this = this;

      var refreshItems = function refreshItems() {
        _this.items = [].slice.call(_this.$refs.items.querySelectorAll('.mdc-list-item[role]'));
        _this.$emit('update');
      };
      this.slotObserver = new MutationObserver(function () {
        return refreshItems();
      });
      this.slotObserver.observe(this.$el, {
        childList: true,
        subtree: true
      });

      this._previousFocus = undefined;

      this.foundation = new MDCMenuFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return Boolean(_this.$refs.items);
        },
        getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
          return target.getAttribute(attributeName);
        },
        getInnerDimensions: function getInnerDimensions() {
          return {
            width: _this.$refs.items.offsetWidth,
            height: _this.$refs.items.offsetHeight
          };
        },
        hasAnchor: function hasAnchor() {
          return _this.$refs.root.parentElement && _this.$refs.root.parentElement.classList.contains('mdc-menu-anchor');
        },
        getAnchorDimensions: function getAnchorDimensions() {
          return _this.$refs.root.parentElement.getBoundingClientRect();
        },
        getWindowDimensions: function getWindowDimensions() {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        },
        getNumberOfItems: function getNumberOfItems() {
          return _this.items.length;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$refs.root.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$refs.root.removeEventListener(type, handler);
        },
        registerBodyClickHandler: function registerBodyClickHandler(handler) {
          return document.body.addEventListener('click', handler);
        },
        deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
          return document.body.removeEventListener('click', handler);
        },
        getIndexForEventTarget: function getIndexForEventTarget(target) {
          return _this.items.indexOf(target);
        },
        notifySelected: function notifySelected(evtData) {
          var evt = {
            index: evtData.index,
            item: _this.items[evtData.index]
          };
          _this.$emit('change', false);
          _this.$emit('select', evt);
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.SELECTED_EVENT, evt);
        },
        notifyCancel: function notifyCancel() {
          _this.$emit('change', false);
          _this.$emit('cancel');
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.CANCEL_EVENT, {});
        },
        saveFocus: function saveFocus() {
          _this._previousFocus = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          if (_this._previousFocus) {
            _this._previousFocus.focus();
          }
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.root;
        },
        focus: function focus() {
          return _this.$refs.root.focus();
        },
        getFocusedItemIndex: function getFocusedItemIndex() {
          return _this.items.indexOf(document.activeElement);
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          return _this.items[index].focus();
        },
        isRtl: function isRtl() {
          return getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        setTransformOrigin: function setTransformOrigin(origin) {
          _this.$set(_this.styles, getTransformPropertyName$1(window) + '-origin', origin);
        },
        setPosition: function setPosition(position) {
          _this.$set(_this.styles, 'left', position.left);
          _this.$set(_this.styles, 'right', position.right);
          _this.$set(_this.styles, 'top', position.top);
          _this.$set(_this.styles, 'bottom', position.bottom);
        },
        setMaxHeight: function setMaxHeight(height) {
          _this.$set(_this.styles, 'max-height', height);
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
          _this.items[index].setAttribute(attr, value);
        },
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
          _this.items[index].removeAttribute(attr);
        },
        addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
          _this.items[index].classList.add(className);
        },
        rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
          _this.items[index].classList.remove(className);
        }
      });

      refreshItems();
      this.foundation.init();
      if (this.anchorCorner !== void 0) {
        this.foundation.setAnchorCorner(Number(this.anchorCorner));
      }
      if (this.anchorMargin !== void 0) {
        this.foundation.setAnchorMargin(this.anchorMargin);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this._previousFocus = null;
      this.slotObserver.disconnect();
      this.foundation.destroy();
    },


    methods: {
      onOpen_: function onOpen_(value) {
        if (value) {
          this.foundation.open((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? value : void 0);
        } else {
          this.foundation.close();
        }
      },
      show: function show(options) {
        this.foundation.open(options);
      },
      hide: function hide() {
        this.foundation.close();
      },
      isOpen: function isOpen() {
        return this.foundation ? this.foundation.isOpen() : false;
      }
    }
  };

  var mdcMenuItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-item mdc-list-item", attrs: { "tabindex": _vm.disabled ? '-1' : '0', "aria-disabled": _vm.disabled, "role": "menuitem" } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-menu-item',
    props: {
      disabled: Boolean
    }
  };

  var mdcMenuDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-divider mdc-list-divider", attrs: { "role": "separator" } });
    }, staticRenderFns: [],
    name: 'mdc-menu-divider'
  };

  var mdcMenuAnchor = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-menu-anchor" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-menu-anchor'
  };

  var VueMDCMenu = BasePlugin({
    mdcMenu: mdcMenu,
    mdcMenuItem: mdcMenuItem,
    mdcMenuDivider: mdcMenuDivider,
    mdcMenuAnchor: mdcMenuAnchor
  });

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Radio. Provides an interface for managing
   * - classes
   * - dom
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCRadioAdapter = function () {
    function MDCRadioAdapter() {
      classCallCheck(this, MDCRadioAdapter);
    }

    createClass(MDCRadioAdapter, [{
      key: 'addClass',

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /** @return {!MDCSelectionControlState} */

    }, {
      key: 'getNativeControl',
      value: function getNativeControl() {}
    }]);
    return MDCRadioAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$12 = {
    NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
  };

  /** @enum {string} */
  var cssClasses$11 = {
    ROOT: 'mdc-radio',
    DISABLED: 'mdc-radio--disabled'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCRadioAdapter>}
   */

  var MDCRadioFoundation = function (_MDCFoundation) {
    inherits(MDCRadioFoundation, _MDCFoundation);

    function MDCRadioFoundation() {
      classCallCheck(this, MDCRadioFoundation);
      return possibleConstructorReturn(this, (MDCRadioFoundation.__proto__ || Object.getPrototypeOf(MDCRadioFoundation)).apply(this, arguments));
    }

    createClass(MDCRadioFoundation, [{
      key: 'isChecked',


      /** @return {boolean} */
      value: function isChecked() {
        return this.getNativeControl_().checked;
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.getNativeControl_().checked = checked;
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeControl_().disabled;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;

        this.getNativeControl_().disabled = disabled;
        if (disabled) {
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
      }

      /** @return {?string} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeControl_().value;
      }

      /** @param {?string} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeControl_().value = value;
      }

      /**
       * @return {!MDCSelectionControlState}
       * @private
       */

    }, {
      key: 'getNativeControl_',
      value: function getNativeControl_() {
        return this.adapter_.getNativeControl() || {
          checked: false,
          disabled: false,
          value: null
        };
      }
    }], [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$11;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$12;
      }

      /** @return {!MDCRadioAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCRadioAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{}
          }
        );
      }
    }]);
    return MDCRadioFoundation;
  }(MDCFoundation);

  var mdcRadio = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-radio-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-radio", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-radio__native-control", attrs: { "id": _vm.vma_uid_, "name": _vm.name, "type": "radio" }, on: { "change": _vm.sync } }), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
    }, staticRenderFns: [function () {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-radio__background" }, [_c('div', { staticClass: "mdc-radio__outer-circle" }), _vm._v(" "), _c('div', { staticClass: "mdc-radio__inner-circle" })]);
    }],
    name: 'mdc-radio',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'picked',
      event: 'change'
    },
    props: {
      name: { type: String, required: true },
      value: String,
      picked: String,
      checked: Boolean,
      label: String,
      'align-end': Boolean,
      disabled: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {},
        formFieldClasses: {
          'mdc-form-field': this.label,
          'mdc-form-field--align-end': this.label && this.alignEnd
        }
      };
    },

    watch: {
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      // add foundation
      this.foundation = new MDCRadioFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        getNativeControl: function getNativeControl() {
          return _this.$refs.control;
        }
      });

      // add ripple
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return false;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler, applyPassive());
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });

      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });

      this.foundation.init();
      this.ripple.init();
      this.formField.init();

      this.foundation.setValue(this.value ? this.value : this.label);
      this.foundation.setDisabled(this.disabled);
      this.foundation.setChecked(this.checked || this.picked == this.foundation.getValue());

      // refresh model
      this.checked && this.sync();
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      isChecked: function isChecked() {
        return this.foundation.isChecked();
      },
      sync: function sync() {
        this.$emit('change', this.foundation.getValue());
      }
    }
  };

  var VueMDCRadio = BasePlugin({
    mdcRadio: mdcRadio
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$12 = {
    BOX: 'mdc-select--box',
    DISABLED: 'mdc-select--disabled',
    ROOT: 'mdc-select'
  };

  var strings$13 = {
    CHANGE_EVENT: 'MDCSelect:change',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    LABEL_SELECTOR: '.mdc-floating-label',
    NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSelectFoundation = function (_MDCFoundation) {
    inherits(MDCSelectFoundation, _MDCFoundation);
    createClass(MDCSelectFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$12;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$13;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          floatLabel: function floatLabel() /* value: boolean */{},
          activateBottomLine: function activateBottomLine() {},
          deactivateBottomLine: function deactivateBottomLine() {},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          getSelectedIndex: function getSelectedIndex() {
            return (/* number */-1
            );
          },
          setSelectedIndex: function setSelectedIndex() /* index: number */{},
          setDisabled: function setDisabled() /* disabled: boolean */{},
          getValue: function getValue() {
            return (/* string */''
            );
          },
          setValue: function setValue() /* value: string */{}
        };
      }
    }]);

    function MDCSelectFoundation(adapter) {
      classCallCheck(this, MDCSelectFoundation);

      var _this = possibleConstructorReturn(this, (MDCSelectFoundation.__proto__ || Object.getPrototypeOf(MDCSelectFoundation)).call(this, _extends(MDCSelectFoundation.defaultAdapter, adapter)));

      _this.focusHandler_ = function (evt) {
        return _this.handleFocus_(evt);
      };
      _this.blurHandler_ = function (evt) {
        return _this.handleBlur_(evt);
      };
      _this.selectionHandler_ = function (evt) {
        return _this.handleSelect_(evt);
      };
      return _this;
    }

    createClass(MDCSelectFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        this.adapter_.registerInteractionHandler('change', this.selectionHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        this.adapter_.deregisterInteractionHandler('change', this.selectionHandler_);
      }
    }, {
      key: 'setSelectedIndex',
      value: function setSelectedIndex(index) {
        this.adapter_.setSelectedIndex(index);
        this.floatLabelWithValue_();
      }
    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.adapter_.setValue(value);
        this.setSelectedIndex(this.adapter_.getSelectedIndex());
      }
    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        var DISABLED = MDCSelectFoundation.cssClasses.DISABLED;

        this.adapter_.setDisabled(disabled);
        if (disabled) {
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
      }
    }, {
      key: 'floatLabelWithValue_',
      value: function floatLabelWithValue_() {
        var optionHasValue = this.adapter_.getValue().length > 0;
        this.adapter_.floatLabel(optionHasValue);
      }
    }, {
      key: 'handleFocus_',
      value: function handleFocus_() {
        this.adapter_.floatLabel(true);
        this.adapter_.activateBottomLine();
      }
    }, {
      key: 'handleBlur_',
      value: function handleBlur_() {
        this.floatLabelWithValue_();
        this.adapter_.deactivateBottomLine();
      }
    }, {
      key: 'handleSelect_',
      value: function handleSelect_() {
        this.setSelectedIndex(this.adapter_.getSelectedIndex());
      }
    }]);
    return MDCSelectFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC TextField Line Ripple.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the line ripple into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCLineRippleAdapter = function () {
    function MDCLineRippleAdapter() {
      classCallCheck(this, MDCLineRippleAdapter);
    }

    createClass(MDCLineRippleAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the line ripple element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the line ripple element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets the style property with propertyName to value on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(propertyName, value) {}

      /**
       * Registers an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}
    }]);
    return MDCLineRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$13 = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCLineRippleAdapter>}
   * @final
   */

  var MDCLineRippleFoundation = function (_MDCFoundation) {
    inherits(MDCLineRippleFoundation, _MDCFoundation);
    createClass(MDCLineRippleFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$13;
      }

      /**
       * {@see MDCLineRippleAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCLineRippleAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCLineRippleAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setStyle: function setStyle() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {}
          }
        );
      }

      /**
       * @param {!MDCLineRippleAdapter=} adapter
       */

    }]);

    function MDCLineRippleFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /** @type {!MDCLineRippleAdapter} */{};
      classCallCheck(this, MDCLineRippleFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, _extends(MDCLineRippleFoundation.defaultAdapter, adapter)));

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd(evt);
      };
      return _this;
    }

    createClass(MDCLineRippleFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
      }

      /**
       * Activates the line ripple
       */

    }, {
      key: 'activate',
      value: function activate() {
        this.adapter_.removeClass(cssClasses$13.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(cssClasses$13.LINE_RIPPLE_ACTIVE);
      }

      /**
       * Sets the center of the ripple animation to the given X coordinate.
       * @param {number} xCoordinate
       */

    }, {
      key: 'setRippleCenter',
      value: function setRippleCenter(xCoordinate) {
        this.adapter_.setStyle('transform-origin', xCoordinate + 'px center');
      }

      /**
       * Deactivates the line ripple
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.adapter_.addClass(cssClasses$13.LINE_RIPPLE_DEACTIVATING);
      }

      /**
       * Handles a transition end event
       * @param {!Event} evt
       */

    }, {
      key: 'handleTransitionEnd',
      value: function handleTransitionEnd(evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(cssClasses$13.LINE_RIPPLE_DEACTIVATING);

        if (evt.propertyName === 'opacity') {
          if (isDeactivating) {
            this.adapter_.removeClass(cssClasses$13.LINE_RIPPLE_ACTIVE);
            this.adapter_.removeClass(cssClasses$13.LINE_RIPPLE_DEACTIVATING);
          }
        }
      }
    }]);
    return MDCLineRippleFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Floating Label.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the floating label into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCFloatingLabelAdapter = function () {
    function MDCFloatingLabelAdapter() {
      classCallCheck(this, MDCFloatingLabelAdapter);
    }

    createClass(MDCFloatingLabelAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the label element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the label element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {}

      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
    }]);
    return MDCFloatingLabelAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$14 = {
    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
    LABEL_SHAKE: 'mdc-floating-label--shake'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
   * @final
   */

  var MDCFloatingLabelFoundation = function (_MDCFoundation) {
    inherits(MDCFloatingLabelFoundation, _MDCFoundation);
    createClass(MDCFloatingLabelFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$14;
      }

      /**
       * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCFloatingLabelAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCFloatingLabelAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            getWidth: function getWidth() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {}
          }
        );
      }

      /**
       * @param {!MDCFloatingLabelAdapter} adapter
       */

    }]);

    function MDCFloatingLabelFoundation(adapter) {
      classCallCheck(this, MDCFloatingLabelFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCFloatingLabelFoundation.__proto__ || Object.getPrototypeOf(MDCFloatingLabelFoundation)).call(this, _extends(MDCFloatingLabelFoundation.defaultAdapter, adapter)));

      _this.shakeAnimationEndHandler_ = function () {
        return _this.handleShakeAnimationEnd_();
      };
      return _this;
    }

    createClass(MDCFloatingLabelFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }

      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: 'getWidth',
      value: function getWidth() {
        return this.adapter_.getWidth();
      }

      /**
       * Styles the label to produce the label shake for errors.
       * @param {boolean} shouldShake adds shake class if true,
       * otherwise removes shake class.
       */

    }, {
      key: 'shake',
      value: function shake(shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        if (shouldShake) {
          this.adapter_.addClass(LABEL_SHAKE);
        } else {
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }

      /**
       * Styles the label to float or dock.
       * @param {boolean} shouldFloat adds float class if true, otherwise remove
       * float and shake class to dock label.
       */

    }, {
      key: 'float',
      value: function float(shouldFloat) {
        var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
            LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
            LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

        if (shouldFloat) {
          this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        } else {
          this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }

      /**
       * Handles an interaction event on the root element.
       */

    }, {
      key: 'handleShakeAnimationEnd_',
      value: function handleShakeAnimationEnd_() {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        this.adapter_.removeClass(LABEL_SHAKE);
      }
    }]);
    return MDCFloatingLabelFoundation;
  }(MDCFoundation);

  var mdcSelect = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-select", class: _vm.rootClasses, style: _vm.styles, attrs: { "id": _vm.id } }, [_c('select', _vm._g(_vm._b({ ref: "native_control", staticClass: "mdc-select__native-control" }, 'select', _vm.$attrs, false), _vm.listeners), [!!_vm.label ? _c('option', { staticClass: "mdc-option", attrs: { "value": "", "disabled": "disabled", "selected": "selected" } }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2), _vm._v(" "), _c('div', { ref: "label", staticClass: "mdc-floating-label", class: _vm.labelClasses }, [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('div', { ref: "line", staticClass: "mdc-line-ripple", class: _vm.lineClasses, style: _vm.lineStyles })]);
    }, staticRenderFns: [],
    name: 'mdc-select',
    inheritAttrs: false,
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: String,
      disabled: Boolean,
      label: String,
      box: Boolean,
      id: { type: String }
    },
    data: function data() {
      return {
        styles: {},
        labelClasses: {},
        lineClasses: {},
        lineStyles: {},
        classes: {}
      };
    },

    computed: {
      rootClasses: function rootClasses() {
        return _extends({
          'mdc-select--box': this.box
        }, this.classes);
      },
      listeners: function listeners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          change: function change(event) {
            return _this.$emit('change', event.target.value);
          }
        });
      }
    },
    watch: {
      disabled: function disabled(value) {
        this.foundation && this.foundation.setDisabled(value);
      },

      value: 'refreshIndex'
    },
    mounted: function mounted() {
      var _this2 = this;

      this.labelFoundation = new MDCFloatingLabelFoundation({
        addClass: function addClass(className) {
          _this2.$set(_this2.labelClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this2.$delete(_this2.labelClasses, className);
        },
        getWidth: function getWidth() {
          return _this2.$refs.label.offsetWidth;
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this2.$refs.label.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this2.$refs.label.removeEventListener(evtType, handler);
        }
      });
      this.labelFoundation.init();

      this.lineRippleFoundation = new MDCLineRippleFoundation({
        addClass: function addClass(className) {
          _this2.$set(_this2.lineClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this2.$delete(_this2.lineClasses, className);
        },
        hasClass: function hasClass(className) {
          _this2.$refs.line.classList.contains(className);
        },
        setStyle: function setStyle(name, value) {
          _this2.$set(_this2.lineStyles, name, value);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          _this2.$refs.line.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          _this2.$refs.line.removeEventListener(evtType, handler);
        }
      });
      this.lineRippleFoundation.init();

      this.foundation = new MDCSelectFoundation({
        addClass: function addClass(className) {
          return _this2.$set(_this2.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this2.$delete(_this2.classes, className);
        },
        floatLabel: function floatLabel(value) {
          _this2.labelFoundation.float(value);
        },
        activateBottomLine: function activateBottomLine() {
          _this2.lineRippleFoundation.activate();
        },
        deactivateBottomLine: function deactivateBottomLine() {
          _this2.lineRippleFoundation.deactivate();
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this2.$refs.native_control.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this2.$refs.native_control.removeEventListener(type, handler);
        },
        getSelectedIndex: function getSelectedIndex() {
          return _this2.$refs.native_control.selectedIndex;
        },
        setSelectedIndex: function setSelectedIndex(index) {
          return _this2.$refs.native_control.selectedIndex = index;
        },
        setDisabled: function setDisabled(disabled) {
          return _this2.$refs.native_control.disabled = disabled;
        },
        getValue: function getValue() {
          return _this2.$refs.native_control.value;
        },
        setValue: function setValue(value) {
          return _this2.$refs.native_control.value = value;
        }
      });

      this.foundation.init();

      this.foundation.setDisabled(this.disabled);

      // initial sync with DOM
      this.refreshIndex();
      this.slotObserver = new MutationObserver(function () {
        return _this2.refreshIndex();
      });
      this.slotObserver.observe(this.$refs.native_control, {
        childList: true,
        subtree: true
      });

      if (this.box) {
        this.ripple = new RippleBase(this);
        this.ripple.init();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();

      var labelFoundation = this.labelFoundation;
      this.labelFoundation = null;
      labelFoundation.destroy();

      var lineRippleFoundation = this.lineRippleFoundation;
      this.lineRippleFoundation = null;
      lineRippleFoundation.destroy();

      this.ripple && this.ripple.destroy();
    },

    methods: {
      refreshIndex: function refreshIndex() {
        var _this3 = this;

        var options = [].concat(toConsumableArray(this.$refs.native_control.querySelectorAll('option')));

        var idx = options.findIndex(function (_ref) {
          var value = _ref.value;

          return _this3.value === value;
        });

        if (this.$refs.native_control.selectedIndex !== idx) {
          this.foundation.setSelectedIndex(idx);
        }
      }
    }
  };

  var VueMDCSelect = BasePlugin({
    mdcSelect: mdcSelect
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$15 = {
    ACTIVE: 'mdc-slider--active',
    DISABLED: 'mdc-slider--disabled',
    DISCRETE: 'mdc-slider--discrete',
    FOCUS: 'mdc-slider--focus',
    IN_TRANSIT: 'mdc-slider--in-transit',
    IS_DISCRETE: 'mdc-slider--discrete',
    HAS_TRACK_MARKER: 'mdc-slider--display-markers'
  };

  /** @enum {string} */
  var strings$14 = {
    TRACK_SELECTOR: '.mdc-slider__track',
    TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
    LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
    THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
    PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
    ARIA_VALUEMIN: 'aria-valuemin',
    ARIA_VALUEMAX: 'aria-valuemax',
    ARIA_VALUENOW: 'aria-valuenow',
    ARIA_DISABLED: 'aria-disabled',
    STEP_DATA_ATTR: 'data-step',
    CHANGE_EVENT: 'MDCSlider:change',
    INPUT_EVENT: 'MDCSlider:input'
  };

  /** @enum {number} */
  var numbers$3 = {
    PAGE_FACTOR: 4
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint-disable no-unused-vars */

  /**
   * Adapter for MDC Slider.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Slider into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSliderAdapter = function () {
    function MDCSliderAdapter() {
      classCallCheck(this, MDCSliderAdapter);
    }

    createClass(MDCSliderAdapter, [{
      key: "hasClass",

      /**
       * Returns true if className exists for the slider Element
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Adds a class to the slider Element
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /**
       * Removes a class from the slider Element
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns a string if attribute name exists on the slider Element,
       * otherwise returns null
       * @param {string} name
       * @return {?string}
       */

    }, {
      key: "getAttribute",
      value: function getAttribute(name) {}

      /**
       * Sets attribute name on slider Element to value
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttribute",
      value: function setAttribute(name, value) {}

      /**
       * Removes attribute name from slider Element
       * @param {string} name
       */

    }, {
      key: "removeAttribute",
      value: function removeAttribute(name) {}

      /**
       * Returns the bounding client rect for the slider Element
       * @return {?ClientRect}
       */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /**
       * Returns the tab index of the slider Element
       * @return {number}
       */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerThumbContainerInteractionHandler",
      value: function registerThumbContainerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterThumbContainerInteractionHandler",
      value: function deregisterThumbContainerInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerBodyInteractionHandler",
      value: function registerBodyInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterBodyInteractionHandler",
      value: function deregisterBodyInteractionHandler(type, handler) {}

      /**
       * Registers an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * Deregisters an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * Emits a custom event MDCSlider:input from the root
       */

    }, {
      key: "notifyInput",
      value: function notifyInput() {}

      /**
       * Emits a custom event MDCSlider:change from the root
       */

    }, {
      key: "notifyChange",
      value: function notifyChange() {}

      /**
       * Sets a style property of the thumb container element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setThumbContainerStyleProperty",
      value: function setThumbContainerStyleProperty(propertyName, value) {}

      /**
       * Sets a style property of the track element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setTrackStyleProperty",
      value: function setTrackStyleProperty(propertyName, value) {}

      /**
       * Sets the inner text of the pin marker to the passed value
       * @param {number} value
       */

    }, {
      key: "setMarkerValue",
      value: function setMarkerValue(value) {}

      /**
       * Appends the passed number of track markers to the track mark container element
       * @param {number} numMarkers
       */

    }, {
      key: "appendTrackMarkers",
      value: function appendTrackMarkers(numMarkers) {}

      /**
       * Removes all track markers fromt he track mark container element
       */

    }, {
      key: "removeTrackMarkers",
      value: function removeTrackMarkers() {}

      /**
       * Sets a style property of the last track marker to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setLastTrackMarkersStyleProperty",
      value: function setLastTrackMarkersStyleProperty(propertyName, value) {}

      /**
       * Returns true if the root element is RTL, otherwise false
       * @return {boolean}
       */

    }, {
      key: "isRTL",
      value: function isRTL() {}
    }]);
    return MDCSliderAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   *you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var KEY_IDS = {
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    ARROW_DOWN: 'ArrowDown',
    HOME: 'Home',
    END: 'End',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown'
  };

  /** @enum {string} */
  var MOVE_EVENT_MAP = {
    'mousedown': 'mousemove',
    'touchstart': 'touchmove',
    'pointerdown': 'pointermove'
  };

  var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
  var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];

  /**
   * @extends {MDCFoundation<!MDCSliderAdapter>}
   */

  var MDCSliderFoundation = function (_MDCFoundation) {
    inherits(MDCSliderFoundation, _MDCFoundation);
    createClass(MDCSliderFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$15;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$14;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$3;
      }

      /** @return {!MDCSliderAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSliderAdapter} */{
            hasClass: function hasClass() {
              return (/* className: string */ /* boolean */false
              );
            },
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getAttribute: function getAttribute() {
              return (/* name: string */ /* string|null */null
              );
            },
            setAttribute: function setAttribute() /* name: string, value: string */{},
            removeAttribute: function removeAttribute() /* name: string */{},
            computeBoundingRect: function computeBoundingRect() {
              return (/* ClientRect */{
                  top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0
                }
              );
            },
            getTabIndex: function getTabIndex() {
              return (/* number */0
              );
            },
            registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            registerBodyInteractionHandler: function registerBodyInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler() /* type: string, handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            notifyInput: function notifyInput() {},
            notifyChange: function notifyChange() {},
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty() /* propertyName: string, value: string */{},
            setTrackStyleProperty: function setTrackStyleProperty() /* propertyName: string, value: string */{},
            setMarkerValue: function setMarkerValue() /* value: number */{},
            appendTrackMarkers: function appendTrackMarkers() /* numMarkers: number */{},
            removeTrackMarkers: function removeTrackMarkers() {},
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty() /* propertyName: string, value: string */{},
            isRTL: function isRTL() {
              return (/* boolean */false
              );
            }
          }
        );
      }

      /**
       * Creates a new instance of MDCSliderFoundation
       * @param {?MDCSliderAdapter} adapter
       */

    }]);

    function MDCSliderFoundation(adapter) {
      classCallCheck(this, MDCSliderFoundation);

      /** @private {?ClientRect} */
      var _this = possibleConstructorReturn(this, (MDCSliderFoundation.__proto__ || Object.getPrototypeOf(MDCSliderFoundation)).call(this, _extends(MDCSliderFoundation.defaultAdapter, adapter)));

      _this.rect_ = null;
      // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
      // because those could be valid tabindices set by the client code.
      _this.savedTabIndex_ = NaN;
      _this.active_ = false;
      _this.inTransit_ = false;
      _this.isDiscrete_ = false;
      _this.hasTrackMarker_ = false;
      _this.handlingThumbTargetEvt_ = false;
      _this.min_ = 0;
      _this.max_ = 100;
      _this.step_ = 0;
      _this.value_ = 0;
      _this.disabled_ = false;
      _this.preventFocusState_ = false;
      _this.updateUIFrame_ = 0;
      _this.thumbContainerPointerHandler_ = function () {
        _this.handlingThumbTargetEvt_ = true;
      };
      _this.interactionStartHandler_ = function (evt) {
        return _this.handleDown_(evt);
      };
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeydown_(evt);
      };
      _this.focusHandler_ = function () {
        return _this.handleFocus_();
      };
      _this.blurHandler_ = function () {
        return _this.handleBlur_();
      };
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCSliderFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.isDiscrete_ = this.adapter_.hasClass(cssClasses$15.IS_DISCRETE);
        this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$15.HAS_TRACK_MARKER);
        DOWN_EVENTS.forEach(function (evtName) {
          return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
        });
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
        });
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.layout();
        // At last step, provide a reasonable default value to discrete slider
        if (this.isDiscrete_ && this.getStep() == 0) {
          this.step_ = 1;
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
        });
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
        });
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'setupTrackMarker',
      value: function setupTrackMarker() {
        if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
          var min = this.getMin();
          var max = this.getMax();
          var step = this.getStep();
          var numMarkers = (max - min) / step;

          // In case distance between max & min is indivisible to step,
          // we place the secondary to last marker proportionally at where thumb
          // could reach and place the last marker at max value
          var indivisible = Math.ceil(numMarkers) !== numMarkers;
          if (indivisible) {
            numMarkers = Math.ceil(numMarkers);
          }

          this.adapter_.removeTrackMarkers();
          this.adapter_.appendTrackMarkers(numMarkers);

          if (indivisible) {
            var lastStepRatio = (max - numMarkers * step) / step + 1;
            var flex = getCorrectPropertyName(window, 'flex');
            this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.rect_ = this.adapter_.computeBoundingRect();
        this.updateUIForCurrentValue_();
      }

      /** @return {number} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.value_;
      }

      /** @param {number} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.setValue_(value, false);
      }

      /** @return {number} */

    }, {
      key: 'getMax',
      value: function getMax() {
        return this.max_;
      }

      /** @param {number} max */

    }, {
      key: 'setMax',
      value: function setMax(max) {
        if (max < this.min_) {
          throw new Error('Cannot set max to be less than the slider\'s minimum value');
        }
        this.max_ = max;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$14.ARIA_VALUEMAX, String(this.max_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getMin',
      value: function getMin() {
        return this.min_;
      }

      /** @param {number} min */

    }, {
      key: 'setMin',
      value: function setMin(min) {
        if (min > this.max_) {
          throw new Error('Cannot set min to be greater than the slider\'s maximum value');
        }
        this.min_ = min;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$14.ARIA_VALUEMIN, String(this.min_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getStep',
      value: function getStep() {
        return this.step_;
      }

      /** @param {number} step */

    }, {
      key: 'setStep',
      value: function setStep(step) {
        if (step < 0) {
          throw new Error('Step cannot be set to a negative number');
        }
        if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
          step = 1;
        }
        this.step_ = step;
        this.setValue_(this.value_, false, true);
        this.setupTrackMarker();
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.disabled_ = disabled;
        this.toggleClass_(cssClasses$15.DISABLED, this.disabled_);
        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setAttribute(strings$14.ARIA_DISABLED, 'true');
          this.adapter_.removeAttribute('tabindex');
        } else {
          this.adapter_.removeAttribute(strings$14.ARIA_DISABLED);
          if (!isNaN(this.savedTabIndex_)) {
            this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
          }
        }
      }

      /**
       * Called when the user starts interacting with the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDown_',
      value: function handleDown_(evt) {
        var _this4 = this;

        if (this.disabled_) {
          return;
        }

        this.preventFocusState_ = true;
        this.setInTransit_(!this.handlingThumbTargetEvt_);
        this.handlingThumbTargetEvt_ = false;
        this.setActive_(true);

        var moveHandler = function moveHandler(evt) {
          _this4.handleMove_(evt);
        };

        // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
        // do not always fire these consistently in pairs.
        // (See https://github.com/material-components/material-components-web/issues/1192)
        var upHandler = function upHandler() {
          _this4.handleUp_();
          _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
          });
        };

        this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
        });
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user moves the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleMove_',
      value: function handleMove_(evt) {
        evt.preventDefault();
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user's interaction with the slider ends
       * @private
       */

    }, {
      key: 'handleUp_',
      value: function handleUp_() {
        this.setActive_(false);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the pageX of the event
       * @param {!Event} evt
       * @return {number}
       * @private
       */

    }, {
      key: 'getPageX_',
      value: function getPageX_(evt) {
        if (evt.targetTouches && evt.targetTouches.length > 0) {
          return evt.targetTouches[0].pageX;
        }
        return evt.pageX;
      }

      /**
       * Sets the slider value from an event
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'setValueFromEvt_',
      value: function setValueFromEvt_(evt) {
        var pageX = this.getPageX_(evt);
        var value = this.computeValueFromPageX_(pageX);
        this.setValue_(value, true);
      }

      /**
       * Computes the new value from the pageX position
       * @param {number} pageX
       * @return {number}
       */

    }, {
      key: 'computeValueFromPageX_',
      value: function computeValueFromPageX_(pageX) {
        var max = this.max_,
            min = this.min_;

        var xPos = pageX - this.rect_.left;
        var pctComplete = xPos / this.rect_.width;
        if (this.adapter_.isRTL()) {
          pctComplete = 1 - pctComplete;
        }
        // Fit the percentage complete between the range [min,max]
        // by remapping from [0, 1] to [min, min+(max-min)].
        return min + pctComplete * (max - min);
      }

      /**
       * Handles keydown events
       * @param {!Event} evt
       */

    }, {
      key: 'handleKeydown_',
      value: function handleKeydown_(evt) {
        var keyId = this.getKeyId_(evt);
        var value = this.getValueForKeyId_(keyId);
        if (isNaN(value)) {
          return;
        }

        // Prevent page from scrolling due to key presses that would normally scroll the page
        evt.preventDefault();
        this.adapter_.addClass(cssClasses$15.FOCUS);
        this.setValue_(value, true);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the computed name of the event
       * @param {!Event} kbdEvt
       * @return {string}
       */

    }, {
      key: 'getKeyId_',
      value: function getKeyId_(kbdEvt) {
        if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
          return KEY_IDS.ARROW_LEFT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
          return KEY_IDS.ARROW_RIGHT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
          return KEY_IDS.ARROW_UP;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
          return KEY_IDS.ARROW_DOWN;
        }
        if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
          return KEY_IDS.HOME;
        }
        if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
          return KEY_IDS.END;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
          return KEY_IDS.PAGE_UP;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
          return KEY_IDS.PAGE_DOWN;
        }

        return '';
      }

      /**
       * Computes the value given a keyboard key ID
       * @param {string} keyId
       * @return {number}
       */

    }, {
      key: 'getValueForKeyId_',
      value: function getValueForKeyId_(keyId) {
        var max = this.max_,
            min = this.min_,
            step = this.step_;

        var delta = step || (max - min) / 100;
        var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);
        if (valueNeedsToBeFlipped) {
          delta = -delta;
        }

        switch (keyId) {
          case KEY_IDS.ARROW_LEFT:
          case KEY_IDS.ARROW_DOWN:
            return this.value_ - delta;
          case KEY_IDS.ARROW_RIGHT:
          case KEY_IDS.ARROW_UP:
            return this.value_ + delta;
          case KEY_IDS.HOME:
            return this.min_;
          case KEY_IDS.END:
            return this.max_;
          case KEY_IDS.PAGE_UP:
            return this.value_ + delta * numbers$3.PAGE_FACTOR;
          case KEY_IDS.PAGE_DOWN:
            return this.value_ - delta * numbers$3.PAGE_FACTOR;
          default:
            return NaN;
        }
      }
    }, {
      key: 'handleFocus_',
      value: function handleFocus_() {
        if (this.preventFocusState_) {
          return;
        }
        this.adapter_.addClass(cssClasses$15.FOCUS);
      }
    }, {
      key: 'handleBlur_',
      value: function handleBlur_() {
        this.preventFocusState_ = false;
        this.adapter_.removeClass(cssClasses$15.FOCUS);
      }

      /**
       * Sets the value of the slider
       * @param {number} value
       * @param {boolean} shouldFireInput
       * @param {boolean=} force
       */

    }, {
      key: 'setValue_',
      value: function setValue_(value, shouldFireInput) {
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (value === this.value_ && !force) {
          return;
        }

        var min = this.min_,
            max = this.max_;

        var valueSetToBoundary = value === min || value === max;
        if (this.step_ && !valueSetToBoundary) {
          value = this.quantize_(value);
        }
        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        }
        this.value_ = value;
        this.adapter_.setAttribute(strings$14.ARIA_VALUENOW, String(this.value_));
        this.updateUIForCurrentValue_();

        if (shouldFireInput) {
          this.adapter_.notifyInput();
          if (this.isDiscrete_) {
            this.adapter_.setMarkerValue(value);
          }
        }
      }

      /**
       * Calculates the quantized value
       * @param {number} value
       * @return {number}
       */

    }, {
      key: 'quantize_',
      value: function quantize_(value) {
        var numSteps = Math.round(value / this.step_);
        var quantizedVal = numSteps * this.step_;
        return quantizedVal;
      }
    }, {
      key: 'updateUIForCurrentValue_',
      value: function updateUIForCurrentValue_() {
        var _this5 = this;

        var max = this.max_,
            min = this.min_,
            value = this.value_;

        var pctComplete = (value - min) / (max - min);
        var translatePx = pctComplete * this.rect_.width;
        if (this.adapter_.isRTL()) {
          translatePx = this.rect_.width - translatePx;
        }

        var transformProp = getCorrectPropertyName(window, 'transform');
        var transitionendEvtName = getCorrectEventName(window, 'transitionend');

        if (this.inTransit_) {
          var onTransitionEnd = function onTransitionEnd() {
            _this5.setInTransit_(false);
            _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          };
          this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        }

        this.updateUIFrame_ = requestAnimationFrame(function () {
          // NOTE(traviskaufman): It would be nice to use calc() here,
          // but IE cannot handle calcs in transforms correctly.
          // See: https://goo.gl/NC2itk
          // Also note that the -50% offset is used to center the slider thumb.
          _this5.adapter_.setThumbContainerStyleProperty(transformProp, 'translateX(' + translatePx + 'px) translateX(-50%)');
          _this5.adapter_.setTrackStyleProperty(transformProp, 'scaleX(' + pctComplete + ')');
        });
      }

      /**
       * Toggles the active state of the slider
       * @param {boolean} active
       */

    }, {
      key: 'setActive_',
      value: function setActive_(active) {
        this.active_ = active;
        this.toggleClass_(cssClasses$15.ACTIVE, this.active_);
      }

      /**
       * Toggles the inTransit state of the slider
       * @param {boolean} inTransit
       */

    }, {
      key: 'setInTransit_',
      value: function setInTransit_(inTransit) {
        this.inTransit_ = inTransit;
        this.toggleClass_(cssClasses$15.IN_TRANSIT, this.inTransit_);
      }

      /**
       * Conditionally adds or removes a class based on shouldBePresent
       * @param {string} className
       * @param {boolean} shouldBePresent
       */

    }, {
      key: 'toggleClass_',
      value: function toggleClass_(className, shouldBePresent) {
        if (shouldBePresent) {
          this.adapter_.addClass(className);
        } else {
          this.adapter_.removeClass(className);
        }
      }
    }]);
    return MDCSliderFoundation;
  }(MDCFoundation);

  var mdcSlider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-slider", class: _vm.classes, attrs: { "tabindex": "0", "role": "slider" } }, [_c('div', { staticClass: "mdc-slider__track-container" }, [_c('div', { staticClass: "mdc-slider__track", style: _vm.trackStyles }), _vm._v(" "), _vm.hasMarkers ? _c('div', { staticClass: "mdc-slider__track-marker-container" }, _vm._l(_vm.numMarkers, function (markerNum) {
        return _c('div', { key: markerNum, staticClass: "mdc-slider__track-marker", style: markerNum == _vm.numMarkers ? _vm.lastTrackMarkersStyles : {} });
      })) : _vm._e()]), _vm._v(" "), _c('div', { ref: "thumbContainer", staticClass: "mdc-slider__thumb-container", style: _vm.thumbStyles }, [_vm.isDiscrete ? _c('div', { staticClass: "mdc-slider__pin" }, [_c('span', { staticClass: "mdc-slider__pin-value-marker" }, [_vm._v(_vm._s(_vm.markerValue))])]) : _vm._e(), _vm._v(" "), _c('svg', { staticClass: "mdc-slider__thumb", attrs: { "width": "21", "height": "21" } }, [_c('circle', { attrs: { "cx": "10.5", "cy": "10.5", "r": "7.875" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-slider__focus-ring" })])]);
    }, staticRenderFns: [],
    name: 'mdc-slider',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: [Number, String],
      min: { type: [Number, String], default: 0 },
      max: { type: [Number, String], default: 100 },
      step: { type: [Number, String], default: 0 },
      displayMarkers: Boolean,
      disabled: Boolean,
      layoutOn: String,
      layoutOnSource: { type: Object, required: false }
    },
    data: function data() {
      return {
        classes: {
          'mdc-slider--discrete': !!this.step,
          'mdc-slider--display-markers': this.displayMarkers
        },
        trackStyles: {},
        lastTrackMarkersStyles: {},
        thumbStyles: {},
        markerValue: '',
        numMarkers: 0
      };
    },

    computed: {
      isDiscrete: function isDiscrete() {
        return !!this.step;
      },
      hasMarkers: function hasMarkers() {
        return !!this.step && this.displayMarkers && this.numMarkers;
      }
    },
    watch: {
      value: function value() {
        if (this.foundation.getValue() !== Number(this.value)) {
          this.foundation.setValue(this.value);
        }
      },
      min: function min() {
        this.foundation.setMin(Number(this.min));
      },
      max: function max() {
        this.foundation.setMax(Number(this.max));
      },
      step: function step() {
        this.foundation.setStep(Number(this.step));
      },
      disabled: function disabled() {
        this.foundation.setDisabled(this.disabled);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSliderFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className, true);
        },
        getAttribute: function getAttribute(name) {
          return _this.$el.getAttribute(name);
        },
        setAttribute: function setAttribute(name, value) {
          return _this.$el.setAttribute(name, value);
        },
        removeAttribute: function removeAttribute(name) {
          return _this.$el.removeAttribute(name);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$el.getBoundingClientRect();
        },
        getTabIndex: function getTabIndex() {
          return _this.$el.tabIndex;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$el.addEventListener(type, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$el.removeEventListener(type, handler, applyPassive());
        },
        registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
          _this.$refs.thumbContainer.addEventListener(type, handler, applyPassive());
        },
        deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
          _this.$refs.thumbContainer.removeEventListener(type, handler, applyPassive());
        },
        registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
          document.body.addEventListener(type, handler);
        },
        deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
          document.body.removeEventListener(type, handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        notifyInput: function notifyInput() {
          _this.$emit('input', _this.foundation.getValue());
        },
        notifyChange: function notifyChange() {
          _this.$emit('change', _this.foundation.getValue());
        },
        setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
          _this.$set(_this.thumbStyles, propertyName, value);
        },
        setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
          _this.$set(_this.trackStyles, propertyName, value);
        },
        setMarkerValue: function setMarkerValue(value) {
          _this.markerValue = value;
        },
        appendTrackMarkers: function appendTrackMarkers(numMarkers) {
          _this.numMarkers = numMarkers;
        },
        removeTrackMarkers: function removeTrackMarkers() {
          _this.numMarkers = 0;
        },
        setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
          _this.$set(_this.lastTrackMarkersStyles, propertyName, value);
        },
        isRTL: function isRTL() {
          return false;
        }
      });

      this.foundation.init();
      this.foundation.setDisabled(this.disabled);
      if (Number(this.min) <= this.foundation.getMax()) {
        this.foundation.setMin(Number(this.min));
        this.foundation.setMax(Number(this.max));
      } else {
        this.foundation.setMax(Number(this.max));
        this.foundation.setMin(Number(this.min));
      }
      this.foundation.setStep(Number(this.step));
      this.foundation.setValue(Number(this.value));
      if (this.hasMarkers) {
        this.foundation.setupTrackMarker();
      }

      this.$root.$on('vma:layout', this.layout);

      if (this.layoutOn) {
        this.layoutOnEventSource = this.layoutOnSource || this.$root;
        this.layoutOnEventSource.$on(this.layoutOn, this.layout);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.$root.$off('vma:layout', this.layout);
      if (this.layoutOnEventSource) {
        this.layoutOnEventSource.$off(this.layoutOn, this.layout);
      }
      this.foundation.destroy();
    },

    methods: {
      layout: function layout() {
        var _this2 = this;

        this.$nextTick(function () {
          _this2.foundation && _this2.foundation.layout();
        });
      }
    }
  };

  var VueMDCSlider = BasePlugin({
    mdcSlider: mdcSlider
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$16 = {
    ROOT: 'mdc-snackbar',
    TEXT: 'mdc-snackbar__text',
    ACTION_WRAPPER: 'mdc-snackbar__action-wrapper',
    ACTION_BUTTON: 'mdc-snackbar__action-button',
    ACTIVE: 'mdc-snackbar--active',
    MULTILINE: 'mdc-snackbar--multiline',
    ACTION_ON_BOTTOM: 'mdc-snackbar--action-on-bottom'
  };

  var strings$15 = {
    TEXT_SELECTOR: '.mdc-snackbar__text',
    ACTION_WRAPPER_SELECTOR: '.mdc-snackbar__action-wrapper',
    ACTION_BUTTON_SELECTOR: '.mdc-snackbar__action-button',
    SHOW_EVENT: 'MDCSnackbar:show',
    HIDE_EVENT: 'MDCSnackbar:hide'
  };

  var numbers$4 = {
    MESSAGE_TIMEOUT: 2750
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSnackbarFoundation = function (_MDCFoundation) {
    inherits(MDCSnackbarFoundation, _MDCFoundation);
    createClass(MDCSnackbarFoundation, [{
      key: 'active',
      get: function get$$1() {
        return this.active_;
      }
    }], [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$16;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$15;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          setAriaHidden: function setAriaHidden() {},
          unsetAriaHidden: function unsetAriaHidden() {},
          setActionAriaHidden: function setActionAriaHidden() {},
          unsetActionAriaHidden: function unsetActionAriaHidden() {},
          setActionText: function setActionText() /* actionText: string */{},
          setMessageText: function setMessageText() /* message: string */{},
          setFocus: function setFocus() {},
          visibilityIsHidden: function visibilityIsHidden() {
            return (/* boolean */false
            );
          },
          registerCapturedBlurHandler: function registerCapturedBlurHandler() /* handler: EventListener */{},
          deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler() /* handler: EventListener */{},
          registerVisibilityChangeHandler: function registerVisibilityChangeHandler() /* handler: EventListener */{},
          deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler() /* handler: EventListener */{},
          registerCapturedInteractionHandler: function registerCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerActionClickHandler: function registerActionClickHandler() /* handler: EventListener */{},
          deregisterActionClickHandler: function deregisterActionClickHandler() /* handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          notifyShow: function notifyShow() {},
          notifyHide: function notifyHide() {}
        };
      }
    }]);

    function MDCSnackbarFoundation(adapter) {
      classCallCheck(this, MDCSnackbarFoundation);

      var _this = possibleConstructorReturn(this, (MDCSnackbarFoundation.__proto__ || Object.getPrototypeOf(MDCSnackbarFoundation)).call(this, _extends(MDCSnackbarFoundation.defaultAdapter, adapter)));

      _this.active_ = false;
      _this.actionWasClicked_ = false;
      _this.dismissOnAction_ = true;
      _this.firstFocus_ = true;
      _this.pointerDownRecognized_ = false;
      _this.snackbarHasFocus_ = false;
      _this.snackbarData_ = null;
      _this.queue_ = [];
      _this.actionClickHandler_ = function () {
        _this.actionWasClicked_ = true;
        _this.invokeAction_();
      };
      _this.visibilitychangeHandler_ = function () {
        clearTimeout(_this.timeoutId_);
        _this.snackbarHasFocus_ = true;

        if (!_this.adapter_.visibilityIsHidden()) {
          setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
        }
      };
      _this.interactionHandler_ = function (evt) {
        if (evt.type == 'touchstart' || evt.type == 'mousedown') {
          _this.pointerDownRecognized_ = true;
        }
        _this.handlePossibleTabKeyboardFocus_(evt);

        if (evt.type == 'focus') {
          _this.pointerDownRecognized_ = false;
        }
      };
      _this.blurHandler_ = function () {
        clearTimeout(_this.timeoutId_);
        _this.snackbarHasFocus_ = false;
        _this.timeoutId_ = setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
      };
      return _this;
    }

    createClass(MDCSnackbarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerActionClickHandler(this.actionClickHandler_);
        this.adapter_.setAriaHidden();
        this.adapter_.setActionAriaHidden();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this2 = this;

        this.adapter_.deregisterActionClickHandler(this.actionClickHandler_);
        this.adapter_.deregisterCapturedBlurHandler(this.blurHandler_);
        this.adapter_.deregisterVisibilityChangeHandler(this.visibilitychangeHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this2.adapter_.deregisterCapturedInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: 'dismissesOnAction',
      value: function dismissesOnAction() {
        return this.dismissOnAction_;
      }
    }, {
      key: 'setDismissOnAction',
      value: function setDismissOnAction(dismissOnAction) {
        this.dismissOnAction_ = !!dismissOnAction;
      }
    }, {
      key: 'show',
      value: function show(data) {
        var _this3 = this;

        if (!data) {
          throw new Error('Please provide a data object with at least a message to display.');
        }
        if (!data.message) {
          throw new Error('Please provide a message to be displayed.');
        }
        if (data.actionHandler && !data.actionText) {
          throw new Error('Please provide action text with the handler.');
        }
        if (this.active) {
          this.queue_.push(data);
          return;
        }
        clearTimeout(this.timeoutId_);
        this.snackbarData_ = data;
        this.firstFocus_ = true;
        this.adapter_.registerVisibilityChangeHandler(this.visibilitychangeHandler_);
        this.adapter_.registerCapturedBlurHandler(this.blurHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this3.adapter_.registerCapturedInteractionHandler(evtType, _this3.interactionHandler_);
        });

        var ACTIVE = cssClasses$16.ACTIVE,
            MULTILINE = cssClasses$16.MULTILINE,
            ACTION_ON_BOTTOM = cssClasses$16.ACTION_ON_BOTTOM;


        this.adapter_.setMessageText(this.snackbarData_.message);

        if (this.snackbarData_.multiline) {
          this.adapter_.addClass(MULTILINE);
          if (this.snackbarData_.actionOnBottom) {
            this.adapter_.addClass(ACTION_ON_BOTTOM);
          }
        }

        if (this.snackbarData_.actionHandler) {
          this.adapter_.setActionText(this.snackbarData_.actionText);
          this.actionHandler_ = this.snackbarData_.actionHandler;
          this.setActionHidden_(false);
        } else {
          this.setActionHidden_(true);
          this.actionHandler_ = null;
          this.adapter_.setActionText(null);
        }

        this.active_ = true;
        this.adapter_.addClass(ACTIVE);
        this.adapter_.unsetAriaHidden();
        this.adapter_.notifyShow();

        this.timeoutId_ = setTimeout(this.cleanup_.bind(this), this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
      }
    }, {
      key: 'handlePossibleTabKeyboardFocus_',
      value: function handlePossibleTabKeyboardFocus_() {
        var hijackFocus = this.firstFocus_ && !this.pointerDownRecognized_;

        if (hijackFocus) {
          this.setFocusOnAction_();
        }

        this.firstFocus_ = false;
      }
    }, {
      key: 'setFocusOnAction_',
      value: function setFocusOnAction_() {
        this.adapter_.setFocus();
        this.snackbarHasFocus_ = true;
        this.firstFocus_ = false;
      }
    }, {
      key: 'invokeAction_',
      value: function invokeAction_() {
        try {
          if (!this.actionHandler_) {
            return;
          }

          this.actionHandler_();
        } finally {
          if (this.dismissOnAction_) {
            this.cleanup_();
          }
        }
      }
    }, {
      key: 'cleanup_',
      value: function cleanup_() {
        var _this4 = this;

        var allowDismissal = !this.snackbarHasFocus_ || this.actionWasClicked_;

        if (allowDismissal) {
          var ACTIVE = cssClasses$16.ACTIVE,
              MULTILINE = cssClasses$16.MULTILINE,
              ACTION_ON_BOTTOM = cssClasses$16.ACTION_ON_BOTTOM;


          this.adapter_.removeClass(ACTIVE);

          var handler = function handler() {
            clearTimeout(_this4.timeoutId_);
            _this4.adapter_.deregisterTransitionEndHandler(handler);
            _this4.adapter_.removeClass(MULTILINE);
            _this4.adapter_.removeClass(ACTION_ON_BOTTOM);
            _this4.setActionHidden_(true);
            _this4.adapter_.setAriaHidden();
            _this4.active_ = false;
            _this4.snackbarHasFocus_ = false;
            _this4.adapter_.notifyHide();
            _this4.showNext_();
          };

          this.adapter_.registerTransitionEndHandler(handler);
        }
      }
    }, {
      key: 'showNext_',
      value: function showNext_() {
        if (!this.queue_.length) {
          return;
        }
        this.show(this.queue_.shift());
      }
    }, {
      key: 'setActionHidden_',
      value: function setActionHidden_(isHidden) {
        if (isHidden) {
          this.adapter_.setActionAriaHidden();
        } else {
          this.adapter_.unsetActionAriaHidden();
        }
      }
    }]);
    return MDCSnackbarFoundation;
  }(MDCFoundation);

  var mdcSnackbar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-snackbar", class: _vm.classes, attrs: { "aria-hidden": _vm.hidden, "aria-live": "assertive", "aria-atomic": "true" } }, [_c('div', { staticClass: "mdc-snackbar__text" }, [_vm._v(_vm._s(_vm.message))]), _vm._v(" "), _c('div', { staticClass: "mdc-snackbar__action-wrapper" }, [_c('button', { ref: "button", staticClass: "mdc-snackbar__action-button", attrs: { "aria-hidden": _vm.actionHidden, "type": "button" } }, [_vm._v(_vm._s(_vm.actionText))])])]);
    }, staticRenderFns: [],
    name: 'mdc-snackbar',
    model: {
      prop: 'snack',
      event: 'queued'
    },
    props: {
      'align-start': Boolean,
      snack: Object,
      event: String,
      'event-source': {
        type: Object,
        required: false,
        default: function _default() {
          return this.$root;
        }
      },
      'dismisses-on-action': {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        classes: {
          'mdc-snackbar--align-start': this.alignStart
        },
        message: '',
        actionText: '',
        hidden: false,
        actionHidden: false
      };
    },

    watch: {
      snack: 'onSnack'
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSnackbarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setAriaHidden: function setAriaHidden() {
          return _this.hidden = true;
        },
        unsetAriaHidden: function unsetAriaHidden() {
          return _this.hidden = false;
        },
        setActionAriaHidden: function setActionAriaHidden() {
          return _this.actionHidden = true;
        },
        unsetActionAriaHidden: function unsetActionAriaHidden() {
          return _this.actionHidden = false;
        },
        setActionText: function setActionText(text) {
          _this.actionText = text;
        },
        setMessageText: function setMessageText(text) {
          _this.message = text;
        },
        setFocus: function setFocus() {
          return _this.$refs.button.focus();
        },
        visibilityIsHidden: function visibilityIsHidden() {
          return document.hidden;
        },
        registerCapturedBlurHandler: function registerCapturedBlurHandler(handler) {
          return _this.$refs.button.addEventListener('blur', handler, true);
        },
        deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler(handler) {
          return _this.$refs.button.removeEventListener('blur', handler, true);
        },
        registerVisibilityChangeHandler: function registerVisibilityChangeHandler(handler) {
          return document.addEventListener('visibilitychange', handler);
        },
        deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler(handler) {
          return document.removeEventListener('visibilitychange', handler);
        },
        registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
          return document.body.addEventListener(evt, handler, true);
        },
        deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
          return document.body.removeEventListener(evt, handler, true);
        },
        registerActionClickHandler: function registerActionClickHandler(handler) {
          return _this.$refs.button.addEventListener('click', handler);
        },
        deregisterActionClickHandler: function deregisterActionClickHandler(handler) {
          return _this.$refs.button.removeEventListener('click', handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          var root = _this.$refs.root;
          root && root.addEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          var root = _this.$refs.root;
          root && root.removeEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        notifyShow: function notifyShow() {
          return _this.$emit('show');
        },
        notifyHide: function notifyHide() {
          return _this.$emit('hide');
        }
      });
      this.foundation.init();

      // if event specified use it, else if no snack prop then use default.
      this.eventName = this.event || (this.snack === void 0 ? 'show-snackbar' : null);
      if (this.eventName) {
        this.eventSource.$on(this.eventName, this.show);
      }
      this.foundation.setDismissOnAction(this.dismissesOnAction);
    },
    beforeDestroy: function beforeDestroy() {
      if (this.eventSource) {
        this.eventSource.$off(this.eventName, this.show);
      }
      this.foundation.destroy();
    },

    methods: {
      onSnack: function onSnack(snack) {
        if (snack && snack.message) {
          this.foundation.show(snack);
          this.$emit('queued', snack);
        }
      },
      show: function show(data) {
        this.foundation.show(data);
      }
    }
  };

  var VueMDCSnackbar = BasePlugin({
    mdcSnackbar: mdcSnackbar
  });

  var mdcSwitch = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch-wrapper", class: { 'mdc-form-field': _vm.hasLabel, 'mdc-form-field--align-end': _vm.hasLabel && _vm.alignEnd } }, [_c('div', { staticClass: "mdc-switch", class: { 'mdc-switch--disabled': _vm.disabled } }, [_c('input', { ref: "control", staticClass: "mdc-switch__native-control", attrs: { "name": _vm.name, "id": _vm.vma_uid_, "disabled": _vm.disabled, "type": "checkbox" }, domProps: { "checked": _vm.checked }, on: { "change": _vm.onChanged } }), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _vm.hasLabel ? _c('label', { staticClass: "mdc-switch-label", attrs: { "for": _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
    }, staticRenderFns: [function () {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch__background" }, [_c('div', { staticClass: "mdc-switch__knob" })]);
    }],
    name: 'mdc-switch',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: Boolean,
      label: String,
      alignEnd: Boolean,
      disabled: Boolean,
      value: {
        type: String,
        default: function _default() {
          return 'on';
        }
      },
      name: String
    },
    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      }
    },
    methods: {
      onChanged: function onChanged(event) {
        this.$emit('change', event.target.checked);
      }
    }
  };

  var VueMDCSwitch = BasePlugin({
    mdcSwitch: mdcSwitch
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$17 = {
    ACTIVE: 'mdc-tab--active'
  };

  var strings$16 = {
    SELECTED_EVENT: 'MDCTab:selected'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTabFoundation = function (_MDCFoundation) {
    inherits(MDCTabFoundation, _MDCFoundation);
    createClass(MDCTabFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$17;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$16;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          getOffsetLeft: function getOffsetLeft() {
            return (/* number */0
            );
          },
          notifySelected: function notifySelected() {}
        };
      }
    }]);

    function MDCTabFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCTabFoundation);

      var _this = possibleConstructorReturn(this, (MDCTabFoundation.__proto__ || Object.getPrototypeOf(MDCTabFoundation)).call(this, _extends(MDCTabFoundation.defaultAdapter, adapter)));

      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.isActive_ = false;
      _this.preventDefaultOnClick_ = false;

      _this.clickHandler_ = function (evt) {
        if (_this.preventDefaultOnClick_) {
          evt.preventDefault();
        }
        _this.adapter_.notifySelected();
      };

      _this.keydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
          _this.adapter_.notifySelected();
        }
      };
      return _this;
    }

    createClass(MDCTabFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'getComputedWidth',
      value: function getComputedWidth() {
        return this.computedWidth_;
      }
    }, {
      key: 'getComputedLeft',
      value: function getComputedLeft() {
        return this.computedLeft_;
      }
    }, {
      key: 'isActive',
      value: function isActive() {
        return this.isActive_;
      }
    }, {
      key: 'setActive',
      value: function setActive(isActive) {
        this.isActive_ = isActive;
        if (this.isActive_) {
          this.adapter_.addClass(cssClasses$17.ACTIVE);
        } else {
          this.adapter_.removeClass(cssClasses$17.ACTIVE);
        }
      }
    }, {
      key: 'preventsDefaultOnClick',
      value: function preventsDefaultOnClick() {
        return this.preventDefaultOnClick_;
      }
    }, {
      key: 'setPreventDefaultOnClick',
      value: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.preventDefaultOnClick_ = preventDefaultOnClick;
      }
    }, {
      key: 'measureSelf',
      value: function measureSelf() {
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.computedLeft_ = this.adapter_.getOffsetLeft();
      }
    }]);
    return MDCTabFoundation;
  }(MDCFoundation);

  var mdcTab = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', _vm._g({ staticClass: "mdc-tab", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link } }, _vm.listeners), [!!_vm.hasIcon ? _c('i', { ref: "icon", staticClass: "mdc-tab__icon", class: _vm.hasIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("icon", [_vm._v(_vm._s(_vm.hasIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasText ? _c('span', { class: { 'mdc-tab__icon-text': !!_vm.hasIcon } }, [_vm._t("default")], 2) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-tab',
    mixins: [CustomLinkMixin, DispatchEventMixin],
    props: {
      active: Boolean,
      icon: [String, Array, Object]
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      hasIcon: function hasIcon() {
        if (this.icon || this.$slots.icon) {
          return this.icon ? extractIconProp(this.icon) : {};
        }
        return false;
      },
      hasText: function hasText() {
        return !!this.$slots.default;
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$el.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$el.removeEventListener(type, handler);
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getOffsetLeft: function getOffsetLeft() {
          return _this.$el.offsetLeft;
        },
        notifySelected: function notifySelected() {
          emitCustomEvent(_this.$el, MDCTabFoundation.strings.SELECTED_EVENT, { tab: _this }, true);
        }
      });
      this.foundation.init();
      this.setActive(this.active);
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    },

    methods: {
      getComputedWidth: function getComputedWidth() {
        return this.foundation.getComputedWidth();
      },
      getComputedLeft: function getComputedLeft() {
        return this.foundation.getComputedLeft();
      },
      isActive: function isActive() {
        return this.foundation.isActive();
      },
      setActive: function setActive(isActive) {
        this.foundation.setActive(isActive);
      },
      isDefaultPreventedOnClick: function isDefaultPreventedOnClick() {
        return this.foundation.preventsDefaultOnClick();
      },
      setPreventDefaultOnClick: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.foundation.setPreventDefaultOnClick(preventDefaultOnClick);
      },
      measureSelf: function measureSelf() {
        this.foundation.measureSelf();
      }
    }
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$18 = {
    UPGRADED: 'mdc-tab-bar-upgraded'
  };

  var strings$17 = {
    TAB_SELECTOR: '.mdc-tab',
    INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
    CHANGE_EVENT: 'MDCTabBar:change'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTabBarFoundation = function (_MDCFoundation) {
    inherits(MDCTabBarFoundation, _MDCFoundation);
    createClass(MDCTabBarFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$18;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$17;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {},
          unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          setStyleForIndicator: function setStyleForIndicator() /* propertyName: string, value: string */{},
          getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
            return (/* number */0
            );
          },
          notifyChange: function notifyChange() /* evtData: {activeTabIndex: number} */{},
          getNumberOfTabs: function getNumberOfTabs() {
            return (/* number */0
            );
          },
          isTabActiveAtIndex: function isTabActiveAtIndex() {
            return (/* index: number */ /* boolean */false
            );
          },
          setTabActiveAtIndex: function setTabActiveAtIndex() /* index: number, isActive: true */{},
          isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {
            return (/* index: number */ /* boolean */false
            );
          },
          setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex() /* index: number, preventDefaultOnClick: boolean */{},
          measureTabAtIndex: function measureTabAtIndex() /* index: number */{},
          getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
            return (/* index: number */ /* number */0
            );
          }
        };
      }
    }]);

    function MDCTabBarFoundation(adapter) {
      classCallCheck(this, MDCTabBarFoundation);

      var _this = possibleConstructorReturn(this, (MDCTabBarFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarFoundation)).call(this, _extends(MDCTabBarFoundation.defaultAdapter, adapter)));

      _this.isIndicatorShown_ = false;
      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.activeTabIndex_ = 0;
      _this.layoutFrame_ = 0;
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCTabBarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.addClass(cssClasses$18.UPGRADED);
        this.adapter_.bindOnMDCTabSelectedEvent();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        var activeTabIndex = this.findActiveTabIndex_();
        if (activeTabIndex >= 0) {
          this.activeTabIndex_ = activeTabIndex;
        }
        this.layout();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.removeClass(cssClasses$18.UPGRADED);
        this.adapter_.unbindOnMDCTabSelectedEvent();
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this2 = this;

        this.forEachTabIndex_(function (index) {
          return _this2.adapter_.measureTabAtIndex(index);
        });
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.layoutIndicator_();
      }
    }, {
      key: 'layoutIndicator_',
      value: function layoutIndicator_() {
        var isIndicatorFirstRender = !this.isIndicatorShown_;

        // Ensure that indicator appears in the right position immediately for correct first render.
        if (isIndicatorFirstRender) {
          this.adapter_.setStyleForIndicator('transition', 'none');
        }

        var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
        var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();

        var transformValue = 'translateX(' + translateAmtForActiveTabLeft + 'px) scale(' + scaleAmtForActiveTabWidth + ', 1)';
        this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);

        if (isIndicatorFirstRender) {
          // Force layout so that transform styles to take effect.
          this.adapter_.getOffsetWidthForIndicator();
          this.adapter_.setStyleForIndicator('transition', '');
          this.adapter_.setStyleForIndicator('visibility', 'visible');
          this.isIndicatorShown_ = true;
        }
      }
    }, {
      key: 'findActiveTabIndex_',
      value: function findActiveTabIndex_() {
        var _this3 = this;

        var activeTabIndex = -1;
        this.forEachTabIndex_(function (index) {
          if (_this3.adapter_.isTabActiveAtIndex(index)) {
            activeTabIndex = index;
            return true;
          }
        });
        return activeTabIndex;
      }
    }, {
      key: 'forEachTabIndex_',
      value: function forEachTabIndex_(iterator) {
        var numTabs = this.adapter_.getNumberOfTabs();
        for (var index = 0; index < numTabs; index++) {
          var shouldBreak = iterator(index);
          if (shouldBreak) {
            break;
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this4 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this4.layoutInternal_();
          _this4.layoutFrame_ = 0;
        });
      }
    }, {
      key: 'switchToTabAtIndex',
      value: function switchToTabAtIndex(index, shouldNotify) {
        var _this5 = this;

        if (index === this.activeTabIndex_) {
          return;
        }

        if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
          throw new Error('Out of bounds index specified for tab: ' + index);
        }

        var prevActiveTabIndex = this.activeTabIndex_;
        this.activeTabIndex_ = index;
        requestAnimationFrame(function () {
          if (prevActiveTabIndex >= 0) {
            _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
          }
          _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);
          _this5.layoutIndicator_();
          if (shouldNotify) {
            _this5.adapter_.notifyChange({ activeTabIndex: _this5.activeTabIndex_ });
          }
        });
      }
    }, {
      key: 'getActiveTabIndex',
      value: function getActiveTabIndex() {
        return this.findActiveTabIndex_();
      }
    }]);
    return MDCTabBarFoundation;
  }(MDCFoundation);

  var mdcTabBar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', _vm._g({ staticClass: "mdc-tab-bar", class: _vm.classes }, _vm.$listeners), [_vm._t("default"), _vm._v(" "), _c('span', { ref: "indicator", staticClass: "mdc-tab-bar__indicator", style: _vm.indicatorStyles })], 2);
    }, staticRenderFns: [],
    name: 'mdc-tab-bar',
    data: function data() {
      return {
        classes: {},
        indicatorStyles: {},
        tabs: []
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabBarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {
          _this.$el.addEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
        },
        unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {
          return _this.$el.removeEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        setStyleForIndicator: function setStyleForIndicator(propertyName, value) {
          return _this.$set(_this.indicatorStyles, propertyName, value);
        },
        getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
          return _this.$refs.indicator.offsetWidth;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData.activeTabIndex);
        },
        getNumberOfTabs: function getNumberOfTabs() {
          return _this.tabs.length;
        },
        isTabActiveAtIndex: function isTabActiveAtIndex(index) {
          return _this.tabs[index].isActive();
        },
        setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {
          // pgbr: 2018-04-07
          // since it is possible to change the number of tabs programatically
          // we need to detect the foundation deactivating a tab
          // that no longer exists but was previously active.
          if (!isActive && index >= _this.tabs.length) {
            return;
          }
          _this.tabs[index].setActive(isActive);
        },
        isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {
          return _this.tabs[index].isDefaultPreventedOnClick();
        },
        setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
          _this.tabs[index].setPreventDefaultOnClick(preventDefaultOnClick);
        },
        measureTabAtIndex: function measureTabAtIndex(index) {
          return _this.tabs[index].measureSelf();
        },
        getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
          return _this.tabs[index].getComputedWidth();
        },
        getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
          return _this.tabs[index].getComputedLeft();
        }
      });

      var resetTabs = function resetTabs() {
        var tabElements = [].slice.call(_this.$el.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
        _this.tabs = tabElements.map(function (el) {
          return el.__vue__;
        });

        var hasText = void 0,
            hasIcon = void 0;
        var tabs = _this.tabs;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tab = _step.value;

            if (tab.hasText) {
              hasText = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = tabs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _tab = _step2.value;

            if (_tab.hasIcon) {
              hasIcon = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (hasText && hasIcon) {
          _this.$set(_this.classes, 'mdc-tab-bar--icons-with-text', true);
        } else if (hasIcon) {
          _this.$set(_this.classes, 'mdc-tab-bar--icon-tab-bar', true);
        }

        if (_this.foundation) {
          var activeTabIndex = _this.foundation.getActiveTabIndex();
          if (activeTabIndex >= 0) {
            _this.foundation.switchToTabAtIndex(activeTabIndex, true);
          } else {
            _this.foundation.switchToTabAtIndex(0, true);
          }
          _this.foundation.layout();
        }
      };

      resetTabs();

      this.slotObserver = new MutationObserver(function () {
        return resetTabs();
      });
      this.slotObserver.observe(this.$el, { childList: true, subtree: true });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();
      this.foundation.destroy();
    },

    methods: {
      onSelect: function onSelect(_ref) {
        var detail = _ref.detail;
        var tab = detail.tab;

        var index = this.tabs.indexOf(tab);
        if (index < 0) {
          throw new Error('mdc-tab-bar internal error: index not found');
        }
        this.foundation.switchToTabAtIndex(index, true);
      }
    }
  };

  var VueMDCTabs = BasePlugin({
    mdcTab: mdcTab,
    mdcTabBar: mdcTabBar
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Helper Text.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the TextField helper text into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldHelperTextAdapter = function () {
    function MDCTextFieldHelperTextAdapter() {
      classCallCheck(this, MDCTextFieldHelperTextAdapter);
    }

    createClass(MDCTextFieldHelperTextAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the helper text element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the helper text element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns whether or not the helper text element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets an attribute with a given value on the helper text element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}

      /**
       * Removes an attribute from the helper text element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}

      /**
       * Sets the text content for the helper text element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
    }]);
    return MDCTextFieldHelperTextAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$18 = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role'
  };

  /** @enum {string} */
  var cssClasses$19 = {
    HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
   * @final
   */

  var MDCTextFieldHelperTextFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);
    createClass(MDCTextFieldHelperTextFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$19;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$18;
      }

      /**
       * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldHelperTextAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldHelperTextAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldHelperTextAdapter} adapter
       */

    }]);

    function MDCTextFieldHelperTextFoundation(adapter) {
      classCallCheck(this, MDCTextFieldHelperTextFoundation);
      return possibleConstructorReturn(this, (MDCTextFieldHelperTextFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperTextFoundation)).call(this, _extends(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
    }

    /**
     * Sets the content of the helper text field.
     * @param {string} content
     */


    createClass(MDCTextFieldHelperTextFoundation, [{
      key: 'setContent',
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }

      /** @param {boolean} isPersistent Sets the persistency of the helper text. */

    }, {
      key: 'setPersistent',
      value: function setPersistent(isPersistent) {
        if (isPersistent) {
          this.adapter_.addClass(cssClasses$19.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter_.removeClass(cssClasses$19.HELPER_TEXT_PERSISTENT);
        }
      }

      /**
       * @param {boolean} isValidation True to make the helper text act as an
       *   error validation message.
       */

    }, {
      key: 'setValidation',
      value: function setValidation(isValidation) {
        if (isValidation) {
          this.adapter_.addClass(cssClasses$19.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter_.removeClass(cssClasses$19.HELPER_TEXT_VALIDATION_MSG);
        }
      }

      /** Makes the helper text visible to the screen reader. */

    }, {
      key: 'showToScreenReader',
      value: function showToScreenReader() {
        this.adapter_.removeAttr(strings$18.ARIA_HIDDEN);
      }

      /**
       * Sets the validity of the helper text based on the input validity.
       * @param {boolean} inputIsValid
       */

    }, {
      key: 'setValidity',
      value: function setValidity(inputIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$19.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$19.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

        if (validationMsgNeedsDisplay) {
          this.adapter_.setAttr(strings$18.ROLE, 'alert');
        } else {
          this.adapter_.removeAttr(strings$18.ROLE);
        }

        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      }

      /**
       * Hides the help text from screen readers.
       * @private
       */

    }, {
      key: 'hide_',
      value: function hide_() {
        this.adapter_.setAttr(strings$18.ARIA_HIDDEN, 'true');
      }
    }]);
    return MDCTextFieldHelperTextFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Icon.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the text field icon into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldIconAdapter = function () {
    function MDCTextFieldIconAdapter() {
      classCallCheck(this, MDCTextFieldIconAdapter);
    }

    createClass(MDCTextFieldIconAdapter, [{
      key: "getAttr",

      /**
       * Gets the value of an attribute on the icon element.
       * @param {string} attr
       * @return {string}
       */
      value: function getAttr(attr) {}

      /**
       * Sets an attribute on the icon element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}

      /**
       * Removes an attribute from the icon element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}

      /**
       * Registers an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
       */

    }, {
      key: "notifyIconAction",
      value: function notifyIconAction() {}
    }]);
    return MDCTextFieldIconAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$19 = {
    ICON_EVENT: 'MDCTextField:icon',
    ICON_ROLE: 'button'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
   * @final
   */

  var MDCTextFieldIconFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldIconFoundation, _MDCFoundation);
    createClass(MDCTextFieldIconFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$19;
      }

      /**
       * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldIconAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldIconAdapter} */{
            getAttr: function getAttr() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            notifyIconAction: function notifyIconAction() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldIconAdapter} adapter
       */

    }]);

    function MDCTextFieldIconFoundation(adapter) {
      classCallCheck(this, MDCTextFieldIconFoundation);

      /** @private {string?} */
      var _this = possibleConstructorReturn(this, (MDCTextFieldIconFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldIconFoundation)).call(this, _extends(MDCTextFieldIconFoundation.defaultAdapter, adapter)));

      _this.savedTabIndex_ = null;

      /** @private {function(!Event): undefined} */
      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction(evt);
      };
      return _this;
    }

    createClass(MDCTextFieldIconFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');

        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
        });
      }

      /**
       * Sets the content of the helper text field.
       * @param {boolean} disabled
       */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        if (!this.savedTabIndex_) {
          return;
        }

        if (disabled) {
          this.adapter_.setAttr('tabindex', '-1');
          this.adapter_.removeAttr('role');
        } else {
          this.adapter_.setAttr('tabindex', this.savedTabIndex_);
          this.adapter_.setAttr('role', strings$19.ICON_ROLE);
        }
      }

      /**
       * Handles an interaction event
       * @param {!Event} evt
       */

    }, {
      key: 'handleInteraction',
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyIconAction();
        }
      }
    }]);
    return MDCTextFieldIconFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Adapter for MDC Text Field.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Text Field into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCTextFieldAdapter = function () {
    function MDCTextFieldAdapter() {
      classCallCheck(this, MDCTextFieldAdapter);
    }

    createClass(MDCTextFieldAdapter, [{
      key: 'addClass',

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: 'hasClass',
      value: function hasClass(className) {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'registerTextFieldInteractionHandler',
      value: function registerTextFieldInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'deregisterTextFieldInteractionHandler',
      value: function deregisterTextFieldInteractionHandler(type, handler) {}

      /**
       * Registers an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'registerInputInteractionHandler',
      value: function registerInputInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'deregisterInputInteractionHandler',
      value: function deregisterInputInteractionHandler(evtType, handler) {}

      /**
       * Registers a validation attribute change listener on the input element.
       * @param {function(!Array): undefined} handler
       * @return {!MutationObserver}
       */

    }, {
      key: 'registerValidationAttributeChangeHandler',
      value: function registerValidationAttributeChangeHandler(handler) {}

      /**
       * Disconnects a validation attribute observer on the input element.
       * @param {!MutationObserver} observer
       */

    }, {
      key: 'deregisterValidationAttributeChangeHandler',
      value: function deregisterValidationAttributeChangeHandler(observer) {}

      /**
       * Returns an object representing the native text input element, with a
       * similar API shape. The object returned should include the value, disabled
       * and badInput properties, as well as the checkValidity() function. We never
       * alter the value within our code, however we do update the disabled
       * property, so if you choose to duck-type the return value for this method
       * in your implementation it's important to keep this in mind. Also note that
       * this method can return null, which the foundation will handle gracefully.
       * @return {?Element|?NativeInputType}
       */

    }, {
      key: 'getNativeInput',
      value: function getNativeInput() {}

      /**
       * Returns true if the textfield is focused.
       * We achieve this via `document.activeElement === this.root_`.
       * @return {boolean}
       */

    }, {
      key: 'isFocused',
      value: function isFocused() {}

      /**
       * Returns true if the direction of the root element is set to RTL.
       * @return {boolean}
       */

    }, {
      key: 'isRtl',
      value: function isRtl() {}

      /**
       * Activates the line ripple.
       */

    }, {
      key: 'activateLineRipple',
      value: function activateLineRipple() {}

      /**
       * Deactivates the line ripple.
       */

    }, {
      key: 'deactivateLineRipple',
      value: function deactivateLineRipple() {}

      /**
       * Sets the transform origin of the line ripple.
       * @param {number} normalizedX
       */

    }, {
      key: 'setLineRippleTransformOrigin',
      value: function setLineRippleTransformOrigin(normalizedX) {}

      /**
       * Only implement if label exists.
       * Shakes label if shouldShake is true.
       * @param {boolean} shouldShake
       */

    }, {
      key: 'shakeLabel',
      value: function shakeLabel(shouldShake) {}

      /**
       * Only implement if label exists.
       * Floats the label above the input element if shouldFloat is true.
       * @param {boolean} shouldFloat
       */

    }, {
      key: 'floatLabel',
      value: function floatLabel(shouldFloat) {}

      /**
       * Returns true if label element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: 'hasLabel',
      value: function hasLabel() {}

      /**
       * Only implement if label exists.
       * Returns width of label in pixels.
       * @return {number}
       */

    }, {
      key: 'getLabelWidth',
      value: function getLabelWidth() {}

      /**
       * Returns true if outline element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: 'hasOutline',
      value: function hasOutline() {}

      /**
       * Only implement if outline element exists.
       * Updates SVG Path and outline element based on the
       * label element width and RTL context.
       * @param {number} labelWidth
       * @param {boolean=} isRtl
       */

    }, {
      key: 'notchOutline',
      value: function notchOutline(labelWidth, isRtl) {}

      /**
       * Only implement if outline element exists.
       * Closes notch in outline element.
       */

    }, {
      key: 'closeOutline',
      value: function closeOutline() {}
    }]);
    return MDCTextFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$20 = {
    ARIA_CONTROLS: 'aria-controls',
    INPUT_SELECTOR: '.mdc-text-field__input',
    LABEL_SELECTOR: '.mdc-floating-label',
    ICON_SELECTOR: '.mdc-text-field__icon',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple'
  };

  /** @enum {string} */
  var cssClasses$20 = {
    ROOT: 'mdc-text-field',
    UPGRADED: 'mdc-text-field--upgraded',
    DISABLED: 'mdc-text-field--disabled',
    DENSE: 'mdc-text-field--dense',
    FOCUSED: 'mdc-text-field--focused',
    INVALID: 'mdc-text-field--invalid',
    BOX: 'mdc-text-field--box',
    OUTLINED: 'mdc-text-field--outlined'
  };

  /** @enum {number} */
  var numbers$5 = {
    LABEL_SCALE: 0.75,
    DENSE_LABEL_SCALE: 0.923
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
  // under section: `Validation-related attributes`
  var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];

  /**
   * @extends {MDCFoundation<!MDCTextFieldAdapter>}
   * @final
   */

  var MDCTextFieldFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldFoundation, _MDCFoundation);
    createClass(MDCTextFieldFoundation, [{
      key: 'shouldShake',


      /** @return {boolean} */
      get: function get$$1() {
        return !this.isValid() && !this.isFocused_;
      }

      /** @return {boolean} */

    }, {
      key: 'shouldFloat',
      get: function get$$1() {
        return !this.isBadInput_() && (!!this.getValue() || this.isFocused_);
      }

      /**
       * {@see MDCTextFieldAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldAdapter}
       */

    }], [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$20;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$20;
      }

      /** @return enum {string} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$5;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
            deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
            registerInputInteractionHandler: function registerInputInteractionHandler() {},
            deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
            registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {},
            deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {},
            getNativeInput: function getNativeInput() {},
            isFocused: function isFocused() {},
            isRtl: function isRtl() {},
            activateLineRipple: function activateLineRipple() {},
            deactivateLineRipple: function deactivateLineRipple() {},
            setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {},
            shakeLabel: function shakeLabel() {},
            floatLabel: function floatLabel() {},
            hasLabel: function hasLabel() {},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {},
            notchOutline: function notchOutline() {},
            closeOutline: function closeOutline() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldAdapter} adapter
       * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
       */

    }]);

    function MDCTextFieldFoundation(adapter) {
      var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /** @type {!FoundationMapType} */{};
      classCallCheck(this, MDCTextFieldFoundation);

      /** @type {!MDCTextFieldHelperTextFoundation|undefined} */
      var _this = possibleConstructorReturn(this, (MDCTextFieldFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldFoundation)).call(this, _extends(MDCTextFieldFoundation.defaultAdapter, adapter)));

      _this.helperText_ = foundationMap.helperText;
      /** @type {!MDCTextFieldIconFoundation|undefined} */
      _this.icon_ = foundationMap.icon;

      /** @private {boolean} */
      _this.isFocused_ = false;
      /** @private {boolean} */
      _this.receivedUserInput_ = false;
      /** @private {boolean} */
      _this.useCustomValidityChecking_ = false;
      /** @private {boolean} */
      _this.isValid_ = true;
      /** @private {function(): undefined} */
      _this.inputFocusHandler_ = function () {
        return _this.activateFocus();
      };
      /** @private {function(): undefined} */
      _this.inputBlurHandler_ = function () {
        return _this.deactivateFocus();
      };
      /** @private {function(): undefined} */
      _this.inputInputHandler_ = function () {
        return _this.autoCompleteFocus();
      };
      /** @private {function(!Event): undefined} */
      _this.setPointerXOffset_ = function (evt) {
        return _this.setTransformOrigin(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.textFieldInteractionHandler_ = function () {
        return _this.handleTextFieldInteraction();
      };
      /** @private {function(!Array): undefined} */
      _this.validationAttributeChangeHandler_ = function (mutations) {
        return _this.handleValidationAttributeMutation(mutations);
      };
      /** @private {!MutationObserver} */
      _this.validationObserver_;
      return _this;
    }

    createClass(MDCTextFieldFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
        // Ensure label does not collide with any pre-filled value.
        if (this.adapter_.hasLabel() && this.getValue()) {
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }

        if (this.adapter_.isFocused()) {
          this.inputFocusHandler_();
        }

        this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
        });
        this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
        this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
        });
        this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
      }

      /**
       * Handles user interactions with the Text Field.
       */

    }, {
      key: 'handleTextFieldInteraction',
      value: function handleTextFieldInteraction() {
        if (this.adapter_.getNativeInput().disabled) {
          return;
        }
        this.receivedUserInput_ = true;
      }

      /**
       * Handles validation attribute changes
       * @param {!Array<MutationRecord>} mutationsList
       */

    }, {
      key: 'handleValidationAttributeMutation',
      value: function handleValidationAttributeMutation(mutationsList) {
        var _this4 = this;

        mutationsList.some(function (mutation) {
          if (VALIDATION_ATTR_WHITELIST.indexOf(mutation.attributeName) > -1) {
            _this4.styleValidity_(true);
            return true;
          }
        });
      }

      /**
       * Opens/closes the notched outline.
       * @param {boolean} openNotch
       */

    }, {
      key: 'notchOutline',
      value: function notchOutline(openNotch) {
        if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
          return;
        }

        if (openNotch) {
          var isDense = this.adapter_.hasClass(cssClasses$20.DENSE);
          var labelScale = isDense ? numbers$5.DENSE_LABEL_SCALE : numbers$5.LABEL_SCALE;
          var labelWidth = this.adapter_.getLabelWidth() * labelScale;
          var isRtl = this.adapter_.isRtl();
          this.adapter_.notchOutline(labelWidth, isRtl);
        } else {
          this.adapter_.closeOutline();
        }
      }

      /**
       * Activates the text field focus state.
       */

    }, {
      key: 'activateFocus',
      value: function activateFocus() {
        this.isFocused_ = true;
        this.styleFocused_(this.isFocused_);
        this.adapter_.activateLineRipple();
        this.notchOutline(this.shouldFloat);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
        }
        if (this.helperText_) {
          this.helperText_.showToScreenReader();
        }
      }

      /**
       * Sets the line ripple's transform origin, so that the line ripple activate
       * animation will animate out from the user's click location.
       * @param {!Event} evt
       */

    }, {
      key: 'setTransformOrigin',
      value: function setTransformOrigin(evt) {
        var targetClientRect = evt.target.getBoundingClientRect();
        var evtCoords = { x: evt.clientX, y: evt.clientY };
        var normalizedX = evtCoords.x - targetClientRect.left;
        this.adapter_.setLineRippleTransformOrigin(normalizedX);
      }

      /**
       * Activates the Text Field's focus state in cases when the input value
       * changes without user input (e.g. programatically).
       */

    }, {
      key: 'autoCompleteFocus',
      value: function autoCompleteFocus() {
        if (!this.receivedUserInput_) {
          this.activateFocus();
        }
      }

      /**
       * Deactivates the Text Field's focus state.
       */

    }, {
      key: 'deactivateFocus',
      value: function deactivateFocus() {
        this.isFocused_ = false;
        this.adapter_.deactivateLineRipple();
        var input = this.getNativeInput_();
        var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        this.styleFocused_(this.isFocused_);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }
        if (shouldRemoveLabelFloat) {
          this.receivedUserInput_ = false;
        }
      }

      /**
       * @return {string} The value of the input Element.
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeInput_().value;
      }

      /**
       * @param {string} value The value to set on the input Element.
       */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeInput_().value = value;
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }
      }

      /**
       * @return {boolean} If a custom validity is set, returns that value.
       *     Otherwise, returns the result of native validity checks.
       */

    }, {
      key: 'isValid',
      value: function isValid() {
        return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();
      }

      /**
       * @param {boolean} isValid Sets the validity state of the Text Field.
       */

    }, {
      key: 'setValid',
      value: function setValid(isValid) {
        this.useCustomValidityChecking_ = true;
        this.isValid_ = isValid;
        // Retrieve from the getter to ensure correct logic is applied.
        isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
        }
      }

      /**
       * @return {boolean} True if the Text Field is disabled.
       */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeInput_().disabled;
      }

      /**
       * @param {boolean} disabled Sets the text-field disabled or enabled.
       */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.getNativeInput_().disabled = disabled;
        this.styleDisabled_(disabled);
      }

      /**
       * @param {string} content Sets the content of the helper text.
       */

    }, {
      key: 'setHelperTextContent',
      value: function setHelperTextContent(content) {
        if (this.helperText_) {
          this.helperText_.setContent(content);
        }
      }

      /**
       * @return {boolean} True if the Text Field input fails in converting the
       *     user-supplied value.
       * @private
       */

    }, {
      key: 'isBadInput_',
      value: function isBadInput_() {
        return this.getNativeInput_().validity.badInput;
      }

      /**
       * @return {boolean} The result of native validity checking
       *     (ValidityState.valid).
       */

    }, {
      key: 'isNativeInputValid_',
      value: function isNativeInputValid_() {
        return this.getNativeInput_().validity.valid;
      }

      /**
       * Styles the component based on the validity state.
       * @param {boolean} isValid
       * @private
       */

    }, {
      key: 'styleValidity_',
      value: function styleValidity_(isValid) {
        var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

        if (isValid) {
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.addClass(INVALID);
        }
        if (this.helperText_) {
          this.helperText_.setValidity(isValid);
        }
      }

      /**
       * Styles the component based on the focused state.
       * @param {boolean} isFocused
       * @private
       */

    }, {
      key: 'styleFocused_',
      value: function styleFocused_(isFocused) {
        var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

        if (isFocused) {
          this.adapter_.addClass(FOCUSED);
        } else {
          this.adapter_.removeClass(FOCUSED);
        }
      }

      /**
       * Styles the component based on the disabled state.
       * @param {boolean} isDisabled
       * @private
       */

    }, {
      key: 'styleDisabled_',
      value: function styleDisabled_(isDisabled) {
        var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
            DISABLED = _MDCTextFieldFoundati.DISABLED,
            INVALID = _MDCTextFieldFoundati.INVALID;

        if (isDisabled) {
          this.adapter_.addClass(DISABLED);
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
        if (this.icon_) {
          this.icon_.setDisabled(isDisabled);
        }
      }

      /**
       * @return {!Element|!NativeInputType} The native text input from the
       * host environment, or a dummy if none exists.
       * @private
       */

    }, {
      key: 'getNativeInput_',
      value: function getNativeInput_() {
        return this.adapter_.getNativeInput() ||
        /** @type {!NativeInputType} */{
          value: '',
          disabled: false,
          validity: {
            badInput: false,
            valid: true
          }
        };
      }
    }]);
    return MDCTextFieldFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Notched Outline.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Notched Outline into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCNotchedOutlineAdapter = function () {
    function MDCNotchedOutlineAdapter() {
      classCallCheck(this, MDCNotchedOutlineAdapter);
    }

    createClass(MDCNotchedOutlineAdapter, [{
      key: "getWidth",

      /**
       * Returns the width of the root element.
       * @return {number}
       */
      value: function getWidth() {}

      /**
       * Returns the height of the root element.
       * @return {number}
       */

    }, {
      key: "getHeight",
      value: function getHeight() {}

      /**
       * Adds a class to the root element.
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Sets the "d" attribute of the outline element's SVG path.
       * @param {string} value
       */

    }, {
      key: "setOutlinePathAttr",
      value: function setOutlinePathAttr(value) {}

      /**
       * Returns the idle outline element's computed style value of the given css property `propertyName`.
       * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getIdleOutlineStyleValue",
      value: function getIdleOutlineStyleValue(propertyName) {}
    }]);
    return MDCNotchedOutlineAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$21 = {
    PATH_SELECTOR: '.mdc-notched-outline__path',
    IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
  };

  /** @enum {string} */
  var cssClasses$21 = {
    OUTLINE_NOTCHED: 'mdc-notched-outline--notched'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
   * @final
   */

  var MDCNotchedOutlineFoundation = function (_MDCFoundation) {
    inherits(MDCNotchedOutlineFoundation, _MDCFoundation);
    createClass(MDCNotchedOutlineFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$21;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$21;
      }

      /**
       * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCNotchedOutlineAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCNotchedOutlineAdapter} */{
            getWidth: function getWidth() {},
            getHeight: function getHeight() {},
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            setOutlinePathAttr: function setOutlinePathAttr() {},
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
          }
        );
      }

      /**
       * @param {!MDCNotchedOutlineAdapter} adapter
       */

    }]);

    function MDCNotchedOutlineFoundation(adapter) {
      classCallCheck(this, MDCNotchedOutlineFoundation);
      return possibleConstructorReturn(this, (MDCNotchedOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCNotchedOutlineFoundation)).call(this, _extends(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
    }

    /**
     * Adds the outline notched selector and updates the notch width
     * calculated based off of notchWidth and isRtl.
     * @param {number} notchWidth
     * @param {boolean=} isRtl
     */


    createClass(MDCNotchedOutlineFoundation, [{
      key: 'notch',
      value: function notch(notchWidth) {
        var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

        this.adapter_.addClass(OUTLINE_NOTCHED);
        this.updateSvgPath_(notchWidth, isRtl);
      }

      /**
       * Removes notched outline selector to close the notch in the outline.
       */

    }, {
      key: 'closeNotch',
      value: function closeNotch() {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

        this.adapter_.removeClass(OUTLINE_NOTCHED);
      }

      /**
       * Updates the SVG path of the focus outline element based on the notchWidth
       * and the RTL context.
       * @param {number} notchWidth
       * @param {boolean=} isRtl
       * @private
       */

    }, {
      key: 'updateSvgPath_',
      value: function updateSvgPath_(notchWidth, isRtl) {
        // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
        var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
        var radius = parseFloat(radiusStyleValue);
        var width = this.adapter_.getWidth();
        var height = this.adapter_.getHeight();
        var cornerWidth = radius + 1.2;
        var leadingStrokeLength = Math.abs(11 - cornerWidth);
        var paddedNotchWidth = notchWidth + 8;

        // The right, bottom, and left sides of the outline follow the same SVG path.
        var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;

        var path = void 0;
        if (!isRtl) {
          path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
        } else {
          path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
        }

        this.adapter_.setOutlinePathAttr(path);
      }
    }]);
    return MDCNotchedOutlineFoundation;
  }(MDCFoundation);

  var mdcTextField = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-textfield-wrapper", style: { width: _vm.fullwidth ? '100%' : undefined }, attrs: { "id": _vm.id } }, [_c('div', { ref: "root", class: _vm.rootClasses }, [!!_vm.hasLeadingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasLeadingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("leading-icon", [_vm._v(_vm._s(_vm.hasLeadingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.multiline ? _c('textarea', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "id": _vm.vma_uid_, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls, "rows": _vm.rows, "cols": _vm.cols }, on: { "input": function input($event) {
            _vm.updateValue($event.target.value);
          } } }, 'textarea', _vm.$attrs, false), _vm.$listeners)) : _c('input', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "id": _vm.vma_uid_, "type": _vm.type, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls }, on: { "input": function input($event) {
            _vm.updateValue($event.target.value);
          } } }, 'input', _vm.$attrs, false), _vm.$listeners)), _vm._v(" "), _vm.hasLabel ? _c('label', { ref: "label", class: _vm.labelClassesUpgraded, attrs: { "for": _vm.vma_uid_ } }, [_vm._v(" " + _vm._s(_vm.label) + " ")]) : _vm._e(), _vm._v(" "), !!_vm.hasTrailingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasTrailingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("trailing-icon", [_vm._v(_vm._s(_vm.hasTrailingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outline", staticClass: "mdc-notched-outline", class: _vm.outlineClasses }, [_c('svg', [_c('path', { staticClass: "mdc-notched-outline__path", attrs: { "d": _vm.outlinePathAttr } })])]) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outlineIdle", staticClass: "mdc-notched-outline__idle" }) : _vm._e(), _vm._v(" "), _vm.hasLineRipple ? _c('div', { ref: "lineRipple", class: _vm.lineRippleClasses, style: _vm.lineRippleStyles }) : _vm._e()]), _vm._v(" "), _vm.helptext ? _c('p', { ref: "help", class: _vm.helpClasses, attrs: { "id": 'help-' + _vm.vma_uid_, "aria-hidden": "true" } }, [_vm._v(" " + _vm._s(_vm.helptext) + " ")]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-textfield',
    mixins: [CustomElementMixin, DispatchFocusMixin, VMAUniqueIdMixin],
    inheritAttrs: false,
    model: {
      prop: 'value',
      event: 'model'
    },
    props: {
      value: String,
      type: {
        type: String,
        default: 'text',
        validator: function validator(value) {
          return ['text', 'email', 'search', 'password', 'tel', 'url', 'number'].indexOf(value) !== -1;
        }
      },
      dense: Boolean,
      label: String,
      helptext: String,
      helptextPersistent: Boolean,
      helptextValidation: Boolean,
      box: Boolean,
      outline: Boolean,
      disabled: Boolean,
      required: Boolean,
      valid: { type: Boolean, default: undefined },
      fullwidth: Boolean,
      multiline: Boolean,
      leadingIcon: [String, Array, Object],
      trailingIcon: [String, Array, Object],
      size: { type: [Number, String], default: 20 },
      minlength: { type: [Number, String], default: undefined },
      maxlength: { type: [Number, String], default: undefined },
      rows: { type: [Number, String], default: 8 },
      cols: { type: [Number, String], default: 40 },
      id: { type: String }
    },
    data: function data() {
      return {
        text: this.value,
        rootClasses: {
          'mdc-textfield': true,
          'mdc-text-field': true,
          'mdc-text-field--upgraded': true,
          'mdc-text-field--disabled': this.disabled,
          'mdc-text-field--dense': this.dense,
          'mdc-text-field--fullwidth': this.fullwidth,
          'mdc-text-field--textarea': this.multiline,
          'mdc-text-field--box': !this.fullwidth && this.box,
          'mdc-text-field--outlined': !this.fullwidth && this.outline
        },
        inputClasses: {
          'mdc-text-field__input': true
        },
        labelClasses: {
          'mdc-floating-label': true
        },
        lineRippleClasses: {
          'mdc-line-ripple': true
        },
        lineRippleStyles: {},
        helpClasses: {
          'mdc-text-field-helper-text': true,
          'mdc-text-field-helper-text--persistent': this.helptextPersistent,
          'mdc-text-field-helper-text--validation-msg': this.helptextValidation
        },
        outlineClasses: {},
        outlinePathAttr: undefined
      };
    },
    computed: {
      inputPlaceHolder: function inputPlaceHolder() {
        return this.fullwidth ? this.label : undefined;
      },
      inputAriaControls: function inputAriaControls() {
        return this.help ? 'help-' + this.vma_uid_ : undefined;
      },
      hasLabel: function hasLabel() {
        return !this.fullwidth && this.label;
      },
      hasOutline: function hasOutline() {
        return !this.fullwidth && this.outline;
      },
      hasLineRipple: function hasLineRipple() {
        return !this.hasOutline && !this.multiline;
      },
      hasLeadingIcon: function hasLeadingIcon() {
        if ((this.leadingIcon || this.$slots['leading-icon']) && !(this.trailingIcon || this.$slots['trailing-icon'])) {
          return this.leadingIcon ? extractIconProp(this.leadingIcon) : {};
        }
        return false;
      },
      hasTrailingIcon: function hasTrailingIcon() {
        if (this.trailingIcon || this.$slots['trailing-icon']) {
          return this.trailingIcon ? extractIconProp(this.trailingIcon) : {};
        }
        return false;
      },
      labelClassesUpgraded: function labelClassesUpgraded() {
        return _extends(this.labelClasses, {
          'mdc-floating-label--float-above': this.value
        });
      }
    },
    watch: {
      disabled: function disabled() {
        this.foundation && this.foundation.setDisabled(this.disabled);
      },
      required: function required() {
        this.$refs.input && (this.$refs.input.required = this.required);
      },
      valid: function valid() {
        if (typeof this.valid !== 'undefined') {
          this.foundation && this.foundation.setValid(this.valid);
        }
      },
      dense: function dense() {
        this.$set(this.rootClasses, 'mdc-text-field--dense', this.dense);
      },
      helptextPersistent: function helptextPersistent() {
        this.helperTextFoundation && this.helperTextFoundation.setPersistent(this.helptextPersistent);
      },
      helptextValidation: function helptextValidation() {
        this.helperTextFoundation && this.helperTextFoundation.setValidation(this.helptextValidation);
      },
      value: function value(_value) {
        if (this.foundation) {
          if (_value !== this.foundation.getValue()) {
            this.foundation.setValue(_value);
          }
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.$refs.lineRipple) {
        this.lineRippleFoundation = new MDCLineRippleFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.lineRippleClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.lineRippleClasses, className);
          },
          hasClass: function hasClass(className) {
            _this.$refs.lineRipple.classList.contains(className);
          },
          setStyle: function setStyle(name, value) {
            _this.$set(_this.lineRippleStyles, name, value);
          },
          registerEventHandler: function registerEventHandler(evtType, handler) {
            _this.$refs.lineRipple.addEventListener(evtType, handler);
          },
          deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
            _this.$refs.lineRipple.removeEventListener(evtType, handler);
          }
        });
        this.lineRippleFoundation.init();
      }

      if (this.$refs.help) {
        this.helperTextFoundation = new MDCTextFieldHelperTextFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.helpClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.helpClasses, className);
          },
          hasClass: function hasClass(className) {
            return _this.$refs.help.classList.contains(className);
          },
          setAttr: function setAttr(name, value) {
            _this.$refs.help.setAttribute(name, value);
          },
          removeAttr: function removeAttr(name) {
            _this.$refs.help.removeAttribute(name);
          },
          setContent: function setContent() /*content*/{
            // help text get's updated from {{helptext}}
            // this.$refs.help.textContent = content;
          }
        });
        this.helperTextFoundation.init();
      }

      if (this.$refs.icon) {
        if (this.hasLeadingIcon) {
          this.$set(this.rootClasses, 'mdc-text-field--with-leading-icon', true);
        } else if (this.hasTrailingIcon) {
          this.$set(this.rootClasses, 'mdc-text-field--with-trailing-icon', true);
        }

        this.iconFoundation = new MDCTextFieldIconFoundation({
          setAttr: function setAttr(attr, value) {
            return _this.$refs.icon.setAttribute(attr, value);
          },
          getAttr: function getAttr(attr) {
            return _this.$refs.icon.getAttribute(attr);
          },
          removeAttr: function removeAttr(attr) {
            return _this.$refs.icon.removeAttribute(attr);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.icon.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.icon.removeEventListener(evtType, handler);
          },
          notifyIconAction: function notifyIconAction() {
            return _this.$emit('icon-action');
          }
        });
        this.iconFoundation.init();
      }

      if (this.$refs.label) {
        this.labelFoundation = new MDCFloatingLabelFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.labelClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.labelClasses, className);
          },
          getWidth: function getWidth() {
            return _this.$refs.label.offsetWidth;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.label.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.label.removeEventListener(evtType, handler);
          }
        });
        this.labelFoundation.init();
      }

      if (this.$refs.outline) {
        this.outlineFoundation = new MDCNotchedOutlineFoundation({
          getWidth: function getWidth() {
            return _this.$refs.outline.offsetWidth;
          },
          getHeight: function getHeight() {
            return _this.$refs.outline.offsetHeight;
          },
          addClass: function addClass(className) {
            _this.$set(_this.outlineClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.outlineClasses, className);
          },
          setOutlinePathAttr: function setOutlinePathAttr(value) {
            _this.outlinePathAttr = value;
          },
          getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
            var idleOutlineElement = _this.$refs.outlineIdle;
            if (idleOutlineElement) {
              return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
            }
          }
        });
        this.outlineFoundation.init();
      }

      this.foundation = new MDCTextFieldFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.$refs.root.classList.contains(className);
        },
        registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.addEventListener(evtType, handler);
        },
        deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.removeEventListener(evtType, handler);
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.input;
        },
        isRtl: function isRtl() {
          return window.getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        deactivateLineRipple: function deactivateLineRipple() {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.deactivate();
          }
        },
        activateLineRipple: function activateLineRipple() {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.activate();
          }
        },
        setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.setRippleCenter(normalizedX);
          }
        },
        registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
          _this.$refs.input.addEventListener(evtType, handler, applyPassive());
        },
        deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
          _this.$refs.input.removeEventListener(evtType, handler, applyPassive());
        },
        registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
          var observer = new MutationObserver(handler);
          var targetNode = _this.$refs.input;
          var config = { attributes: true };
          observer.observe(targetNode, config);
          return observer;
        },
        deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
          observer.disconnect();
        },
        shakeLabel: function shakeLabel(shouldShake) {
          _this.labelFoundation.shake(shouldShake);
        },
        floatLabel: function floatLabel(shouldFloat) {
          _this.labelFoundation.float(shouldFloat);
        },
        hasLabel: function hasLabel() {
          return !!_this.$refs.label;
        },
        getLabelWidth: function getLabelWidth() {
          return _this.labelFoundation.getWidth();
        },
        getNativeInput: function getNativeInput() {
          return _this.$refs.input;
        },
        hasOutline: function hasOutline() {
          return !!_this.hasOutline;
        },
        notchOutline: function notchOutline(notchWidth, isRtl) {
          return _this.outlineFoundation.notch(notchWidth, isRtl);
        },
        closeOutline: function closeOutline() {
          return _this.outlineFoundation.closeNotch();
        }
      }, {
        helperText: this.helperTextFoundation,
        icon: this.iconFoundation
      });

      this.foundation.init();
      this.foundation.setValue(this.value);
      this.foundation.setDisabled(this.disabled);
      this.$refs.input && (this.$refs.input.required = this.required);
      if (typeof this.valid !== 'undefined') {
        this.foundation.setValid(this.valid);
      }

      if (this.textbox) {
        this.ripple = new RippleBase(this);
        this.ripple.init();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.lineRippleFoundation && this.lineRippleFoundation.destroy();
      this.helperTextFoundation && this.helperTextFoundation.destroy();
      this.iconFoundation && this.iconFoundation.destroy();
      this.labelFoundation && this.labelFoundation.destroy();
      this.outlineFoundation && this.outlineFoundation.destroy();
      this.ripple && this.ripple.destroy();
    },

    methods: {
      updateValue: function updateValue(value) {
        this.$emit('model', value);
      },
      focus: function focus() {
        this.$refs.input && this.$refs.input.focus();
      },
      blur: function blur() {
        this.$refs.input && this.$refs.input.blur();
      }
    }
  };

  var VueMDCTextfield = BasePlugin({
    mdcTextField: mdcTextField
  });

  var THEME_COLORS = ['primary', 'secondary', 'background', 'primary-light', 'secondary-light', 'secondary-dark', 'primary-dark'];

  var THEME_STYLES = ['text-primary', 'text-secondary', 'text-hint', 'text-icon', 'text-disabled'];

  var mdcTheme = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-theme", class: _vm.classes, attrs: { "tag": _vm.tag } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-theme',
    components: {
      CustomElement: CustomElement
    },
    props: {
      tag: { type: String, default: 'div' },
      color: String,
      background: String
    },
    computed: {
      classes: function classes() {
        var classes = {};

        if (this.color && THEME_COLORS.indexOf(this.color) !== -1) {
          classes['mdc-theme--' + this.color] = true;
        }

        if (this.background && THEME_COLORS.indexOf(this.background) !== -1) {
          classes['mdc-theme--' + this.background + '-bg'] = true;

          if (this.color && THEME_STYLES.indexOf(this.color) !== -1) {
            classes['mdc-theme--' + this.color + '-on-' + this.background] = true;
          }
        }
        return classes;
      }
    }
  };

  var VueMDCTheme = BasePlugin({
    mdcTheme: mdcTheme
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$22 = {
    FIXED: 'mdc-toolbar--fixed',
    FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
    FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
    TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
    FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
    FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
    FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
  };

  var strings$22 = {
    TITLE_SELECTOR: '.mdc-toolbar__title',
    ICON_SELECTOR: '.mdc-toolbar__icon',
    FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
    CHANGE_EVENT: 'MDCToolbar:change'
  };

  var numbers$6 = {
    MAX_TITLE_SIZE: 2.125,
    MIN_TITLE_SIZE: 1.25,
    TOOLBAR_ROW_HEIGHT: 64,
    TOOLBAR_ROW_MOBILE_HEIGHT: 56,
    TOOLBAR_MOBILE_BREAKPOINT: 600
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCToolbarFoundation = function (_MDCFoundation) {
    inherits(MDCToolbarFoundation, _MDCFoundation);
    createClass(MDCToolbarFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$22;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$22;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$6;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          hasClass: function hasClass() {
            return (/* className: string */ /* boolean */false
            );
          },
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
          deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getViewportWidth: function getViewportWidth() {
            return (/* number */0
            );
          },
          getViewportScrollY: function getViewportScrollY() {
            return (/* number */0
            );
          },
          getOffsetHeight: function getOffsetHeight() {
            return (/* number */0
            );
          },
          getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
            return (/* number */0
            );
          },
          notifyChange: function notifyChange() /* evtData: {flexibleExpansionRatio: number} */{},
          setStyle: function setStyle() /* property: string, value: string */{},
          setStyleForTitleElement: function setStyleForTitleElement() /* property: string, value: string */{},
          setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement() /* property: string, value: string */{},
          setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement() /* property: string, value: string */{}
        };
      }
    }]);

    function MDCToolbarFoundation(adapter) {
      classCallCheck(this, MDCToolbarFoundation);

      var _this = possibleConstructorReturn(this, (MDCToolbarFoundation.__proto__ || Object.getPrototypeOf(MDCToolbarFoundation)).call(this, _extends(MDCToolbarFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.checkRowHeight_();
      };
      _this.scrollHandler_ = function () {
        return _this.updateToolbarStyles_();
      };
      _this.checkRowHeightFrame_ = 0;
      _this.scrollFrame_ = 0;
      _this.executedLastChange_ = false;

      _this.calculations_ = {
        toolbarRowHeight: 0,
        // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
        toolbarRatio: 0, // The ratio of toolbar height to row height
        flexibleExpansionRatio: 0, // The ratio of flexible space height to row height
        maxTranslateYRatio: 0, // The ratio of max toolbar move up distance to row height
        scrollThresholdRatio: 0, // The ratio of max scrollTop that we should listen to to row height
        // Derived Heights based on the above key ratios.
        toolbarHeight: 0,
        flexibleExpansionHeight: 0, // Flexible row minus toolbar height (derived)
        maxTranslateYDistance: 0, // When toolbar only fix last row (derived)
        scrollThreshold: 0
      };
      // Toolbar fixed behavior
      // If toolbar is fixed
      _this.fixed_ = false;
      // If fixed is targeted only at the last row
      _this.fixedLastrow_ = false;
      // Toolbar flexible behavior
      // If the first row is flexible
      _this.hasFlexibleRow_ = false;
      // If use the default behavior
      _this.useFlexDefaultBehavior_ = false;
      return _this;
    }

    createClass(MDCToolbarFoundation, [{
      key: 'init',
      value: function init() {
        this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
        this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
        this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);
        if (this.hasFlexibleRow_) {
          this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
        }
        this.initKeyRatio_();
        this.setKeyHeights_();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.adapter_.registerScrollHandler(this.scrollHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }
    }, {
      key: 'updateAdjustElementStyles',
      value: function updateAdjustElementStyles() {
        if (this.fixed_) {
          this.adapter_.setStyleForFixedAdjustElement('margin-top', this.calculations_.toolbarHeight + 'px');
        }
      }
    }, {
      key: 'getFlexibleExpansionRatio_',
      value: function getFlexibleExpansionRatio_(scrollTop) {
        // To prevent division by zero when there is no flexibleExpansionHeight
        var delta = 0.0001;
        return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
      }
    }, {
      key: 'checkRowHeight_',
      value: function checkRowHeight_() {
        var _this2 = this;

        cancelAnimationFrame(this.checkRowHeightFrame_);
        this.checkRowHeightFrame_ = requestAnimationFrame(function () {
          return _this2.setKeyHeights_();
        });
      }
    }, {
      key: 'setKeyHeights_',
      value: function setKeyHeights_() {
        var newToolbarRowHeight = this.getRowHeight_();
        if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
          this.calculations_.toolbarRowHeight = newToolbarRowHeight;
          this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
          this.updateAdjustElementStyles();
          this.updateToolbarStyles_();
        }
      }
    }, {
      key: 'updateToolbarStyles_',
      value: function updateToolbarStyles_() {
        var _this3 = this;

        cancelAnimationFrame(this.scrollFrame_);
        this.scrollFrame_ = requestAnimationFrame(function () {
          var scrollTop = _this3.adapter_.getViewportScrollY();
          var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

          if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
            return;
          }

          var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

          _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);
          if (_this3.fixedLastrow_) {
            _this3.updateToolbarFixedState_(scrollTop);
          }
          if (_this3.hasFlexibleRow_) {
            _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
          }
          _this3.executedLastChange_ = hasScrolledOutOfThreshold;
          _this3.adapter_.notifyChange({ flexibleExpansionRatio: flexibleExpansionRatio });
        });
      }
    }, {
      key: 'scrolledOutOfThreshold_',
      value: function scrolledOutOfThreshold_(scrollTop) {
        return scrollTop > this.calculations_.scrollThreshold;
      }
    }, {
      key: 'initKeyRatio_',
      value: function initKeyRatio_() {
        var toolbarRowHeight = this.getRowHeight_();
        var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
        this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
        this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
        this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
        this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
      }
    }, {
      key: 'getRowHeight_',
      value: function getRowHeight_() {
        var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
        return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
      }
    }, {
      key: 'updateToolbarFlexibleState_',
      value: function updateToolbarFlexibleState_(flexibleExpansionRatio) {
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        if (flexibleExpansionRatio === 1) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        } else if (flexibleExpansionRatio === 0) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        }
      }
    }, {
      key: 'updateToolbarFixedState_',
      value: function updateToolbarFixedState_(scrollTop) {
        var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
        this.adapter_.setStyle('transform', 'translateY(' + -translateDistance + 'px)');

        if (translateDistance === this.calculations_.maxTranslateYDistance) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        } else {
          this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        }
      }
    }, {
      key: 'updateFlexibleRowElementStyles_',
      value: function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
        if (this.fixed_) {
          var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
          this.adapter_.setStyleForFlexibleRowElement('height', height + this.calculations_.toolbarRowHeight + 'px');
        }
        if (this.useFlexDefaultBehavior_) {
          this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
        }
      }
    }, {
      key: 'updateElementStylesDefaultBehavior_',
      value: function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
        var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
        var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
        var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;

        this.adapter_.setStyleForTitleElement('font-size', currentTitleSize + 'rem');
      }
    }]);
    return MDCToolbarFoundation;
  }(MDCFoundation);

  var mdcToolbar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('header', { staticClass: "mdc-toolbar-wrapper" }, [_c('div', { ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, [_vm._t("default")], 2), _vm._v(" "), _vm.fixed || _vm.waterfall || _vm.fixedLastrow ? _c('div', { ref: "fixed-adjust", staticClass: "mdc-toolbar-fixed-adjust", style: _vm.adjustStyles }) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-toolbar',
    props: {
      fixed: Boolean,
      waterfall: Boolean,
      'fixed-lastrow': Boolean,
      flexible: Boolean,
      'flexible-default': { type: Boolean, default: true }
    },
    data: function data() {
      return {
        rootClasses: {
          'mdc-toolbar': true,
          'mdc-toolbar--fixed': this.fixed || this.waterfall || this.fixedLastrow,
          'mdc-toolbar--waterfall': this.waterfall,
          'mdc-toolbar--fixed-lastrow-only': this.fixedLastrow,
          'mdc-toolbar--flexible': this.flexible,
          'mdc-toolbar--flexible-default-behavior': this.flexible && this.flexibleDefault
        },
        rootStyles: {},
        adjustStyles: {
          // to avoid top margin collapse with :after el
          // 0.1 px should be rounded to 0px
          // TODO: find a better trick
          // height: '0.1px'
        },
        foundation: null
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCToolbarFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        getViewportWidth: function getViewportWidth() {
          return window.innerWidth;
        },
        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getOffsetHeight: function getOffsetHeight() {
          return _this.$refs.root.offsetHeight;
        },
        getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
          return el ? el.offsetHeight : undefined;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        setStyleForTitleElement: function setStyleForTitleElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.TITLE_SELECTOR);
          if (el) el.style.setProperty(property, value);
        },
        setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
          if (el) el.style.setProperty(property, value);
        },
        setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
          _this.$set(_this.adjustStyles, property, value);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcToolbarRow = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-toolbar-row mdc-toolbar__row" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-row'
  };

  var mdcToolbarSection = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-toolbar-section mdc-toolbar__section", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-section',
    props: {
      'align-start': Boolean,
      'align-end': Boolean,
      'shrink-to-fit': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-toolbar__section--align-start': this.alignStart,
          'mdc-toolbar__section--align-end': this.alignEnd,
          'mdc-toolbar__section--shrink-to-fit': this.shrinkToFit
        }
      };
    }
  };

  var mdcToolbarMenuIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', _vm._g({ staticClass: "mdc-toolbar-menu-icon mdc-toolbar__menu-icon", class: { 'material-icons': !!_vm.icon } }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-menu-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: { type: String, default: 'menu' }
    }
  };

  var mdcToolbarTitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', _vm._g({ staticClass: "mdc-toolbar-title mdc-toolbar__title" }, _vm.listeners), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-title',
    mixins: [DispatchEventMixin]
  };

  var mdcToolbarIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', _vm._g({ staticClass: "mdc-toolbar-icon mdc-toolbar__icon", class: { 'material-icons': !!_vm.icon } }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    }
  };

  var VueMDCToolbar = BasePlugin({
    mdcToolbar: mdcToolbar,
    mdcToolbarRow: mdcToolbarRow,
    mdcToolbarSection: mdcToolbarSection,
    mdcToolbarMenuIcon: mdcToolbarMenuIcon,
    mdcToolbarTitle: mdcToolbarTitle,
    mdcToolbarIcon: mdcToolbarIcon
  });

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$23 = {
    FIXED_CLASS: 'mdc-top-app-bar--fixed',
    FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
    SHORT_CLASS: 'mdc-top-app-bar--short',
    SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
    SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed'
  };

  /** @enum {number} */
  var numbers$7 = {
    DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
    MAX_TOP_APP_BAR_HEIGHT: 128
  };

  /** @enum {string} */
  var strings$23 = {
    ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
    NAVIGATION_EVENT: 'MDCTopAppBar:nav',
    NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
    ROOT_SELECTOR: '.mdc-top-app-bar',
    TITLE_SELECTOR: '.mdc-top-app-bar__title'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Top App Bar
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Top App Bar into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTopAppBarAdapter = function () {
    function MDCTopAppBarAdapter() {
      classCallCheck(this, MDCTopAppBarAdapter);
    }

    createClass(MDCTopAppBarAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root Element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets the specified inline style property on the root Element to the given value.
       * @param {string} property
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(property, value) {}

      /**
       * Gets the height of the top app bar.
       * @return {number}
       */

    }, {
      key: "getTopAppBarHeight",
      value: function getTopAppBarHeight() {}

      /**
       * Registers an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerNavigationIconInteractionHandler",
      value: function registerNavigationIconInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterNavigationIconInteractionHandler",
      value: function deregisterNavigationIconInteractionHandler(type, handler) {}

      /**
       * Emits an event when the navigation icon is clicked.
       */

    }, {
      key: "notifyNavigationIconClicked",
      value: function notifyNavigationIconClicked() {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerScrollHandler",
      value: function registerScrollHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterScrollHandler",
      value: function deregisterScrollHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /** @return {number} */

    }, {
      key: "getViewportScrollY",
      value: function getViewportScrollY() {}

      /** @return {number} */

    }, {
      key: "getTotalActionItems",
      value: function getTotalActionItems() {}
    }]);
    return MDCTopAppBarAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
   */

  var MDCTopAppBarBaseFoundation = function (_MDCFoundation) {
    inherits(MDCTopAppBarBaseFoundation, _MDCFoundation);
    createClass(MDCTopAppBarBaseFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$23;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$23;
      }

      /** @return enum {number} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$7;
      }

      /**
       * {@see MDCTopAppBarAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTopAppBarAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTopAppBarAdapter} */{
            hasClass: function hasClass() /* className: string */{},
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            setStyle: function setStyle() /* property: string, value: string */{},
            getTopAppBarHeight: function getTopAppBarHeight() {},
            registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
            notifyNavigationIconClicked: function notifyNavigationIconClicked() {},
            registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
            deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            getViewportScrollY: function getViewportScrollY() {
              return (/* number */0
              );
            },
            getTotalActionItems: function getTotalActionItems() {
              return (/* number */0
              );
            }
          }
        );
      }

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */

    }]);

    function MDCTopAppBarBaseFoundation( /** @type {!MDCTopAppBarAdapter} */adapter) {
      classCallCheck(this, MDCTopAppBarBaseFoundation);

      var _this = possibleConstructorReturn(this, (MDCTopAppBarBaseFoundation.__proto__ || Object.getPrototypeOf(MDCTopAppBarBaseFoundation)).call(this, _extends(MDCTopAppBarBaseFoundation.defaultAdapter, adapter)));

      _this.navClickHandler_ = function () {
        return _this.adapter_.notifyNavigationIconClicked();
      };
      return _this;
    }

    createClass(MDCTopAppBarBaseFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }]);
    return MDCTopAppBarBaseFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCTopAppBarBaseFoundation<!MDCShortTopAppBarFoundation>}
   * @final
   */

  var MDCShortTopAppBarFoundation = function (_MDCTopAppBarBaseFoun) {
    inherits(MDCShortTopAppBarFoundation, _MDCTopAppBarBaseFoun);

    /**
     * @param {!MDCTopAppBarAdapter} adapter
     */
    function MDCShortTopAppBarFoundation(adapter) {
      classCallCheck(this, MDCShortTopAppBarFoundation);

      // State variable for the current top app bar state
      var _this = possibleConstructorReturn(this, (MDCShortTopAppBarFoundation.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation)).call(this, adapter));

      _this.isCollapsed = false;

      _this.scrollHandler_ = function () {
        return _this.shortAppBarScrollHandler_();
      };
      return _this;
    }

    createClass(MDCShortTopAppBarFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'init', this).call(this);
        var isAlwaysCollapsed = this.adapter_.hasClass(cssClasses$23.SHORT_COLLAPSED_CLASS);

        if (this.adapter_.getTotalActionItems() > 0) {
          this.adapter_.addClass(cssClasses$23.SHORT_HAS_ACTION_ITEM_CLASS);
        }

        if (!isAlwaysCollapsed) {
          this.adapter_.registerScrollHandler(this.scrollHandler_);
          this.shortAppBarScrollHandler_();
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'destroy', this).call(this);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }

      /**
       * Scroll handler for applying/removing the collapsed modifier class
       * on the short top app bar.
       * @private
       */

    }, {
      key: 'shortAppBarScrollHandler_',
      value: function shortAppBarScrollHandler_() {
        var currentScroll = this.adapter_.getViewportScrollY();

        if (currentScroll <= 0) {
          if (this.isCollapsed) {
            this.adapter_.removeClass(cssClasses$23.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = false;
          }
        } else {
          if (!this.isCollapsed) {
            this.adapter_.addClass(cssClasses$23.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = true;
          }
        }
      }
    }]);
    return MDCShortTopAppBarFoundation;
  }(MDCTopAppBarBaseFoundation);

  var mdcTopAppBar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('header', _vm._g({ ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, _vm.$listeners), [_c('div', { staticClass: "mdc-top-app-bar__row" }, [_c('section', { staticClass: "mdc-top-app-bar__section mdc-top-app-bar__section--align-start" }, [_vm.haveNavigationIcon ? _c('a', _vm._g({ ref: "navigationIcon", class: _vm.naviconClasses, attrs: { "href": "#" } }, _vm.listeners), [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), !!_vm.title ? _c('span', { staticClass: "mdc-top-app-bar__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e()]), _vm._v(" "), _vm.$slots.default ? _c('section', { staticClass: "mdc-top-app-bar__section mdc-top-app-bar__section--align-end" }, [_vm._t("default")], 2) : _vm._e()])]);
    }, staticRenderFns: [],
    name: 'mdc-top-app-bar',
    mixins: [DispatchEventMixin],
    props: {
      short: Boolean,
      shortCollapsed: Boolean,
      prominent: Boolean,
      fixed: Boolean,
      title: String,
      icon: {
        type: String,
        default: 'menu'
      },
      iconClasses: Object,
      dense: Boolean
    },
    data: function data() {
      return {
        rootStyles: {},
        rootClasses: {
          'mdc-top-app-bar': true,
          'mdc-top-app-bar--dense': this.dense,
          'mdc-top-app-bar--short': this.short,
          'mdc-top-app-bar--short-collapsed': this.shortCollapsed,
          'mdc-top-app-bar--prominent': this.prominent,
          'mdc-top-app-bar--fixed': this.fixed
        },
        foundation: null
      };
    },

    computed: {
      haveNavigationIcon: function haveNavigationIcon() {
        return !!this.icon || this.iconClasses;
      },
      naviconClasses: function naviconClasses() {
        return _extends({
          'mdc-top-app-bar__navigation-icon': true,
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    },
    mounted: function mounted() {
      var _this = this;

      var adapter = {
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        getTopAppBarHeight: function getTopAppBarHeight() {
          return _this.$el.clientHeight;
        },
        registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.addEventListener(type, handler);
          }
        },
        deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.removeEventListener(type, handler);
          }
        },
        notifyNavigationIconClicked: function notifyNavigationIconClicked() {
          _this.$emit('nav');
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },

        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getTotalActionItems: function getTotalActionItems() {
          return _this.$refs.root.querySelectorAll(MDCTopAppBarBaseFoundation.strings.ACTION_ITEM_SELECTOR).length;
        }
      };

      this.foundation = this.short ? new MDCShortTopAppBarFoundation(adapter) : new MDCTopAppBarBaseFoundation(adapter);

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcTopAppBarAction = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', _vm._g({ staticClass: "mdc-top-app-bar-action mdc-top-app-bar--action mdc-top-app-bar__action-item", class: _vm.actioniconClasses, attrs: { "href": "#" } }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-top-app-bar-action',
    mixins: [DispatchEventMixin, RippleMixin],
    props: {
      icon: String,
      iconClasses: Object
    },
    computed: {
      actioniconClasses: function actioniconClasses() {
        return _extends({
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    }
  };

  var VueMDCTopAppBar = BasePlugin({
    mdcTopAppBar: mdcTopAppBar,
    mdcTopAppBarAction: mdcTopAppBarAction
  });

  var typos = ['headline1', 'headline2', 'headline3', 'headline4', 'headline5', 'headline6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'caption', 'button', 'overline'];

  var mdcTypoMixin = function mdcTypoMixin(name) {
    return {
      render: function render(createElement) {
        var _class;

        return createElement(this.tag, {
          class: (_class = {
            'mdc-typo': true
          }, defineProperty(_class, name, true), defineProperty(_class, 'mdc-typography--' + this.typo, true), _class),
          attrs: this.$attrs,
          on: this.$listeners
        }, this.$slots.default);
      }
    };
  };

  function mdcTypoPropMixin(defaultTag, defaultTypo, validTypos) {
    return {
      props: {
        tag: {
          type: String,
          default: defaultTag
        },
        typo: {
          type: String,
          default: defaultTypo,
          validator: function validator(value) {
            return validTypos.indexOf(value) !== -1;
          }
        }
      }
    };
  }

  var mdcTextSection = {
    name: 'mdc-text-section',
    props: {
      tag: {
        type: String,
        default: 'section'
      }
    },
    render: function render(createElement) {
      return createElement(this.tag, {
        class: {
          'mdc-typography': true,
          'mdc-text-section': true
        },
        attrs: this.$attrs,
        on: this.$listeners
      }, this.$slots.default);
    }
  };

  var mdcText = {
    name: 'mdc-text',
    mixins: [mdcTypoMixin('mdc-text'), mdcTypoPropMixin('p', 'body1', typos)]
  };

  var mdcDisplay = {
    name: 'mdc-display',
    mixins: [mdcTypoMixin('mdc-display'), mdcTypoPropMixin('h1', 'headline4', ['headline4', 'headline3', 'headline2', 'headline1'])]
  };

  var mdcHeadline = {
    name: 'mdc-headline',
    mixins: [mdcTypoMixin('mdc-headline'), mdcTypoPropMixin('h2', 'headline5', ['headline5'])]
  };

  var mdcTitle = {
    name: 'mdc-title',
    mixins: [mdcTypoMixin('mdc-title'), mdcTypoPropMixin('h3', 'headline6', ['headline6'])]
  };

  var mdcSubHeading = {
    name: 'mdc-subheading',
    mixins: [mdcTypoMixin('mdc-subheading'), mdcTypoPropMixin('h4', 'subtitle2', ['subtitle1', 'subtitle2'])]
  };

  var mdcBody = {
    name: 'mdc-body',
    mixins: [mdcTypoMixin('mdc-body'), mdcTypoPropMixin('p', 'body1', ['body1', 'body2'])]
  };

  var mdcCaption = {
    name: 'mdc-caption',
    mixins: [mdcTypoMixin('mdc-caption'), mdcTypoPropMixin('span', 'caption', ['caption'])]
  };

  var VueMDCTypography = BasePlugin({
    mdcTextSection: mdcTextSection,
    mdcText: mdcText,
    mdcBody: mdcBody,
    mdcCaption: mdcCaption,
    mdcDisplay: mdcDisplay,
    mdcHeadline: mdcHeadline,
    mdcSubHeading: mdcSubHeading,
    mdcTitle: mdcTitle
  });

  //

  var plugin = {
    version: '0.15.4',
    install: function install(vm) {
      vm.use(VueMDCButton);
      vm.use(VueMDCCard);
      vm.use(VueMDCCheckbox);
      vm.use(VueMDCChipSet);
      vm.use(VueMDCDialog);
      vm.use(VueMDCDrawer);
      vm.use(VueMDCElevation);
      vm.use(VueMDCFab);
      vm.use(VueMDCGridList);
      vm.use(VueMDCIcon);
      vm.use(VueMDCIconToggle);
      vm.use(VueMDCLayoutApp);
      vm.use(VueMDCLayoutGrid);
      vm.use(VueMDCLinearProgress);
      vm.use(VueMDCList);
      vm.use(VueMDCMenu);
      vm.use(VueMDCRadio);
      vm.use(VueMDCRipple);
      vm.use(VueMDCSelect);
      vm.use(VueMDCSlider);
      vm.use(VueMDCSnackbar);
      vm.use(VueMDCSwitch);
      vm.use(VueMDCTabs);
      vm.use(VueMDCTextfield);
      vm.use(VueMDCTheme);
      vm.use(VueMDCToolbar);
      vm.use(VueMDCTopAppBar);
      vm.use(VueMDCTypography);
    }
  };

  autoInit(plugin);

  return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1kYy1hZGFwdGVyLmpzIiwic291cmNlcyI6WyIuLi9jb21wb25lbnRzL2Jhc2UvYXBwbHktcGFzc2l2ZS5qcyIsIi4uL2NvbXBvbmVudHMvYmFzZS9hdXRvLWluaXQuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvYmFzZS1wbHVnaW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWVsZW1lbnQuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWxpbmsuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWV2ZW50LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1idXR0b24uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWljb24uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvZGlzcGF0Y2gtZXZlbnQtbWl4aW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvZGlzcGF0Y2gtZm9jdXMtbWl4aW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvdW5pcXVlaWQtbWl4aW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS91dGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL21kYy1yaXBwbGUtYmFzZS5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL21kYy1yaXBwbGUudnVlIiwiLi4vY29tcG9uZW50cy9yaXBwbGUvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2J1dHRvbi9tZGMtYnV0dG9uLWJhc2UudnVlIiwiLi4vY29tcG9uZW50cy9idXR0b24vbWRjLWJ1dHRvbi52dWUiLCIuLi9jb21wb25lbnRzL2J1dHRvbi9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtcHJpbWFyeS1hY3Rpb24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLW1lZGlhLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1oZWFkZXIudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXRpdGxlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1zdWJ0aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtdGV4dC52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9ucy52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1idXR0b24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1pY29ucy52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9uLWljb24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGVja2JveC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zvcm0tZmllbGQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvY2hlY2tib3gvbWRjLWNoZWNrYm94LnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2hlY2tib3gvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvY2hpcHMvbWRjLWNoaXAudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAtc2V0L2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2NoaXBzL21kYy1jaGlwLXNldC52dWUiLCIuLi9jb21wb25lbnRzL2NoaXBzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvdXRpbC5qcyIsIi4uL2NvbXBvbmVudHMvZGlhbG9nL21kYy1kaWFsb2cudnVlIiwiLi4vY29tcG9uZW50cy9kaWFsb2cvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtcGVybWFuZW50LWRyYXdlci52dWUiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9zbGlkYWJsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9zbGlkYWJsZS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3BlcnNpc3RlbnQvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3V0aWwuanMiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtcGVyc2lzdGVudC1kcmF3ZXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvdGVtcG9yYXJ5L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3RlbXBvcmFyeS9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXRlbXBvcmFyeS1kcmF3ZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWxheW91dC52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWhlYWRlci52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWxpc3QudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1pdGVtLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvZWxldmF0aW9uL21kYy1lbGV2YXRpb24udnVlIiwiLi4vY29tcG9uZW50cy9lbGV2YXRpb24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2ZhYi9tZGMtZmFiLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZmFiL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9ncmlkLWxpc3QvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9ncmlkLWxpc3QvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvZ3JpZC1saXN0L21kYy1ncmlkLWxpc3QudnVlIiwiLi4vY29tcG9uZW50cy9ncmlkLWxpc3QvbWRjLWdyaWQtdGlsZS52dWUiLCIuLi9jb21wb25lbnRzL2dyaWQtbGlzdC9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvaWNvbi9tZGMtaWNvbi52dWUiLCIuLi9jb21wb25lbnRzL2ljb24vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvaWNvbi10b2dnbGUvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvaWNvbi10b2dnbGUvbWRjLWljb24tdG9nZ2xlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvaWNvbi10b2dnbGUvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2xheW91dC1hcHAvbWRjLWxheW91dC1hcHAudnVlIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtYXBwL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtZ3JpZC9tZGMtbGF5b3V0LWdyaWQudnVlIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtZ3JpZC9tZGMtbGF5b3V0LWNlbGwudnVlIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtZ3JpZC9tZGMtbGF5b3V0LWlubmVyLWdyaWQudnVlIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtZ3JpZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZWFyLXByb2dyZXNzL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZWFyLXByb2dyZXNzL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2xpbmVhci1wcm9ncmVzcy9tZGMtbGluZWFyLXByb2dyZXNzLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGluZWFyLXByb2dyZXNzL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1pdGVtLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1ncm91cC52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAtaGVhZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1ncm91cC1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51L3V0aWwuanMiLCIuLi9jb21wb25lbnRzL21lbnUvbWRjLW1lbnUudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWl0ZW0udnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWFuY2hvci52dWUiLCIuLi9jb21wb25lbnRzL21lbnUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmFkaW8vZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvcmFkaW8vbWRjLXJhZGlvLnZ1ZSIsIi4uL2NvbXBvbmVudHMvcmFkaW8vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1zZWxlY3QudnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NsaWRlci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NsaWRlci9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbGlkZXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc2xpZGVyL21kYy1zbGlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9zbGlkZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NuYWNrYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc25hY2tiYXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc25hY2tiYXIvbWRjLXNuYWNrYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc25hY2tiYXIvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL3N3aXRjaC9tZGMtc3dpdGNoLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc3dpdGNoL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3RhYnMvbWRjLXRhYi52dWUiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90YWJzL21kYy10YWItYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdGFicy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbm90Y2hlZC1vdXRsaW5lL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90ZXh0ZmllbGQvbWRjLXRleHRmaWVsZC52dWUiLCIuLi9jb21wb25lbnRzL3RleHRmaWVsZC9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvdGhlbWUvbWRjLXRoZW1lLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdGhlbWUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3Rvb2xiYXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b29sYmFyL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXIudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLXJvdy52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItc2VjdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItbWVudS1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci10aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItaWNvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RvcC1hcHAtYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvc2hvcnQvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdG9wLWFwcC1iYXIvbWRjLXRvcC1hcHAtYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9wLWFwcC1iYXIvbWRjLXRvcC1hcHAtYmFyLWFjdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3RvcC1hcHAtYmFyL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy90eXBvZ3JhcGh5L21kYy10eXBvZ3JhcGh5LmpzIiwiLi4vY29tcG9uZW50cy90eXBvZ3JhcGh5L2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHN1cHBvcnRzUGFzc2l2ZV9cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZVxuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtcbiAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSB7IHBhc3NpdmU6IHRydWUgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vZW1wdHlcbiAgICB9XG5cbiAgICBzdXBwb3J0c1Bhc3NpdmVfID0gaXNTdXBwb3J0ZWRcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYXV0b0luaXQocGx1Z2luKSB7XG4gIC8vIEF1dG8taW5zdGFsbFxuICBsZXQgX1Z1ZSA9IG51bGxcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgX1Z1ZSA9IHdpbmRvdy5WdWVcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8qZ2xvYmFsIGdsb2JhbCovXG4gICAgX1Z1ZSA9IGdsb2JhbC5WdWVcbiAgfVxuICBpZiAoX1Z1ZSkge1xuICAgIF9WdWUudXNlKHBsdWdpbilcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIEJhc2VQbHVnaW4oY29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdfX1ZFUlNJT05fXycsXG4gICAgaW5zdGFsbDogdm0gPT4ge1xuICAgICAgZm9yIChsZXQga2V5IGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNba2V5XVxuICAgICAgICB2bS5jb21wb25lbnQoY29tcG9uZW50Lm5hbWUsIGNvbXBvbmVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHNcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUVsZW1lbnQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcihjcmVhdGVFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICBjb250ZXh0LnByb3BzLmlzIHx8IGNvbnRleHQucHJvcHMudGFnIHx8ICdkaXYnLFxuICAgICAgY29udGV4dC5kYXRhLFxuICAgICAgY29udGV4dC5jaGlsZHJlblxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tRWxlbWVudE1peGluID0ge1xuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tRWxlbWVudFxuICB9XG59XG4iLCJleHBvcnQgY29uc3QgQ3VzdG9tTGluayA9IHtcbiAgbmFtZTogJ2N1c3RvbS1saW5rJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICB0YWc6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnYScgfSxcbiAgICBsaW5rOiBPYmplY3RcbiAgfSxcbiAgcmVuZGVyKGgsIGNvbnRleHQpIHtcbiAgICBsZXQgZWxlbWVudFxuICAgIGxldCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC5kYXRhKVxuXG4gICAgaWYgKGNvbnRleHQucHJvcHMubGluayAmJiBjb250ZXh0LnBhcmVudC4kcm91dGVyKSB7XG4gICAgICAvLyByb3V0ZXItbGluayBjYXNlXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wYXJlbnQuJHJvb3QuJG9wdGlvbnMuY29tcG9uZW50c1sncm91dGVyLWxpbmsnXVxuICAgICAgZGF0YS5wcm9wcyA9IE9iamVjdC5hc3NpZ24oeyB0YWc6IGNvbnRleHQucHJvcHMudGFnIH0sIGNvbnRleHQucHJvcHMubGluaylcbiAgICAgIGlmIChkYXRhLm9uLmNsaWNrKSB7XG4gICAgICAgIGRhdGEubmF0aXZlT24gPSB7IGNsaWNrOiBkYXRhLm9uLmNsaWNrIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWxlbWVudCBmYWxsYmFja1xuICAgICAgZWxlbWVudCA9IGNvbnRleHQucHJvcHMudGFnXG4gICAgfVxuXG4gICAgcmV0dXJuIGgoZWxlbWVudCwgZGF0YSwgY29udGV4dC5jaGlsZHJlbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tTGlua01peGluID0ge1xuICBwcm9wczoge1xuICAgIHRvOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGluaygpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudG8gJiYge1xuICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgIGV4YWN0OiB0aGlzLmV4YWN0LFxuICAgICAgICAgIGFwcGVuZDogdGhpcy5hcHBlbmQsXG4gICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlLFxuICAgICAgICAgIGFjdGl2ZUNsYXNzOiB0aGlzLmFjdGl2ZUNsYXNzLFxuICAgICAgICAgIGV4YWN0QWN0aXZlQ2xhc3M6IHRoaXMuZXhhY3RBY3RpdmVDbGFzc1xuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICB9LFxuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tTGlua1xuICB9XG59XG4iLCIvKiBnbG9iYWwgQ3VzdG9tRXZlbnQgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRDdXN0b21FdmVudChlbCwgZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgbGV0IGV2dFxuICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50JylcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpXG4gIH1cbiAgZWwuZGlzcGF0Y2hFdmVudChldnQpXG59XG4iLCJleHBvcnQgY29uc3QgQ3VzdG9tQnV0dG9uID0ge1xuICBuYW1lOiAnY3VzdG9tLWJ1dHRvbicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbGluazogT2JqZWN0XG4gIH0sXG4gIHJlbmRlcihoLCBjb250ZXh0KSB7XG4gICAgbGV0IGVsZW1lbnRcbiAgICBsZXQgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQuZGF0YSlcblxuICAgIGlmIChjb250ZXh0LnByb3BzLmxpbmsgJiYgY29udGV4dC5wYXJlbnQuJHJvdXRlcikge1xuICAgICAgLy8gcm91dGVyLWxpbmsgY2FzZVxuICAgICAgZWxlbWVudCA9IGNvbnRleHQucGFyZW50LiRyb290LiRvcHRpb25zLmNvbXBvbmVudHNbJ3JvdXRlci1saW5rJ11cbiAgICAgIGRhdGEucHJvcHMgPSBPYmplY3QuYXNzaWduKHsgdGFnOiBjb250ZXh0LnByb3BzLnRhZyB9LCBjb250ZXh0LnByb3BzLmxpbmspXG4gICAgICBkYXRhLmF0dHJzLnJvbGUgPSAnYnV0dG9uJ1xuICAgICAgaWYgKGRhdGEub24uY2xpY2spIHtcbiAgICAgICAgZGF0YS5uYXRpdmVPbiA9IHsgY2xpY2s6IGRhdGEub24uY2xpY2sgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLmhyZWYpIHtcbiAgICAgIC8vIGhyZWYgY2FzZVxuICAgICAgZWxlbWVudCA9ICdhJ1xuICAgICAgZGF0YS5hdHRycy5yb2xlID0gJ2J1dHRvbidcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnV0dG9uIGZhbGxiYWNrXG4gICAgICBlbGVtZW50ID0gJ2J1dHRvbidcbiAgICB9XG5cbiAgICByZXR1cm4gaChlbGVtZW50LCBkYXRhLCBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21CdXR0b25NaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgdG86IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmdcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsaW5rKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy50byAmJiB7XG4gICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICAgICAgYXBwZW5kOiB0aGlzLmFwcGVuZCxcbiAgICAgICAgICByZXBsYWNlOiB0aGlzLnJlcGxhY2UsXG4gICAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMuYWN0aXZlQ2xhc3MsXG4gICAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogdGhpcy5leGFjdEFjdGl2ZUNsYXNzXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21CdXR0b25cbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RJY29uUHJvcChpY29uUHJvcCkge1xuICBpZiAodHlwZW9mIGljb25Qcm9wID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7ICdtYXRlcmlhbC1pY29ucyc6IHRydWUgfSxcbiAgICAgIGNvbnRlbnQ6IGljb25Qcm9wXG4gICAgfVxuICB9IGVsc2UgaWYgKGljb25Qcm9wIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NlczogaWNvblByb3AucmVkdWNlKFxuICAgICAgICAocmVzdWx0LCB2YWx1ZSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW3ZhbHVlXTogdHJ1ZSB9KSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGljb25Qcm9wID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiBpY29uUHJvcC5jbGFzc05hbWVcbiAgICAgICAgLnNwbGl0KCcgJylcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAocmVzdWx0LCB2YWx1ZSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW3ZhbHVlXTogdHJ1ZSB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApLFxuICAgICAgY29udGVudDogaWNvblByb3AudGV4dENvbnRlbnRcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBEaXNwYXRjaEV2ZW50TWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgZXZlbnQ6IFN0cmluZyxcbiAgICAnZXZlbnQtdGFyZ2V0JzogT2JqZWN0LFxuICAgICdldmVudC1hcmdzJzogQXJyYXlcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGRpc3BhdGNoRXZlbnQoZXZ0KSB7XG4gICAgICBldnQgJiYgdGhpcy4kZW1pdChldnQudHlwZSwgZXZ0KVxuICAgICAgaWYgKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZXZlbnRUYXJnZXQgfHwgdGhpcy4kcm9vdFxuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZXZlbnRBcmdzIHx8IFtdXG4gICAgICAgIHRhcmdldC4kZW1pdCh0aGlzLmV2ZW50LCAuLi5hcmdzKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzLiRsaXN0ZW5lcnMsXG4gICAgICAgIGNsaWNrOiBlID0+IHRoaXMuZGlzcGF0Y2hFdmVudChlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRm9jdXNNaXhpbiA9IHtcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4geyBoYXNGb2N1czogZmFsc2UgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlXG4gICAgfSxcbiAgICBvbk1vdXNlVXAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZVxuICAgIH0sXG4gICAgb25Gb2N1c0V2ZW50KCkge1xuICAgICAgLy8gZGlzcGF0Y2ggYXN5bmMgdG8gbGV0IHRpbWUgdG8gb3RoZXIgZm9jdXMgZXZlbnQgdG8gcHJvcGFnYXRlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGlzcGF0Y2hGb2N1c0V2ZW50KCksIDApXG4gICAgfSxcbiAgICBvbkJsdXJFdmVudCgpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGFzeW5jIHRvIGxldCB0aW1lIHRvIG90aGVyIGZvY3VzIGV2ZW50IHRvIHByb3BhZ2F0ZVxuICAgICAgLy8gYWxzbyBmaWx0dXIgYmx1ciBpZiBtb3VzZWRvd25cbiAgICAgIHRoaXMuX2FjdGl2ZSB8fCBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGlzcGF0Y2hGb2N1c0V2ZW50KCksIDApXG4gICAgfSxcbiAgICBkaXNwYXRjaEZvY3VzRXZlbnQoKSB7XG4gICAgICBsZXQgaGFzRm9jdXMgPVxuICAgICAgICB0aGlzLiRlbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fFxuICAgICAgICB0aGlzLiRlbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgICAgaWYgKGhhc0ZvY3VzICE9IHRoaXMuaGFzRm9jdXMpIHtcbiAgICAgICAgdGhpcy4kZW1pdChoYXNGb2N1cyA/ICdmb2N1cycgOiAnYmx1cicpXG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSBoYXNGb2N1c1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLm9uRm9jdXNFdmVudClcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMub25CbHVyRXZlbnQpXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bilcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApXG4gIH1cbn1cbiIsImxldCB1aWRfID0gMFxuXG5leHBvcnQgY29uc3QgVk1BVW5pcXVlSWRNaXhpbiA9IHtcbiAgYmVmb3JlQ3JlYXRlKCkge1xuICAgIHRoaXMudm1hX3VpZF8gPSBgX3ZtYV8ke3VpZF8rK31gXG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKi9cbmNsYXNzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVte2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGV2ZXJ5XG4gICAgLy8gQ1NTIGNsYXNzIHRoZSBmb3VuZGF0aW9uIGNsYXNzIG5lZWRzIGFzIGEgcHJvcGVydHkuIGUuZy4ge0FDVElWRTogJ21kYy1jb21wb25lbnQtLWFjdGl2ZSd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBzZW1hbnRpYyBzdHJpbmdzIGFzIGNvbnN0YW50cy4gZS5nLiB7QVJJQV9ST0xFOiAndGFibGlzdCd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBvZiBpdHMgc2VtYW50aWMgbnVtYmVycyBhcyBjb25zdGFudHMuIGUuZy4ge0FOSU1BVElPTl9ERUxBWV9NUzogMzUwfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshT2JqZWN0fSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gbWF5IGNob29zZSB0byBpbXBsZW1lbnQgdGhpcyBnZXR0ZXIgaW4gb3JkZXIgdG8gcHJvdmlkZSBhIGNvbnZlbmllbnRcbiAgICAvLyB3YXkgb2Ygdmlld2luZyB0aGUgbmVjZXNzYXJ5IG1ldGhvZHMgb2YgYW4gYWRhcHRlci4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGFkYXB0ZXJcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0E9fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyID0ge30pIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUF9ICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKHJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBkZS1pbml0aWFsaXphdGlvbiByb3V0aW5lcyAoZGUtcmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJpcHBsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBDU1MgdmFyaWFibGVzXG4gKiAtIHBvc2l0aW9uXG4gKiAtIGRpbWVuc2lvbnNcbiAqIC0gc2Nyb2xsIHBvc2l0aW9uXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHVuYm91bmRlZCwgYWN0aXZlIGFuZCBkaXNhYmxlZCBzdGF0ZXNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUFkYXB0ZXIge1xuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzVW5ib3VuZGVkKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlQWN0aXZlKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlRGlzYWJsZWQoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXQgKi9cbiAgY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJOYW1lXG4gICAqIEBwYXJhbSB7P251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAqL1xuICB1cGRhdGVDc3NWYXJpYWJsZSh2YXJOYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVCb3VuZGluZ1JlY3QoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSAqL1xuICBnZXRXaW5kb3dQYWdlT2Zmc2V0KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICAvLyBSaXBwbGUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIFwicm9vdFwiIGNvbXBvbmVudCBpcyByZWFsbHkgYSBcIm1peGluXCIgb2Ygc29ydHMsXG4gIC8vIGdpdmVuIHRoYXQgaXQncyBhbiAndXBncmFkZScgdG8gYW4gZXhpc3RpbmcgY29tcG9uZW50LiBUaGF0IGJlaW5nIHNhaWQgaXQgaXMgdGhlIHJvb3RcbiAgLy8gQ1NTIGNsYXNzIHRoYXQgYWxsIG90aGVyIENTUyBjbGFzc2VzIGRlcml2ZSBmcm9tLlxuICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXG4gIFVOQk9VTkRFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLXVuYm91bmRlZCcsXG4gIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxuICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcbiAgRkdfREVBQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1kZWFjdGl2YXRpb24nLFxufTtcblxuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVkFSX0xFRlQ6ICctLW1kYy1yaXBwbGUtbGVmdCcsXG4gIFZBUl9UT1A6ICctLW1kYy1yaXBwbGUtdG9wJyxcbiAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXG4gIFZBUl9GR19TQ0FMRTogJy0tbWRjLXJpcHBsZS1mZy1zY2FsZScsXG4gIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0JyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9FTkQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCcsXG59O1xuXG5jb25zdCBudW1iZXJzID0ge1xuICBQQURESU5HOiAxMCxcbiAgSU5JVElBTF9PUklHSU5fU0NBTEU6IDAuNixcbiAgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM6IDIyNSwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtdHJhbnNsYXRlLWR1cmF0aW9uIChpLmUuIGFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtZmFkZS1vdXQtZHVyYXRpb24gKGkuZS4gZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgVEFQX0RFTEFZX01TOiAzMDAsIC8vIERlbGF5IGJldHdlZW4gdG91Y2ggYW5kIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgb24gdG91Y2ggZGV2aWNlc1xufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgQ1NTIGN1c3RvbSB2YXJpYWJsZSBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBhcHBseVBhc3NpdmUgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKSB7XG4gIC8vIERldGVjdCB2ZXJzaW9ucyBvZiBFZGdlIHdpdGggYnVnZ3kgdmFyKCkgc3VwcG9ydFxuICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzExNDk1NDQ4L1xuICBjb25zdCBkb2N1bWVudCA9IHdpbmRvd09iai5kb2N1bWVudDtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBub2RlLmNsYXNzTmFtZSA9ICdtZGMtcmlwcGxlLXN1cmZhY2UtLXRlc3QtZWRnZS12YXItYnVnJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAvLyBUaGUgYnVnIGV4aXN0cyBpZiA6OmJlZm9yZSBzdHlsZSBlbmRzIHVwIHByb3BhZ2F0aW5nIHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgLy8gQWRkaXRpb25hbGx5LCBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgbnVsbCBpbiBpZnJhbWVzIHdpdGggZGlzcGxheTogXCJub25lXCIgaW4gRmlyZWZveCxcbiAgLy8gYnV0IEZpcmVmb3ggaXMga25vd24gdG8gc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93T2JqLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGNvbnN0IGhhc1BzZXVkb1ZhckJ1ZyA9IGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BTdHlsZSA9PT0gJ3NvbGlkJztcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIGhhc1BzZXVkb1ZhckJ1Zztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSAhZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcztcbn1cblxuLy9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHtwYXNzaXZlOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBIVE1MRWxlbWVudFByb3RvdHlwZVxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudFByb3RvdHlwZSkge1xuICByZXR1cm4gW1xuICAgICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFFdmVudH0gZXZcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcGFnZU9mZnNldFxuICogQHBhcmFtIHshQ2xpZW50UmVjdH0gY2xpZW50UmVjdFxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKGV2LCBwYWdlT2Zmc2V0LCBjbGllbnRSZWN0KSB7XG4gIGNvbnN0IHt4LCB5fSA9IHBhZ2VPZmZzZXQ7XG4gIGNvbnN0IGRvY3VtZW50WCA9IHggKyBjbGllbnRSZWN0LmxlZnQ7XG4gIGNvbnN0IGRvY3VtZW50WSA9IHkgKyBjbGllbnRSZWN0LnRvcDtcblxuICBsZXQgbm9ybWFsaXplZFg7XG4gIGxldCBub3JtYWxpemVkWTtcbiAgLy8gRGV0ZXJtaW5lIHRvdWNoIHBvaW50IHJlbGF0aXZlIHRvIHRoZSByaXBwbGUgY29udGFpbmVyLlxuICBpZiAoZXYudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9IGVsc2Uge1xuICAgIG5vcm1hbGl6ZWRYID0gZXYucGFnZVggLSBkb2N1bWVudFg7XG4gICAgbm9ybWFsaXplZFkgPSBldi5wYWdlWSAtIGRvY3VtZW50WTtcbiAgfVxuXG4gIHJldHVybiB7eDogbm9ybWFsaXplZFgsIHk6IG5vcm1hbGl6ZWRZfTtcbn1cblxuZXhwb3J0IHtzdXBwb3J0c0Nzc1ZhcmlhYmxlcywgYXBwbHlQYXNzaXZlLCBnZXRNYXRjaGVzUHJvcGVydHksIGdldE5vcm1hbGl6ZWRFdmVudENvb3Jkc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge2dldE5vcm1hbGl6ZWRFdmVudENvb3Jkc30gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBpc0FjdGl2YXRlZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIGFjdGl2YXRpb25FdmVudDogRXZlbnQsXG4gKiAgIGlzUHJvZ3JhbW1hdGljOiAoYm9vbGVhbnx1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgQWN0aXZhdGlvblN0YXRlVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBkZWFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGZvY3VzOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGJsdXI6IChzdHJpbmd8dW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IExpc3RlbmVySW5mb1R5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCFFdmVudCksXG4gKiAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uKCFFdmVudCksXG4gKiAgIGZvY3VzOiBmdW5jdGlvbigpLFxuICogICBibHVyOiBmdW5jdGlvbigpXG4gKiB9fVxuICovXG5sZXQgTGlzdGVuZXJzVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB4OiBudW1iZXIsXG4gKiAgIHk6IG51bWJlclxuICogfX1cbiAqL1xubGV0IFBvaW50VHlwZTtcblxuLy8gQWN0aXZhdGlvbiBldmVudHMgcmVnaXN0ZXJlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIGVhY2ggaW5zdGFuY2UgZm9yIGFjdGl2YXRpb25cbmNvbnN0IEFDVElWQVRJT05fRVZFTlRfVFlQRVMgPSBbJ3RvdWNoc3RhcnQnLCAncG9pbnRlcmRvd24nLCAnbW91c2Vkb3duJywgJ2tleWRvd24nXTtcblxuLy8gRGVhY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIGRvY3VtZW50RWxlbWVudCB3aGVuIGEgcG9pbnRlci1yZWxhdGVkIGRvd24gZXZlbnQgb2NjdXJzXG5jb25zdCBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hlbmQnLCAncG9pbnRlcnVwJywgJ21vdXNldXAnXTtcblxuLy8gVHJhY2tzIGFjdGl2YXRpb25zIHRoYXQgaGF2ZSBvY2N1cnJlZCBvbiB0aGUgY3VycmVudCBmcmFtZSwgdG8gYXZvaWQgc2ltdWx0YW5lb3VzIG5lc3RlZCBhY3RpdmF0aW9uc1xuLyoqIEB0eXBlIHshQXJyYXk8IUV2ZW50VGFyZ2V0Pn0gKi9cbmxldCBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1JpcHBsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSaXBwbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IC8qIGJvb2xlYW4gLSBjYWNoZWQgKi8ge30sXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICgvKiB0YXJnZXQ6ICFFdmVudFRhcmdldCAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIENsaWVudFJlY3QgKi8ge30sXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAvKiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9ICovIHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUgeyFDbGllbnRSZWN0fSAqL1xuICAgIHRoaXMuZnJhbWVfID0gLyoqIEB0eXBlIHshQ2xpZW50UmVjdH0gKi8gKHt3aWR0aDogMCwgaGVpZ2h0OiAwfSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4UmFkaXVzXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuYWN0aXZhdGVfKGUpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuZGVhY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKD9FdmVudD0pfSAqL1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyXyA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICgpID0+IHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpXG4gICAgKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXG4gICAgICAoKSA9PiB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKVxuICAgICk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlcn19ICovXG4gICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ1NjYWxlXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHs/RXZlbnR9ICovXG4gICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIGNvbXB1dGUgdGhpcyBwcm9wZXJ0eSBzbyB0aGF0IHdlIGFyZSBub3QgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWVudFxuICAgKiB1bnRpbCB0aGUgcG9pbnQgaW4gdGltZSB3aGVyZSB0aGUgZm91bmRhdGlvbiByZXF1ZXN0cyBpdC4gVGhpcyBwcmV2ZW50cyBzY2VuYXJpb3Mgd2hlcmVcbiAgICogY2xpZW50LXNpZGUgZmVhdHVyZS1kZXRlY3Rpb24gbWF5IGhhcHBlbiB0b28gZWFybHksIHN1Y2ggYXMgd2hlbiBjb21wb25lbnRzIGFyZSByZW5kZXJlZCBvbiB0aGUgc2VydmVyXG4gICAqIGFuZCB0aGVuIGluaXRpYWxpemVkIGF0IG1vdW50IHRpbWUgb24gdGhlIGNsaWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzU3VwcG9ydGVkXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5icm93c2VyU3VwcG9ydHNDc3NWYXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9XG4gICAqL1xuICBkZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IGZhbHNlLFxuICAgICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiBmYWxzZSxcbiAgICAgIHdhc0VsZW1lbnRNYWRlQWN0aXZlOiBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb25FdmVudDogbnVsbCxcbiAgICAgIGlzUHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWdpc3RlclJvb3RIYW5kbGVyc18oKTtcblxuICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFJPT1QpO1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgICAgIC8vIFVuYm91bmRlZCByaXBwbGVzIG5lZWQgbGF5b3V0IGxvZ2ljIGFwcGxpZWQgaW1tZWRpYXRlbHkgdG8gc2V0IGNvb3JkaW5hdGVzIGZvciBib3RoIHNoYWRlIGFuZCByaXBwbGVcbiAgICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZhdGlvblRpbWVyXykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyXyk7XG4gICAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuICAgICAgY29uc3Qge0ZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG4gICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG5cbiAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhST09UKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoVU5CT1VOREVEKTtcbiAgICAgIHRoaXMucmVtb3ZlQ3NzVmFyc18oKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKGUpIHtcbiAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBkZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbW92ZUNzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtzdHJpbmdzfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4gICAgT2JqZWN0LmtleXMoc3RyaW5ncykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgaWYgKGsuaW5kZXhPZignVkFSXycpID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoc3RyaW5nc1trXSwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjdGl2YXRlXyhlKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgcmVhY3RpbmcgdG8gZm9sbG93LW9uIGV2ZW50cyBmaXJlZCBieSB0b3VjaCBkZXZpY2UgYWZ0ZXIgYW4gYWxyZWFkeS1wcm9jZXNzZWQgdXNlciBpbnRlcmFjdGlvblxuICAgIGNvbnN0IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ID0gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF87XG4gICAgY29uc3QgaXNTYW1lSW50ZXJhY3Rpb24gPSBwcmV2aW91c0FjdGl2YXRpb25FdmVudCAmJiBlICYmIHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50LnR5cGUgIT09IGUudHlwZTtcbiAgICBpZiAoaXNTYW1lSW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQgPSB0cnVlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA9IGUgPT09IG51bGw7XG4gICAgYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudCA9IGU7XG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA/IGZhbHNlIDogKFxuICAgICAgZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICdwb2ludGVyZG93bidcbiAgICApO1xuXG4gICAgY29uc3QgaGFzQWN0aXZhdGVkQ2hpbGQgPVxuICAgICAgZSAmJiBhY3RpdmF0ZWRUYXJnZXRzLmxlbmd0aCA+IDAgJiYgYWN0aXZhdGVkVGFyZ2V0cy5zb21lKCh0YXJnZXQpID0+IHRoaXMuYWRhcHRlcl8uY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpKTtcbiAgICBpZiAoaGFzQWN0aXZhdGVkQ2hpbGQpIHtcbiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlc2V0IGFjdGl2YXRpb24gc3RhdGUsIHdoaWxlIHByZXNlcnZpbmcgbG9naWMgdGhhdCBwcmV2ZW50cyB0b3VjaCBmb2xsb3ctb24gZXZlbnRzXG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlKSB7XG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzLnB1c2goLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChlLnRhcmdldCkpO1xuICAgICAgdGhpcy5yZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKTtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgPSB0aGlzLmNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpO1xuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIFJlc2V0IGFycmF5IG9uIG5leHQgZnJhbWUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgaGFzIGhhZCBhIGNoYW5jZSB0byBidWJibGUgdG8gcHJldmVudCBhbmNlc3RvciByaXBwbGVzXG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlICYmIChlLmtleSA9PT0gJyAnIHx8IGUua2V5Q29kZSA9PT0gMzIpKSB7XG4gICAgICAgIC8vIElmIHNwYWNlIHdhcyBwcmVzc2VkLCB0cnkgYWdhaW4gd2l0aGluIGFuIHJBRiBjYWxsIHRvIGRldGVjdCA6YWN0aXZlLCBiZWNhdXNlIGRpZmZlcmVudCBVQXMgcmVwb3J0XG4gICAgICAgIC8vIGFjdGl2ZSBzdGF0ZXMgaW5jb25zaXN0ZW50bHkgd2hlbiB0aGV5J3JlIGNhbGxlZCB3aXRoaW4gZXZlbnQgaGFuZGxpbmcgY29kZTpcbiAgICAgICAgLy8gLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MzU5NzFcbiAgICAgICAgLy8gLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjkzNzQxXG4gICAgICAgIC8vIFdlIHRyeSBmaXJzdCBvdXRzaWRlIHJBRiB0byBzdXBwb3J0IEVkZ2UsIHdoaWNoIGRvZXMgbm90IGV4aGliaXQgdGhpcyBwcm9ibGVtLCBidXQgd2lsbCBjcmFzaCBpZiBhIENTU1xuICAgICAgICAvLyB2YXJpYWJsZSBpcyBzZXQgd2l0aGluIGEgckFGIGNhbGxiYWNrIGZvciBhIHN1Ym1pdCBidXR0b24gaW50ZXJhY3Rpb24gKCMyMjQxKS5cbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKTtcbiAgICAgICAgaWYgKGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgLy8gUmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSBpbW1lZGlhdGVseSBpZiBlbGVtZW50IHdhcyBub3QgbWFkZSBhY3RpdmUuXG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLnR5cGUgPT09ICdrZXlkb3duJykgPyB0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZUFjdGl2ZSgpIDogdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYW5pbWF0ZUFjdGl2YXRpb25fKCkge1xuICAgIGNvbnN0IHtWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0RFQUNUSVZBVElPTl9USU1FT1VUX01TfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycztcblxuICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG5cbiAgICBsZXQgdHJhbnNsYXRlU3RhcnQgPSAnJztcbiAgICBsZXQgdHJhbnNsYXRlRW5kID0gJyc7XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgY29uc3Qge3N0YXJ0UG9pbnQsIGVuZFBvaW50fSA9IHRoaXMuZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpO1xuICAgICAgdHJhbnNsYXRlU3RhcnQgPSBgJHtzdGFydFBvaW50Lnh9cHgsICR7c3RhcnRQb2ludC55fXB4YDtcbiAgICAgIHRyYW5zbGF0ZUVuZCA9IGAke2VuZFBvaW50Lnh9cHgsICR7ZW5kUG9pbnQueX1weGA7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCB0cmFuc2xhdGVTdGFydCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX0VORCwgdHJhbnNsYXRlRW5kKTtcbiAgICAvLyBDYW5jZWwgYW55IG9uZ29pbmcgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gYW5pbWF0aW9uc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyk7XG4gICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG5cbiAgICAvLyBGb3JjZSBsYXlvdXQgaW4gb3JkZXIgdG8gcmUtdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXygpLCBERUFDVElWQVRJT05fVElNRU9VVF9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7e3N0YXJ0UG9pbnQ6IFBvaW50VHlwZSwgZW5kUG9pbnQ6IFBvaW50VHlwZX19XG4gICAqL1xuICBnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCkge1xuICAgIGNvbnN0IHthY3RpdmF0aW9uRXZlbnQsIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcn0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG5cbiAgICBsZXQgc3RhcnRQb2ludDtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyKSB7XG4gICAgICBzdGFydFBvaW50ID0gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKFxuICAgICAgICAvKiogQHR5cGUgeyFFdmVudH0gKi8gKGFjdGl2YXRpb25FdmVudCksXG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93UGFnZU9mZnNldCgpLCB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQb2ludCA9IHtcbiAgICAgICAgeDogdGhpcy5mcmFtZV8ud2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLmZyYW1lXy5oZWlnaHQgLyAyLFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2VudGVyIHRoZSBlbGVtZW50IGFyb3VuZCB0aGUgc3RhcnQgcG9pbnQuXG4gICAgc3RhcnRQb2ludCA9IHtcbiAgICAgIHg6IHN0YXJ0UG9pbnQueCAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogc3RhcnRQb2ludC55IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIGNvbnN0IGVuZFBvaW50ID0ge1xuICAgICAgeDogKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6ICh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICByZXR1cm4ge3N0YXJ0UG9pbnQsIGVuZFBvaW50fTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJvdGggd2hlbiBhIHBvaW50aW5nIGRldmljZSBpcyByZWxlYXNlZCwgYW5kIHdoZW4gdGhlIGFjdGl2YXRpb24gYW5pbWF0aW9uIGVuZHMuXG4gICAgLy8gVGhlIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gc2hvdWxkIG9ubHkgcnVuIGFmdGVyIGJvdGggb2YgdGhvc2Ugb2NjdXIuXG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge2hhc0RlYWN0aXZhdGlvblVYUnVuLCBpc0FjdGl2YXRlZH0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgY29uc3QgYWN0aXZhdGlvbkhhc0VuZGVkID0gaGFzRGVhY3RpdmF0aW9uVVhSdW4gfHwgIWlzQWN0aXZhdGVkO1xuXG4gICAgaWYgKGFjdGl2YXRpb25IYXNFbmRlZCAmJiB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8pIHtcbiAgICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB9LCBudW1iZXJzLkZHX0RFQUNUSVZBVElPTl9NUyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpIHtcbiAgICBjb25zdCB7RkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgfVxuXG4gIHJlc2V0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXy5hY3RpdmF0aW9uRXZlbnQ7XG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIC8vIFRvdWNoIGRldmljZXMgbWF5IGZpcmUgYWRkaXRpb25hbCBldmVudHMgZm9yIHRoZSBzYW1lIGludGVyYWN0aW9uIHdpdGhpbiBhIHNob3J0IHRpbWUuXG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzIGV2ZW50IHVudGlsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCBzdWJzZXF1ZW50IGV2ZW50cyBhcmUgZm9yIG5ldyBpbnRlcmFjdGlvbnMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IG51bGwsIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5UQVBfREVMQVlfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWFjdGl2YXRlXyhlKSB7XG4gICAgY29uc3QgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBzY2VuYXJpb3Mgc3VjaCBhcyB3aGVuIHlvdSBoYXZlIGEga2V5dXAgZXZlbnQgdGhhdCBibHVycyB0aGUgZWxlbWVudC5cbiAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gLyoqIEB0eXBlIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gKi8gKE9iamVjdC5hc3NpZ24oe30sIGFjdGl2YXRpb25TdGF0ZSkpO1xuXG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYykge1xuICAgICAgY29uc3QgZXZ0T2JqZWN0ID0gbnVsbDtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKGV2dE9iamVjdCwgc3RhdGUpKTtcbiAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfLmhhc0RlYWN0aXZhdGlvblVYUnVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhlLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZGVhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmRlYWN0aXZhdGVfKGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFuaW1hdGVEZWFjdGl2YXRpb25fKGUsIHt3YXNBY3RpdmF0ZWRCeVBvaW50ZXIsIHdhc0VsZW1lbnRNYWRlQWN0aXZlfSkge1xuICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgfHwgd2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmxheW91dEZyYW1lXykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZyYW1lXyA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KHRoaXMuZnJhbWVfLmhlaWdodCwgdGhpcy5mcmFtZV8ud2lkdGgpO1xuXG4gICAgLy8gU3VyZmFjZSBkaWFtZXRlciBpcyB0cmVhdGVkIGRpZmZlcmVudGx5IGZvciB1bmJvdW5kZWQgdnMuIGJvdW5kZWQgcmlwcGxlcy5cbiAgICAvLyBVbmJvdW5kZWQgcmlwcGxlIGRpYW1ldGVyIGlzIGNhbGN1bGF0ZWQgc21hbGxlciBzaW5jZSB0aGUgc3VyZmFjZSBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGJlIHBhZGRlZCBhcHByb3ByaWF0ZWx5XG4gICAgLy8gdG8gZXh0ZW5kIHRoZSBoaXRib3gsIGFuZCB0aGUgcmlwcGxlIGlzIGV4cGVjdGVkIHRvIG1lZXQgdGhlIGVkZ2VzIG9mIHRoZSBwYWRkZWQgaGl0Ym94ICh3aGljaCBpcyB0eXBpY2FsbHlcbiAgICAvLyBzcXVhcmUpLiBCb3VuZGVkIHJpcHBsZXMsIG9uIHRoZSBvdGhlciBoYW5kLCBhcmUgZnVsbHkgZXhwZWN0ZWQgdG8gZXhwYW5kIGJleW9uZCB0aGUgc3VyZmFjZSdzIGxvbmdlc3QgZGlhbWV0ZXJcbiAgICAvLyAoY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGlhZ29uYWwgcGx1cyBhIGNvbnN0YW50IHBhZGRpbmcpLCBhbmQgYXJlIGNsaXBwZWQgYXQgdGhlIHN1cmZhY2UncyBib3JkZXIgdmlhXG4gICAgLy8gYG92ZXJmbG93OiBoaWRkZW5gLlxuICAgIGNvbnN0IGdldEJvdW5kZWRSYWRpdXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuZnJhbWVfLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuZnJhbWVfLmhlaWdodCwgMikpO1xuICAgICAgcmV0dXJuIGh5cG90ZW51c2UgKyBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuUEFERElORztcbiAgICB9O1xuXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpID8gbWF4RGltIDogZ2V0Qm91bmRlZFJhZGl1cygpO1xuXG4gICAgLy8gUmlwcGxlIGlzIHNpemVkIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGxhcmdlc3QgZGltZW5zaW9uIG9mIHRoZSBzdXJmYWNlLCB0aGVuIHNjYWxlcyB1cCB1c2luZyBhIENTUyBzY2FsZSB0cmFuc2Zvcm1cbiAgICB0aGlzLmluaXRpYWxTaXplXyA9IG1heERpbSAqIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5JTklUSUFMX09SSUdJTl9TQ0FMRTtcbiAgICB0aGlzLmZnU2NhbGVfID0gdGhpcy5tYXhSYWRpdXNfIC8gdGhpcy5pbml0aWFsU2l6ZV87XG5cbiAgICB0aGlzLnVwZGF0ZUxheW91dENzc1ZhcnNfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdXBkYXRlTGF5b3V0Q3NzVmFyc18oKSB7XG4gICAgY29uc3Qge1xuICAgICAgVkFSX0ZHX1NJWkUsIFZBUl9MRUZULCBWQVJfVE9QLCBWQVJfRkdfU0NBTEUsXG4gICAgfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NJWkUsIGAke3RoaXMuaW5pdGlhbFNpemVffXB4YCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0NBTEUsIHRoaXMuZmdTY2FsZV8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgICB0b3A6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfTEVGVCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLmxlZnR9cHhgKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX1RPUCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLnRvcH1weGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHVuYm91bmRlZCAqL1xuICBzZXRVbmJvdW5kZWQodW5ib3VuZGVkKSB7XG4gICAgY29uc3Qge1VOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHVuYm91bmRlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4iLCJpbXBvcnQgTURDUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMnXG5pbXBvcnQge1xuICBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyxcbiAgZ2V0TWF0Y2hlc1Byb3BlcnR5LFxuICBhcHBseVBhc3NpdmVcbn0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS91dGlsJ1xuXG5leHBvcnQgY2xhc3MgUmlwcGxlQmFzZSBleHRlbmRzIE1EQ1JpcHBsZUZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IE1BVENIRVMoKSB7XG4gICAgLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG4gICAgcmV0dXJuIChcbiAgICAgIFJpcHBsZUJhc2UuX21hdGNoZXMgfHxcbiAgICAgIChSaXBwbGVCYXNlLl9tYXRjaGVzID0gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSkpXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIGlzU3VyZmFjZUFjdGl2ZShyZWYpIHtcbiAgICByZXR1cm4gcmVmW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICB9XG5cbiAgY29uc3RydWN0b3Iodm0sIG9wdGlvbnMpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdm0uJGVsW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2bS5kaXNhYmxlZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2bS4kc2V0KHZtLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdm0uJGRlbGV0ZSh2bS5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiB0YXJnZXQgPT4gdm0uJGVsLmNvbnRhaW5zKHRhcmdldCksXG4gICAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHZtLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB2bS4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgZXZ0VHlwZSxcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBldnRUeXBlLFxuICAgICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgICBhcHBseVBhc3NpdmUoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdm0uJHNldCh2bS5zdHlsZXMsIHZhck5hbWUsIHZhbHVlKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZtLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0V2luZG93UGFnZU9mZnNldDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUmlwcGxlTWl4aW4gPSB7XG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IFxuICAgIDp0YWc9XCJ0YWdcIiBcbiAgICA6Y2xhc3Nlcz1cImNsYXNzZXNcIlxuICAgIDpzdHlsZXM9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1yaXBwbGVcIj5cbiAgICA8c2xvdCAvPlxuICA8L2N1c3RvbS1lbGVtZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IEN1c3RvbUVsZW1lbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4vbWRjLXJpcHBsZS1iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcmlwcGxlJyxcbiAgbWl4aW5zOiBbQ3VzdG9tRWxlbWVudE1peGluLCBSaXBwbGVNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgdGFnOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNSaXBwbGUgZnJvbSAnLi9tZGMtcmlwcGxlLnZ1ZSdcblxuZXhwb3J0ICogZnJvbSAnLi9tZGMtcmlwcGxlLWJhc2UuanMnXG5cbmV4cG9ydCB7IG1kY1JpcHBsZSB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNSaXBwbGVcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxjdXN0b20tYnV0dG9uIFxuICAgIHJlZj1cInJvb3RcIlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIDpocmVmPVwiaHJlZlwiIFxuICAgIDpsaW5rPVwibGlua1wiIFxuICAgIDpkaXNhYmxlZD1cImRpc2FibGVkXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlTWl4aW4gfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24tYmFzZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW4sIFJpcHBsZU1peGluXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24nLFxuICBleHRlbmRzOiBtZGNCdXR0b25CYXNlLFxuICBwcm9wczoge1xuICAgIHJhaXNlZDogQm9vbGVhbixcbiAgICB1bmVsZXZhdGVkOiBCb29sZWFuLFxuICAgIG91dGxpbmVkOiBCb29sZWFuLFxuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1idXR0b24nOiB0cnVlLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tcmFpc2VkJzogdGhpcy5yYWlzZWQsXG4gICAgICAgICdtZGMtYnV0dG9uLS11bmVsZXZhdGVkJzogdGhpcy51bmVsZXZhdGVkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tb3V0bGluZWQnOiB0aGlzLm91dGxpbmVkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tZGVuc2UnOiB0aGlzLmRlbnNlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHJhaXNlZCgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1yYWlzZWQnLCB0aGlzLnJhaXNlZClcbiAgICB9LFxuICAgIHVuZWxldmF0ZWQoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCcsIHRoaXMudW5lbGV2YXRlZClcbiAgICB9LFxuICAgIG91dGxpbmVkKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLW91dGxpbmVkJywgdGhpcy5vdXRsaW5lZClcbiAgICB9LFxuICAgIGRlbnNlKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLWRlbnNlJywgdGhpcy5kZW5zZSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjQnV0dG9uIGZyb20gJy4vbWRjLWJ1dHRvbi52dWUnXG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCB7IG1kY0J1dHRvbkJhc2UsIG1kY0J1dHRvbiB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNCdXR0b25cbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJ7J21kYy1jYXJkLS1vdXRsaW5lZCc6IG91dGxpbmVkfVwiXG4gICAgY2xhc3M9XCJtZGMtY2FyZFwiPlxuICAgIDxzbG90Lz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQnLFxuICBwcm9wczoge1xuICAgIG91dGxpbmVkOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBcclxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxyXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgOmxpbms9XCJsaW5rXCIgXHJcbiAgICBjbGFzcz1cIm1kYy1jYXJkLXByaW1hcnktYWN0aW9uIG1kYy1jYXJkX19wcmltYXJ5LWFjdGlvblwiIFxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG4gICAgPHNsb3QgLz5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4uL3JpcHBsZS9pbmRleCdcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1wcmltYXJ5LWFjdGlvbicsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW4sIFJpcHBsZU1peGluXSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge30sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8c2VjdGlvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXHJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1jYXJkLW1lZGlhIG1kYy1jYXJkX19tZWRpYVwiPlxyXG4gICAgPGRpdiBcbiAgICAgIHYtaWY9XCIkc2xvdHMuZGVmYXVsdFwiIFxuICAgICAgY2xhc3M9XCJtZGMtY2FyZF9fbWVkaWEtY29udGVudFwiPlxyXG4gICAgICA8c2xvdC8+XHJcbiAgICA8L2Rpdj5cclxuICA8L3NlY3Rpb24+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLW1lZGlhJyxcclxuICBwcm9wczoge1xyXG4gICAgc3JjOiBTdHJpbmcsXHJcbiAgICBzcXVhcmU6IEJvb2xlYW5cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBzdHlsZXMoKSB7XHJcbiAgICAgIHZhciBzdHlsZXMgPSB7XHJcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7dGhpcy5zcmN9KWBcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0eWxlc1xyXG4gICAgfSxcclxuICAgIGNsYXNzZXMoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNxdWFyZSA/ICdtZGMtY2FyZF9fbWVkaWEtLXNxdWFyZScgOiAnbWRjLWNhcmRfX21lZGlhLS0xNi05J1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLWhlYWRlciBtZGMtY2FyZF9fcHJpbWFyeVwiPlxuICAgIDxzbG90PlxuICAgICAgPGgxIFxuICAgICAgICB2LWlmPVwidGl0bGVcIlxuICAgICAgICA6Y2xhc3M9XCJ7J21kYy1jYXJkX190aXRsZS0tbGFyZ2UnOiBsYXJnZVRpdGxlfVwiXG4gICAgICAgIGNsYXNzPVwibWRjLWNhcmRfX3RpdGxlXCJcbiAgICAgID5cbiAgICAgICAge3sgdGl0bGUgfX1cbiAgICAgIDwvaDE+XG4gICAgICA8aDIgXG4gICAgICAgIHYtaWY9XCJzdWJ0aXRsZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLWNhcmRfX3N1YnRpdGxlXCJcbiAgICAgID5cbiAgICAgICAge3sgc3VidGl0bGUgfX0gXG4gICAgICA8L2gyPlxuICAgIDwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLWhlYWRlcicsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICBzdWJ0aXRsZTogU3RyaW5nLFxuICAgICdsYXJnZS10aXRsZSc6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdHJ1ZSB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aDEgXG4gICAgOmNsYXNzPVwieydtZGMtY2FyZF9fdGl0bGUtLWxhcmdlJzogbGFyZ2V9XCJcbiAgICBjbGFzcz1cIm1kYy1jYXJkLXRpdGxlIG1kYy1jYXJkX190aXRsZVwiPlxuICAgIDxzbG90Lz5cbiAgPC9oMT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC10aXRsZScsXG4gIHByb3BzOiB7XG4gICAgbGFyZ2U6IEJvb2xlYW5cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoMiBjbGFzcz1cIm1kYy1jYXJkLXN1YnRpdGxlIG1kYy1jYXJkX19zdWJ0aXRsZVwiPlxuICAgIDxzbG90Lz5cbiAgPC9oMj5cbjwvdGVtcGxhdGU+XG5cblxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQtc3VidGl0bGUnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtY2FyZC10ZXh0IG1kYy1jYXJkX19zdXBwb3J0aW5nLXRleHRcIj5cbiAgICA8c2xvdC8+XG4gIDwvc2VjdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC10ZXh0J1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNlY3Rpb24gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxyXG4gICAgY2xhc3M9XCJtZGMtY2FyZC1hY3Rpb25zIG1kYy1jYXJkX19hY3Rpb25zXCI+XHJcbiAgICA8c2xvdC8+XHJcbiAgPC9zZWN0aW9uPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb25zJyxcclxuICBwcm9wczoge1xyXG4gICAgZnVsbEJsZWVkOiBCb29sZWFuXHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgY2xhc3NlcygpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbnMtLWZ1bGwtYmxlZWQnOiB0aGlzLmZ1bGxCbGVlZFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbi1idXR0b25zIG1kYy1jYXJkX19hY3Rpb24tYnV0dG9uc1wiPlxyXG4gICAgPHNsb3QvPlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb24tYnV0dG9ucydcclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHNjcmlwdD5cclxuaW1wb3J0IHsgbWRjQnV0dG9uQmFzZSB9IGZyb20gJy4uL2J1dHRvbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbicsXHJcbiAgZXh0ZW5kczogbWRjQnV0dG9uQmFzZSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtYnV0dG9uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1jYXJkLWFjdGlvbi1idXR0b24nOiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRjLWNhcmQtYWN0aW9uLWljb25zIG1kYy1jYXJkX19hY3Rpb24taWNvbnNcIj5cclxuICAgIDxzbG90Lz5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWljb25zJ1xyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cclxuICA8L3NwYW4+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb24taWNvbicsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgaWNvbjogU3RyaW5nXHJcbiAgfSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtY2FyZC1hY3Rpb24taWNvbic6IHRydWUsXHJcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmljb24sXHJcbiAgICAgICAgJ21kYy1jYXJkX19hY3Rpb24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtY2FyZF9fYWN0aW9uLS1pY29uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWljb24tdG9nZ2xlJzogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgaWNvbigpIHtcclxuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21hdGVyaWFsLWljb25zJywgISF0aGlzLmljb24pXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkKCkge1xyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzLCB7XHJcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlXHJcbiAgICB9KVxyXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0NhcmQgZnJvbSAnLi9tZGMtY2FyZC52dWUnXHJcbmltcG9ydCBtZGNDYXJkUHJpbWFyeUFjdGlvbiBmcm9tICcuL21kYy1jYXJkLXByaW1hcnktYWN0aW9uLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRNZWRpYSBmcm9tICcuL21kYy1jYXJkLW1lZGlhLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRIZWFkZXIgZnJvbSAnLi9tZGMtY2FyZC1oZWFkZXIudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFRpdGxlIGZyb20gJy4vbWRjLWNhcmQtdGl0bGUudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFN1YnRpdGxlIGZyb20gJy4vbWRjLWNhcmQtc3VidGl0bGUudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFRleHQgZnJvbSAnLi9tZGMtY2FyZC10ZXh0LnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25zIGZyb20gJy4vbWRjLWNhcmQtYWN0aW9ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uQnV0dG9ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1idXR0b25zLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25CdXR0b24gZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24tYnV0dG9uLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25JY29ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1pY29ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uSWNvbiBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1pY29uLnZ1ZSdcclxuXHJcbmV4cG9ydCB7XHJcbiAgbWRjQ2FyZCxcclxuICBtZGNDYXJkUHJpbWFyeUFjdGlvbixcclxuICBtZGNDYXJkTWVkaWEsXHJcbiAgbWRjQ2FyZEhlYWRlcixcclxuICBtZGNDYXJkVGl0bGUsXHJcbiAgbWRjQ2FyZFN1YnRpdGxlLFxyXG4gIG1kY0NhcmRUZXh0LFxyXG4gIG1kY0NhcmRBY3Rpb25zLFxyXG4gIG1kY0NhcmRBY3Rpb25CdXR0b25zLFxyXG4gIG1kY0NhcmRBY3Rpb25CdXR0b24sXHJcbiAgbWRjQ2FyZEFjdGlvbkljb25zLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29uXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0NhcmQsXHJcbiAgbWRjQ2FyZFByaW1hcnlBY3Rpb24sXHJcbiAgbWRjQ2FyZE1lZGlhLFxyXG4gIG1kY0NhcmRIZWFkZXIsXHJcbiAgbWRjQ2FyZFRpdGxlLFxyXG4gIG1kY0NhcmRTdWJ0aXRsZSxcclxuICBtZGNDYXJkVGV4dCxcclxuICBtZGNDYXJkQWN0aW9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9uLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29ucyxcclxuICBtZGNDYXJkQWN0aW9uSWNvblxyXG59KVxyXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgRlxuICovXG5jbGFzcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDQ29tcG9uZW50fVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHdoaWNoIGV4dGVuZCBNRENCYXNlIHNob3VsZCBwcm92aWRlIGFuIGF0dGFjaFRvKCkgbWV0aG9kIHRoYXQgdGFrZXMgYSByb290IGVsZW1lbnQgYW5kXG4gICAgLy8gcmV0dXJucyBhbiBpbnN0YW50aWF0ZWQgY29tcG9uZW50IHdpdGggaXRzIHJvb3Qgc2V0IHRvIHRoYXQgZWxlbWVudC4gQWxzbyBub3RlIHRoYXQgaW4gdGhlIGNhc2VzIG9mXG4gICAgLy8gc3ViY2xhc3NlcywgYW4gZXhwbGljaXQgZm91bmRhdGlvbiBjbGFzcyB3aWxsIG5vdCBoYXZlIHRvIGJlIHBhc3NlZCBpbjsgaXQgd2lsbCBzaW1wbHkgYmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBmcm9tIGdldERlZmF1bHRGb3VuZGF0aW9uKCkuXG4gICAgcmV0dXJuIG5ldyBNRENDb21wb25lbnQocm9vdCwgbmV3IE1EQ0ZvdW5kYXRpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge0Y9fSBmb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgZm91bmRhdGlvbiA9IHVuZGVmaW5lZCwgLi4uYXJncykge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnJvb3RfID0gcm9vdDtcbiAgICB0aGlzLmluaXRpYWxpemUoLi4uYXJncyk7XG4gICAgLy8gTm90ZSB0aGF0IHdlIGluaXRpYWxpemUgZm91bmRhdGlvbiBoZXJlIGFuZCBub3Qgd2l0aGluIHRoZSBjb25zdHJ1Y3RvcidzIGRlZmF1bHQgcGFyYW0gc28gdGhhdFxuICAgIC8vIHRoaXMucm9vdF8gaXMgZGVmaW5lZCBhbmQgY2FuIGJlIHVzZWQgd2l0aGluIHRoZSBmb3VuZGF0aW9uIGNsYXNzLlxuICAgIC8qKiBAcHJvdGVjdGVkIHshRn0gKi9cbiAgICB0aGlzLmZvdW5kYXRpb25fID0gZm91bmRhdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXREZWZhdWx0Rm91bmRhdGlvbigpIDogZm91bmRhdGlvbjtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmluaXQoKTtcbiAgICB0aGlzLmluaXRpYWxTeW5jV2l0aERPTSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgvKiAuLi5hcmdzICovKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBkbyBhbnkgYWRkaXRpb25hbCBzZXR1cCB3b3JrIHRoYXQgd291bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAvLyBcImNvbnN0cnVjdG9yXCIuIEVzc2VudGlhbGx5LCBpdCBpcyBhIGhvb2sgaW50byB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGJlZm9yZSB0aGUgZm91bmRhdGlvbiBpc1xuICAgIC8vIGluaXRpYWxpemVkLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYmVzaWRlcyByb290IGFuZCBmb3VuZGF0aW9uIHdpbGwgYmUgcGFzc2VkIGluIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUZ9IGZvdW5kYXRpb25cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkIGZvdW5kYXRpb24gY2xhc3MgZm9yIHRoZVxuICAgIC8vIGNvbXBvbmVudC5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXREZWZhdWx0Rm91bmRhdGlvbiB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkICcgK1xuICAgICAgJ2ZvdW5kYXRpb24gY2xhc3MnKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IG5lZWQgdG8gcGVyZm9ybSB3b3JrIHRvIHN5bmNocm9uaXplIHdpdGggYSBob3N0IERPTVxuICAgIC8vIG9iamVjdC4gQW4gZXhhbXBsZSBvZiB0aGlzIHdvdWxkIGJlIGEgZm9ybSBjb250cm9sIHdyYXBwZXIgdGhhdCBuZWVkcyB0byBzeW5jaHJvbml6ZSBpdHMgaW50ZXJuYWwgc3RhdGVcbiAgICAvLyB0byBzb21lIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSBvZiB0aGUgaG9zdCBET00uIFBsZWFzZSBub3RlOiB0aGlzIGlzICpub3QqIHRoZSBwbGFjZSB0byBwZXJmb3JtIERPTVxuICAgIC8vIHJlYWRzL3dyaXRlcyB0aGF0IHdvdWxkIGNhdXNlIGxheW91dCAvIHBhaW50LCBhcyB0aGlzIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5IGZyb20gd2l0aGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtYXkgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJlbGVhc2UgYW55IHJlc291cmNlcyAvIGRlcmVnaXN0ZXIgYW55IGxpc3RlbmVycyB0aGV5IGhhdmVcbiAgICAvLyBhdHRhY2hlZC4gQW4gZXhhbXBsZSBvZiB0aGlzIG1pZ2h0IGJlIGRlcmVnaXN0ZXJpbmcgYSByZXNpemUgZXZlbnQgZnJvbSB0aGUgd2luZG93IG9iamVjdC5cbiAgICB0aGlzLmZvdW5kYXRpb25fLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIGxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogdW5saXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICB1bmxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGEgY3Jvc3MtYnJvd3Nlci1jb21wYXRpYmxlIGN1c3RvbSBldmVudCBmcm9tIHRoZSBjb21wb25lbnQgcm9vdCBvZiB0aGUgZ2l2ZW4gdHlwZSxcbiAgICogd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshT2JqZWN0fSBldnREYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZEJ1YmJsZVxuICAgKi9cbiAgZW1pdChldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICAgIGxldCBldnQ7XG4gICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgICBidWJibGVzOiBzaG91bGRCdWJibGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMucm9vdF8uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NvbXBvbmVudDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgTURDUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1JpcHBsZUZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAZXh0ZW5kcyBNRENDb21wb25lbnQ8IU1EQ1JpcHBsZUZvdW5kYXRpb24+XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZSBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKiBAcGFyYW0gey4uLj99IGFyZ3MgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVuYm91bmRlZF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge3tpc1VuYm91bmRlZDogKGJvb2xlYW58dW5kZWZpbmVkKX09fSBvcHRpb25zXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGV9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCwge2lzVW5ib3VuZGVkID0gdW5kZWZpbmVkfSA9IHt9KSB7XG4gICAgY29uc3QgcmlwcGxlID0gbmV3IE1EQ1JpcHBsZShyb290KTtcbiAgICAvLyBPbmx5IG92ZXJyaWRlIHVuYm91bmRlZCBiZWhhdmlvciBpZiBvcHRpb24gaXMgZXhwbGljaXRseSBzcGVjaWZpZWRcbiAgICBpZiAoaXNVbmJvdW5kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmlwcGxlLnVuYm91bmRlZCA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGlzVW5ib3VuZGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJpcHBsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFSaXBwbGVDYXBhYmxlU3VyZmFjZX0gaW5zdGFuY2VcbiAgICogQHJldHVybiB7IU1EQ1JpcHBsZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWRhcHRlcihpbnN0YW5jZSkge1xuICAgIGNvbnN0IE1BVENIRVMgPSB1dGlsLmdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IHV0aWwuc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiBpbnN0YW5jZS51bmJvdW5kZWQsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IGluc3RhbmNlLnJvb3RfW01BVENIRVNdKCc6YWN0aXZlJyksXG4gICAgICBpc1N1cmZhY2VEaXNhYmxlZDogKCkgPT4gaW5zdGFuY2UuZGlzYWJsZWQsXG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gaW5zdGFuY2Uucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IGluc3RhbmNlLnJvb3RfLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICh0YXJnZXQpID0+IGluc3RhbmNlLnJvb3RfLmNvbnRhaW5zKHRhcmdldCksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGluc3RhbmNlLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgaW5zdGFuY2Uucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKHZhck5hbWUsIHZhbHVlKSA9PiBpbnN0YW5jZS5yb290Xy5zdHlsZS5zZXRQcm9wZXJ0eSh2YXJOYW1lLCB2YWx1ZSksXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiBpbnN0YW5jZS5yb290Xy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+ICh7eDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXR9KSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCB1bmJvdW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5ib3VuZGVkXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHVuYm91bmRlZCAqL1xuICBzZXQgdW5ib3VuZGVkKHVuYm91bmRlZCkge1xuICAgIHRoaXMudW5ib3VuZGVkXyA9IEJvb2xlYW4odW5ib3VuZGVkKTtcbiAgICB0aGlzLnNldFVuYm91bmRlZF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zdXJlIENvbXBpbGVyIHRocm93cyBhbiBhY2Nlc3MgY29udHJvbCBlcnJvciB3aGVuIGRpcmVjdGx5IGFjY2Vzc2luZyBhXG4gICAqIHByb3RlY3RlZCBvciBwcml2YXRlIHByb3BlcnR5IGluc2lkZSBhIGdldHRlci9zZXR0ZXIsIGxpa2UgdW5ib3VuZGVkIGFib3ZlLlxuICAgKiBCeSBhY2Nlc3NpbmcgdGhlIHByb3RlY3RlZCBwcm9wZXJ0eSBpbnNpZGUgYSBtZXRob2QsIHdlIHNvbHZlIHRoYXQgcHJvYmxlbS5cbiAgICogVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGV4aXN0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFVuYm91bmRlZF8oKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRVbmJvdW5kZWQodGhpcy51bmJvdW5kZWRfKTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uYWN0aXZhdGUoKTtcbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5sYXlvdXQoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDUmlwcGxlRm91bmRhdGlvbn0gKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENSaXBwbGVGb3VuZGF0aW9uKE1EQ1JpcHBsZS5jcmVhdGVBZGFwdGVyKHRoaXMpKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICB0aGlzLnVuYm91bmRlZCA9ICdtZGNSaXBwbGVJc1VuYm91bmRlZCcgaW4gdGhpcy5yb290Xy5kYXRhc2V0O1xuICB9XG59XG5cbi8qKlxuICogU2VlIE1hdGVyaWFsIERlc2lnbiBzcGVjIGZvciBtb3JlIGRldGFpbHMgb24gd2hlbiB0byB1c2UgcmlwcGxlcy5cbiAqIGh0dHBzOi8vbWF0ZXJpYWwuaW8vZ3VpZGVsaW5lcy9tb3Rpb24vY2hvcmVvZ3JhcGh5Lmh0bWwjY2hvcmVvZ3JhcGh5LWNyZWF0aW9uXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIFJpcHBsZUNhcGFibGVTdXJmYWNlIHt9XG5cbi8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS5yb290XztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmlwcGxlIGJsZWVkcyBvdXQgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudC5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLnVuYm91bmRlZDtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmlwcGxlIGlzIGF0dGFjaGVkIHRvIGEgZGlzYWJsZWQgY29tcG9uZW50LlxuICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUuZGlzYWJsZWQ7XG5cbmV4cG9ydCB7TURDUmlwcGxlLCBNRENSaXBwbGVGb3VuZGF0aW9uLCBSaXBwbGVDYXBhYmxlU3VyZmFjZSwgdXRpbH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDUmlwcGxlfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2luZGV4Jztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBjaGVja2VkOiBib29sZWFuLFxuICogICBpbmRldGVybWluYXRlOiBib29sZWFuLFxuICogICBkaXNhYmxlZDogYm9vbGVhbixcbiAqICAgdmFsdWU6ID9zdHJpbmdcbiAqIH19XG4gKi9cbmxldCBNRENTZWxlY3Rpb25Db250cm9sU3RhdGU7XG5cbi8qKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTZWxlY3Rpb25Db250cm9sIHtcbiAgLyoqIEByZXR1cm4gez9NRENSaXBwbGV9ICovXG4gIGdldCByaXBwbGUoKSB7fVxufVxuXG5leHBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZSwgTURDU2VsZWN0aW9uQ29udHJvbH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXgnO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hlY2tib3guIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoZWNrYm94QWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiB2YWx1ZSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXROYXRpdmVDb250cm9sQXR0cihhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyKGF0dHIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlciAqL1xuICByZWdpc3RlckNoYW5nZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSAqL1xuICBnZXROYXRpdmVDb250cm9sKCkge31cblxuICBmb3JjZUxheW91dCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzQXR0YWNoZWRUb0RPTSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoZWNrYm94QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBST09UID0gJ21kYy1jaGVja2JveCc7XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgVVBHUkFERUQ6ICdtZGMtY2hlY2tib3gtLXVwZ3JhZGVkJyxcbiAgQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tY2hlY2tlZCcsXG4gIElOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWluZGV0ZXJtaW5hdGUnLFxuICBESVNBQkxFRDogJ21kYy1jaGVja2JveC0tZGlzYWJsZWQnLFxuICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLXVuY2hlY2tlZC1jaGVja2VkJyxcbiAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZScsXG4gIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0tY2hlY2tlZC11bmNoZWNrZWQnLFxuICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUnLFxuICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1pbmRldGVybWluYXRlLWNoZWNrZWQnLFxuICBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6IGAuJHtST09UfV9fbmF0aXZlLWNvbnRyb2xgLFxuICBUUkFOU0lUSU9OX1NUQVRFX0lOSVQ6ICdpbml0JyxcbiAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEOiAnY2hlY2tlZCcsXG4gIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEOiAndW5jaGVja2VkJyxcbiAgVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFOiAnaW5kZXRlcm1pbmF0ZScsXG4gIEFSSUFfQ0hFQ0tFRF9BVFRSOiAnYXJpYS1jaGVja2VkJyxcbiAgQVJJQV9DSEVDS0VEX0lOREVURVJNSU5BVEVfVkFMVUU6ICdtaXhlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIEFOSU1fRU5EX0xBVENIX01TOiAyNTAsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXgnO1xuaW1wb3J0IE1EQ0NoZWNrYm94QWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKiBAY29uc3QgeyFBcnJheTxzdHJpbmc+fSAqL1xuY29uc3QgQ0JfUFJPVE9fUFJPUFMgPSBbJ2NoZWNrZWQnLCAnaW5kZXRlcm1pbmF0ZSddO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENDaGVja2JveEFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENDaGVja2JveEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENDaGVja2JveEFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoZWNrYm94QWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXROYXRpdmVDb250cm9sQXR0cjogKC8qIGF0dHI6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVOYXRpdmVDb250cm9sQXR0cjogKC8qIGF0dHI6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiAvKiAhTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlICovIHt9LFxuICAgICAgZm9yY2VMYXlvdXQ6ICgpID0+IHt9LFxuICAgICAgaXNBdHRhY2hlZFRvRE9NOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDQ2hlY2tib3hGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXyA9IHN0cmluZ3MuVFJBTlNJVElPTl9TVEFURV9JTklUO1xuXG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfID0gJyc7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyA9IDA7XG5cbiAgICB0aGlzLmFuaW1FbmRIYW5kbGVyXyA9IC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kKCkpO1xuXG4gICAgdGhpcy5jaGFuZ2VIYW5kbGVyXyA9IC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQ2hhbmdlKCkpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXyA9IHRoaXMuZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8odGhpcy5nZXROYXRpdmVDb250cm9sXygpKTtcbiAgICB0aGlzLnVwZGF0ZUFyaWFDaGVja2VkXygpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckNoYW5nZUhhbmRsZXIodGhpcy5jaGFuZ2VIYW5kbGVyXyk7XG4gICAgdGhpcy5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcih0aGlzLmNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLnVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNDaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWQgKi9cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzSW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmluZGV0ZXJtaW5hdGU7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpbmRldGVybWluYXRlICovXG4gIHNldEluZGV0ZXJtaW5hdGUoaW5kZXRlcm1pbmF0ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgYW5pbWF0aW9uZW5kIGV2ZW50IGZvciB0aGUgY2hlY2tib3hcbiAgICovXG4gIGhhbmRsZUFuaW1hdGlvbkVuZCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8pO1xuICAgIHRoaXMuYW5pbUVuZExhdGNoVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKHRoaXMuYW5pbUVuZEhhbmRsZXJfKTtcbiAgICB9LCBudW1iZXJzLkFOSU1fRU5EX0xBVENIX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjaGFuZ2UgZXZlbnQgZm9yIHRoZSBjaGVja2JveFxuICAgKi9cbiAgaGFuZGxlQ2hhbmdlKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbkNoZWNrU3RhdGVfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNiID0gdGhpcy5nZXROYXRpdmVDb250cm9sXygpO1xuICAgIGNvbnN0IGNiUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmF0aXZlQ2IpO1xuXG4gICAgQ0JfUFJPVE9fUFJPUFMuZm9yRWFjaCgoY29udHJvbFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjYlByb3RvLCBjb250cm9sU3RhdGUpO1xuICAgICAgLy8gV2UgaGF2ZSB0byBjaGVjayBmb3IgdGhpcyBkZXNjcmlwdG9yLCBzaW5jZSBzb21lIGJyb3dzZXJzIChTYWZhcmkpIGRvbid0IHN1cHBvcnQgaXRzIHJldHVybi5cbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQ5NzM5XG4gICAgICBpZiAodmFsaWREZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUNiRGVzYyA9IC8qKiBAdHlwZSB7IU9iamVjdFByb3BlcnR5RGVzY3JpcHRvcn0gKi8gKHtcbiAgICAgICAgICBnZXQ6IGRlc2MuZ2V0LFxuICAgICAgICAgIHNldDogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKG5hdGl2ZUNiLCBzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25DaGVja1N0YXRlXygpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2IsIGNvbnRyb2xTdGF0ZSwgbmF0aXZlQ2JEZXNjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1bmluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpIHtcbiAgICBjb25zdCBuYXRpdmVDYiA9IHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKTtcbiAgICBjb25zdCBjYlByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5hdGl2ZUNiKTtcblxuICAgIENCX1BST1RPX1BST1BTLmZvckVhY2goKGNvbnRyb2xTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZGVzYyA9IC8qKiBAdHlwZSB7IU9iamVjdFByb3BlcnR5RGVzY3JpcHRvcn0gKi8gKFxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNiUHJvdG8sIGNvbnRyb2xTdGF0ZSkpO1xuICAgICAgaWYgKHZhbGlkRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2IsIGNvbnRyb2xTdGF0ZSwgZGVzYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdHJhbnNpdGlvbkNoZWNrU3RhdGVfKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNiID0gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVDb250cm9sKCk7XG4gICAgaWYgKCFuYXRpdmVDYikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuY3VycmVudENoZWNrU3RhdGVfO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5kZXRlcm1pbmVDaGVja1N0YXRlXyhuYXRpdmVDYik7XG4gICAgaWYgKG9sZFN0YXRlID09PSBuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQXJpYUNoZWNrZWRfKCk7XG5cbiAgICAvLyBDaGVjayB0byBlbnN1cmUgdGhhdCB0aGVyZSBpc24ndCBhIHByZXZpb3VzbHkgZXhpc3RpbmcgYW5pbWF0aW9uIGNsYXNzLCBpbiBjYXNlIGZvciBleGFtcGxlXG4gICAgLy8gdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZSBjaGVja2JveCBiZWZvcmUgdGhlIGFuaW1hdGlvbiB3YXMgZmluaXNoZWQuXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXy5sZW5ndGggPiAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mb3JjZUxheW91dCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18pO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyA9IHRoaXMuZ2V0VHJhbnNpdGlvbkFuaW1hdGlvbkNsYXNzXyhvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgIHRoaXMuY3VycmVudENoZWNrU3RhdGVfID0gbmV3U3RhdGU7XG5cbiAgICAvLyBDaGVjayBmb3IgcGFyZW50Tm9kZSBzbyB0aGF0IGFuaW1hdGlvbnMgYXJlIG9ubHkgcnVuIHdoZW4gdGhlIGVsZW1lbnQgaXMgYXR0YWNoZWRcbiAgICAvLyB0byB0aGUgRE9NLlxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzQXR0YWNoZWRUb0RPTSgpICYmIHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcih0aGlzLmFuaW1FbmRIYW5kbGVyXyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gbmF0aXZlQ2JcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8obmF0aXZlQ2IpIHtcbiAgICBjb25zdCB7XG4gICAgICBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEUsXG4gICAgICBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQsXG4gICAgICBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCxcbiAgICB9ID0gc3RyaW5ncztcblxuICAgIGlmIChuYXRpdmVDYi5pbmRldGVybWluYXRlKSB7XG4gICAgICByZXR1cm4gVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlQ2IuY2hlY2tlZCA/IFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCA6IFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRTdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3U3RhdGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VHJhbnNpdGlvbkFuaW1hdGlvbkNsYXNzXyhvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBUUkFOU0lUSU9OX1NUQVRFX0lOSVQsXG4gICAgICBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQsXG4gICAgICBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCxcbiAgICB9ID0gc3RyaW5ncztcblxuICAgIGNvbnN0IHtcbiAgICAgIEFOSU1fVU5DSEVDS0VEX0NIRUNLRUQsXG4gICAgICBBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFLFxuICAgICAgQU5JTV9DSEVDS0VEX1VOQ0hFQ0tFRCxcbiAgICAgIEFOSU1fQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFLFxuICAgICAgQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQsXG4gICAgICBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VELFxuICAgIH0gPSBNRENDaGVja2JveEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcblxuICAgIHN3aXRjaCAob2xkU3RhdGUpIHtcbiAgICBjYXNlIFRSQU5TSVRJT05fU1RBVEVfSU5JVDpcbiAgICAgIGlmIChuZXdTdGF0ZSA9PT0gVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRDpcbiAgICAgIHJldHVybiBuZXdTdGF0ZSA9PT0gVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEID8gQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRCA6IEFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEU7XG4gICAgY2FzZSBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQ6XG4gICAgICByZXR1cm4gbmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEID8gQU5JTV9DSEVDS0VEX1VOQ0hFQ0tFRCA6IEFOSU1fQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFO1xuICAgIC8vIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCA/XG4gICAgICAgIEFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VEIDogQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRDtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVBcmlhQ2hlY2tlZF8oKSB7XG4gICAgLy8gRW5zdXJlIGFyaWEtY2hlY2tlZCBpcyBzZXQgdG8gbWl4ZWQgaWYgY2hlY2tib3ggaXMgaW4gaW5kZXRlcm1pbmF0ZSBzdGF0ZS5cbiAgICBpZiAodGhpcy5pc0luZGV0ZXJtaW5hdGUoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXROYXRpdmVDb250cm9sQXR0cihcbiAgICAgICAgc3RyaW5ncy5BUklBX0NIRUNLRURfQVRUUiwgc3RyaW5ncy5BUklBX0NIRUNLRURfSU5ERVRFUk1JTkFURV9WQUxVRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlTmF0aXZlQ29udHJvbEF0dHIoc3RyaW5ncy5BUklBX0NIRUNLRURfQVRUUik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROYXRpdmVDb250cm9sXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVDb250cm9sKCkgfHwge1xuICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICBpbmRldGVybWluYXRlOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdFByb3BlcnR5RGVzY3JpcHRvcnx1bmRlZmluZWR9IGlucHV0UHJvcERlc2NcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZhbGlkRGVzY3JpcHRvcihpbnB1dFByb3BEZXNjKSB7XG4gIHJldHVybiAhIWlucHV0UHJvcERlc2MgJiYgdHlwZW9mIGlucHV0UHJvcERlc2Muc2V0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGVja2JveEZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIEZvcm0gRmllbGQuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqIC0gcmlwcGxlIGFjdGl2YXRpb25cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0Zvcm1GaWVsZEFkYXB0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIGFjdGl2YXRlSW5wdXRSaXBwbGUoKSB7fVxuXG4gIGRlYWN0aXZhdGVJbnB1dFJpcHBsZSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0Zvcm1GaWVsZEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWZvcm0tZmllbGQnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBMQUJFTF9TRUxFQ1RPUjogJy5tZGMtZm9ybS1maWVsZCA+IGxhYmVsJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDRm9ybUZpZWxkQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0Zvcm1GaWVsZEFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENGb3JtRmllbGRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDRm9ybUZpZWxkQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gLyoqIEB0eXBlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy5oYW5kbGVDbGlja18oKSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgaGFuZGxlQ2xpY2tfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVJbnB1dFJpcHBsZSgpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkYXB0ZXJfLmRlYWN0aXZhdGVJbnB1dFJpcHBsZSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3JtRmllbGRGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgbm9QcmVmaXg6IHN0cmluZyxcbiAqICAgd2Via2l0UHJlZml4OiBzdHJpbmcsXG4gKiAgIHN0eWxlUHJvcGVydHk6IHN0cmluZ1xuICogfX1cbiAqL1xubGV0IFZlbmRvclByb3BlcnR5TWFwVHlwZTtcblxuLyoqIEBjb25zdCB7T2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovXG5jb25zdCBldmVudFR5cGVNYXAgPSB7XG4gICdhbmltYXRpb25zdGFydCc6IHtcbiAgICBub1ByZWZpeDogJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25TdGFydCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICdhbmltYXRpb25lbmQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICdhbmltYXRpb25pdGVyYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbicsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICd0cmFuc2l0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNpdGlvbmVuZCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ3RyYW5zaXRpb24nLFxuICB9LFxufTtcblxuLyoqIEBjb25zdCB7T2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovXG5jb25zdCBjc3NQcm9wZXJ0eU1hcCA9IHtcbiAgJ2FuaW1hdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ2FuaW1hdGlvbicsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC1hbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNmb3JtJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNmb3JtJyxcbiAgICB3ZWJraXRQcmVmaXg6ICctd2Via2l0LXRyYW5zZm9ybScsXG4gIH0sXG4gICd0cmFuc2l0aW9uJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNpdGlvbicsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc1Byb3BlclNoYXBlKHdpbmRvd09iaikge1xuICByZXR1cm4gKHdpbmRvd09ialsnZG9jdW1lbnQnXSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3aW5kb3dPYmpbJ2RvY3VtZW50J11bJ2NyZWF0ZUVsZW1lbnQnXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpIHtcbiAgcmV0dXJuIChldmVudFR5cGUgaW4gZXZlbnRUeXBlTWFwIHx8IGV2ZW50VHlwZSBpbiBjc3NQcm9wZXJ0eU1hcCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59IG1hcFxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpIHtcbiAgcmV0dXJuIG1hcFtldmVudFR5cGVdLnN0eWxlUHJvcGVydHkgaW4gZWwuc3R5bGUgPyBtYXBbZXZlbnRUeXBlXS5ub1ByZWZpeCA6IG1hcFtldmVudFR5cGVdLndlYmtpdFByZWZpeDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGJyb3dzZXIgcHJlZml4IGZvciBDU1MzIGFuaW1hdGlvbiBldmVudHNcbiAqIGFuZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgaWYgKCFoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHx8ICFldmVudEZvdW5kSW5NYXBzKGV2ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gZXZlbnRUeXBlO1xuICB9XG5cbiAgY29uc3QgbWFwID0gLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovIChcbiAgICBldmVudFR5cGUgaW4gZXZlbnRUeXBlTWFwID8gZXZlbnRUeXBlTWFwIDogY3NzUHJvcGVydHlNYXBcbiAgKTtcbiAgY29uc3QgZWwgPSB3aW5kb3dPYmpbJ2RvY3VtZW50J11bJ2NyZWF0ZUVsZW1lbnQnXSgnZGl2Jyk7XG4gIGxldCBldmVudE5hbWUgPSAnJztcblxuICBpZiAobWFwID09PSBldmVudFR5cGVNYXApIHtcbiAgICBldmVudE5hbWUgPSBnZXRKYXZhU2NyaXB0RXZlbnROYW1lKGV2ZW50VHlwZSwgbWFwLCBlbCk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnROYW1lID0gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggaW4gZWwuc3R5bGUgPyBtYXBbZXZlbnRUeXBlXS5ub1ByZWZpeCA6IG1hcFtldmVudFR5cGVdLndlYmtpdFByZWZpeDtcbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbi8vIFB1YmxpYyBmdW5jdGlvbnMgdG8gYWNjZXNzIGdldEFuaW1hdGlvbk5hbWUoKSBmb3IgSmF2YVNjcmlwdCBldmVudHMgb3IgQ1NTXG4vLyBwcm9wZXJ0eSBuYW1lcy5cblxuY29uc3QgdHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzID0gWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01TVHJhbnNmb3JtJ107XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSkge1xuICByZXR1cm4gZ2V0QW5pbWF0aW9uTmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSkge1xuICByZXR1cm4gZ2V0QW5pbWF0aW9uTmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSk7XG59XG5cbmV4cG9ydCB7dHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzLCBnZXRDb3JyZWN0RXZlbnROYW1lLCBnZXRDb3JyZWN0UHJvcGVydHlOYW1lfTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImZvcm1GaWVsZENsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLWNoZWNrYm94LXdyYXBwZXJcIj5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJyb290XCJcbiAgICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgICAgOnN0eWxlPVwic3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLWNoZWNrYm94XCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgcmVmPVwiY29udHJvbFwiXG4gICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICBjbGFzcz1cIm1kYy1jaGVja2JveF9fbmF0aXZlLWNvbnRyb2xcIlxuICAgICAgICBAY2hhbmdlPVwib25DaGFuZ2VcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtY2hlY2tib3hfX2JhY2tncm91bmRcIj5cbiAgICAgICAgPHN2Z1xuICAgICAgICAgIGNsYXNzPVwibWRjLWNoZWNrYm94X19jaGVja21hcmtcIlxuICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgY2xhc3M9XCJtZGMtY2hlY2tib3hfX2NoZWNrbWFyay1wYXRoXCJcbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbiAgICAgICAgICAgIGQ9XCJNMS43MywxMi45MSA4LjEsMTkuMjggMjIuNzksNC41OVwiLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtY2hlY2tib3hfX21peGVkbWFya1wiLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxsYWJlbFxuICAgICAgcmVmPVwibGFiZWxcIlxuICAgICAgOmZvcj1cInZtYV91aWRfXCJcbiAgICA+PHNsb3Q+e3sgbGFiZWwgfX08L3Nsb3Q+PC9sYWJlbD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG5pbXBvcnQgTURDQ2hlY2tib3hGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9jaGVja2JveC9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Zvcm0tZmllbGQvZm91bmRhdGlvbidcbmltcG9ydCB7IGdldENvcnJlY3RFdmVudE5hbWUgfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uJ1xuaW1wb3J0IHsgRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5pbXBvcnQgeyBhcHBseVBhc3NpdmUgfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hlY2tib3gnLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdjaGVja2VkJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBjaGVja2VkOiBbQm9vbGVhbiwgQXJyYXldLFxuICAgIGluZGV0ZXJtaW5hdGU6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAnb24nXG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBTdHJpbmdcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGNsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGhhc0xhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWwgfHwgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIH0sXG4gICAgZm9ybUZpZWxkQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtZm9ybS1maWVsZCc6IHRoaXMuaGFzTGFiZWwsXG4gICAgICAgICdtZGMtZm9ybS1maWVsZC0tYWxpZ24tZW5kJzogdGhpcy5oYXNMYWJlbCAmJiB0aGlzLmFsaWduRW5kXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGNoZWNrZWQ6ICdzZXRDaGVja2VkJyxcbiAgICBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHZhbHVlKVxuICAgIH0sXG4gICAgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEluZGV0ZXJtaW5hdGUodmFsdWUpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENDaGVja2JveEZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgc2V0TmF0aXZlQ29udHJvbEF0dHI6IChhdHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyOiBhdHRyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLFxuICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgKSxcbiAgICAgIGRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAnYW5pbWF0aW9uZW5kJyksXG4gICAgICAgICAgaGFuZGxlclxuICAgICAgICApLFxuICAgICAgcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVyKSxcbiAgICAgIGdldE5hdGl2ZUNvbnRyb2w6ICgpID0+IHRoaXMuJHJlZnMuY29udHJvbCxcbiAgICAgIGZvcmNlTGF5b3V0OiAoKSA9PiB0aGlzLiRyZWZzLnJvb3Qub2Zmc2V0V2lkdGgsXG4gICAgICBpc0F0dGFjaGVkVG9ET006ICgpID0+IEJvb2xlYW4odGhpcy4kZWwucGFyZW50Tm9kZSlcbiAgICB9KVxuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzLCB7XG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gdHJ1ZSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gUmlwcGxlQmFzZS5pc1N1cmZhY2VBY3RpdmUodGhpcy4kcmVmcy5jb250cm9sKSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvcm1GaWVsZCA9IG5ldyBNRENGb3JtRmllbGRGb3VuZGF0aW9uKHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmFjdGl2YXRlKClcbiAgICAgIH0sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVhY3RpdmF0ZSgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgICB0aGlzLmZvcm1GaWVsZC5pbml0KClcbiAgICB0aGlzLnNldENoZWNrZWQodGhpcy5jaGVja2VkKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRJbmRldGVybWluYXRlKHRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvcm1GaWVsZC5kZXN0cm95KClcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRDaGVja2VkKFxuICAgICAgICBBcnJheS5pc0FycmF5KGNoZWNrZWQpID8gY2hlY2tlZC5pbmRleE9mKHRoaXMudmFsdWUpID4gLTEgOiBjaGVja2VkXG4gICAgICApXG4gICAgfSxcblxuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmluZGV0ZXJtaW5hdGUnLCB0aGlzLmZvdW5kYXRpb24uaXNJbmRldGVybWluYXRlKCkpXG4gICAgICBjb25zdCBpc0NoZWNrZWQgPSB0aGlzLmZvdW5kYXRpb24uaXNDaGVja2VkKClcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jaGVja2VkKSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmNoZWNrZWQuaW5kZXhPZih0aGlzLnZhbHVlKVxuICAgICAgICBpZiAoaXNDaGVja2VkKSB7XG4gICAgICAgICAgaWR4IDwgMCAmJiB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmNoZWNrZWQuY29uY2F0KHRoaXMudmFsdWUpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkeCA+IC0xICYmXG4gICAgICAgICAgICB0aGlzLiRlbWl0KFxuICAgICAgICAgICAgICAnY2hhbmdlJyxcbiAgICAgICAgICAgICAgdGhpcy5jaGVja2VkLnNsaWNlKDAsIGlkeCkuY29uY2F0KHRoaXMuY2hlY2tlZC5zbGljZShpZHggKyAxKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgaXNDaGVja2VkKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNDaGVja2JveCBmcm9tICcuL21kYy1jaGVja2JveC52dWUnXG5cbmV4cG9ydCB7IG1kY0NoZWNrYm94IH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0NoZWNrYm94XG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBDaGlwLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIENoaXAgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoaXBBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByb290IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgbGVhZGluZyBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzVG9MZWFkaW5nSWNvbihjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBsZWFkaW5nIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb24oY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGFyZ2V0IGhhcyBjbGFzc05hbWUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIHshRXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBldmVudFRhcmdldEhhc0NsYXNzKHRhcmdldCwgY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgdHJhaWxpbmcgaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHRyYWlsaW5nIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gXCJNRENDaGlwOmludGVyYWN0aW9uXCIgZXZlbnQgZGVub3RpbmcgdGhlIGNoaXAgaGFzIGJlZW5cbiAgICogaW50ZXJhY3RlZCB3aXRoICh0eXBpY2FsbHkgb24gY2xpY2sgb3Iga2V5ZG93bikuXG4gICAqL1xuICBub3RpZnlJbnRlcmFjdGlvbigpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIFwiTURDQ2hpcDp0cmFpbGluZ0ljb25JbnRlcmFjdGlvblwiIGV2ZW50IGRlbm90aW5nIHRoZSB0cmFpbGluZyBpY29uIGhhcyBiZWVuXG4gICAqIGludGVyYWN0ZWQgd2l0aCAodHlwaWNhbGx5IG9uIGNsaWNrIG9yIGtleWRvd24pLlxuICAgKi9cbiAgbm90aWZ5VHJhaWxpbmdJY29uSW50ZXJhY3Rpb24oKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBcIk1EQ0NoaXA6cmVtb3ZhbFwiIGRlbm90aW5nIHRoZSBjaGlwIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICovXG4gIG5vdGlmeVJlbW92YWwoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gc3R5bGUgcHJvcGVydHkgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRDb21wdXRlZFN0eWxlVmFsdWUocHJvcGVydHlOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gc3R5bGUgcHJvcGVydHkgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFN0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBFTlRSWV9BTklNQVRJT05fTkFNRTogJ21kYy1jaGlwLWVudHJ5JyxcbiAgSU5URVJBQ1RJT05fRVZFTlQ6ICdNRENDaGlwOmludGVyYWN0aW9uJyxcbiAgVFJBSUxJTkdfSUNPTl9JTlRFUkFDVElPTl9FVkVOVDogJ01EQ0NoaXA6dHJhaWxpbmdJY29uSW50ZXJhY3Rpb24nLFxuICBSRU1PVkFMX0VWRU5UOiAnTURDQ2hpcDpyZW1vdmFsJyxcbiAgQ0hFQ0tNQVJLX1NFTEVDVE9SOiAnLm1kYy1jaGlwX19jaGVja21hcmsnLFxuICBMRUFESU5HX0lDT05fU0VMRUNUT1I6ICcubWRjLWNoaXBfX2ljb24tLWxlYWRpbmcnLFxuICBUUkFJTElOR19JQ09OX1NFTEVDVE9SOiAnLm1kYy1jaGlwX19pY29uLS10cmFpbGluZycsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIENIRUNLTUFSSzogJ21kYy1jaGlwX19jaGVja21hcmsnLFxuICBDSElQOiAnbWRjLWNoaXAnLFxuICBDSElQX0VYSVQ6ICdtZGMtY2hpcC0tZXhpdCcsXG4gIEhJRERFTl9MRUFESU5HX0lDT046ICdtZGMtY2hpcF9faWNvbi0tbGVhZGluZy1oaWRkZW4nLFxuICBMRUFESU5HX0lDT046ICdtZGMtY2hpcF9faWNvbi0tbGVhZGluZycsXG4gIFRSQUlMSU5HX0lDT046ICdtZGMtY2hpcF9faWNvbi0tdHJhaWxpbmcnLFxuICBTRUxFQ1RFRDogJ21kYy1jaGlwLS1zZWxlY3RlZCcsXG4gIFRFWFQ6ICdtZGMtY2hpcF9fdGV4dCcsXG59O1xuXG5leHBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0NoaXBBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENDaGlwQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDQ2hpcEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENDaGlwQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENDaGlwQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoaXBBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgYWRkQ2xhc3NUb0xlYWRpbmdJY29uOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uOiAoKSA9PiB7fSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUludGVyYWN0aW9uOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeVRyYWlsaW5nSWNvbkludGVyYWN0aW9uOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeVJlbW92YWw6ICgpID0+IHt9LFxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOiAoKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlUHJvcGVydHk6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENDaGlwRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVJbnRlcmFjdGlvbl8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYWlsaW5nSWNvbkludGVyYWN0aW9uXyhldnQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nLCAndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nLCAndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy50cmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTZWxlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLlNFTEVDVEVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqL1xuICBzZXRTZWxlY3RlZChzZWxlY3RlZCkge1xuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlNFTEVDVEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLlNFTEVDVEVEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudCBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbl8oZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUludGVyYWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSB0cmFuc2l0aW9uIGVuZCBldmVudCBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpIHtcbiAgICAvLyBIYW5kbGUgdHJhbnNpdGlvbiBlbmQgZXZlbnQgb24gdGhlIGNoaXAgd2hlbiBpdCBpcyBhYm91dCB0byBiZSByZW1vdmVkLlxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3MoLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChldnQudGFyZ2V0KSwgY3NzQ2xhc3Nlcy5DSElQX0VYSVQpKSB7XG4gICAgICBpZiAoZXZ0LnByb3BlcnR5TmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVJlbW92YWwoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZ0LnByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS91c2luZy1jc3MtdHJhbnNpdGlvbnMtYXV0by1kaW1lbnNpb25zLyNhcnRpY2xlLWhlYWRlci1pZC01XG4gICAgICAgIGNvbnN0IGNoaXBXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCd3aWR0aCcpO1xuXG4gICAgICAgIC8vIE9uIHRoZSBuZXh0IGZyYW1lIChvbmNlIHdlIGdldCB0aGUgY29tcHV0ZWQgd2lkdGgpLCBleHBsaWNpdGx5IHNldCB0aGUgY2hpcCdzIHdpZHRoXG4gICAgICAgIC8vIHRvIGl0cyBjdXJyZW50IHBpeGVsIHdpZHRoLCBzbyB3ZSBhcmVuJ3QgdHJhbnNpdGlvbmluZyBvdXQgb2YgJ2F1dG8nLlxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVQcm9wZXJ0eSgnd2lkdGgnLCBjaGlwV2lkdGgpO1xuXG4gICAgICAgICAgLy8gVG8gbWl0aWdhdGUgaml0dGVyLCBzdGFydCB0cmFuc2l0aW9uaW5nIHBhZGRpbmcgYW5kIG1hcmdpbiBiZWZvcmUgd2lkdGguXG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZVByb3BlcnR5KCdwYWRkaW5nJywgJzAnKTtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlUHJvcGVydHkoJ21hcmdpbicsICcwJyk7XG5cbiAgICAgICAgICAvLyBPbiB0aGUgbmV4dCBmcmFtZSAob25jZSB3aWR0aCBpcyBleHBsaWNpdGx5IHNldCksIHRyYW5zaXRpb24gd2lkdGggdG8gMC5cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZVByb3BlcnR5KCd3aWR0aCcsICcwJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBhIHRyYW5zaXRpb24gZW5kIGV2ZW50IG9uIHRoZSBsZWFkaW5nIGljb24gb3IgY2hlY2ttYXJrLCBzaW5jZSB0aGUgdHJhbnNpdGlvbiBlbmQgZXZlbnQgYnViYmxlcy5cbiAgICBpZiAoZXZ0LnByb3BlcnR5TmFtZSAhPT0gJ29wYWNpdHknKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3MoLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChldnQudGFyZ2V0KSwgY3NzQ2xhc3Nlcy5MRUFESU5HX0lDT04pICYmXG4gICAgICAgIHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3NUb0xlYWRpbmdJY29uKGNzc0NsYXNzZXMuSElEREVOX0xFQURJTkdfSUNPTik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3MoLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChldnQudGFyZ2V0KSwgY3NzQ2xhc3Nlcy5DSEVDS01BUkspICYmXG4gICAgICAgICAgICAgICAhdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLlNFTEVDVEVEKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzc0Zyb21MZWFkaW5nSWNvbihjc3NDbGFzc2VzLkhJRERFTl9MRUFESU5HX0lDT04pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGFuIGludGVyYWN0aW9uIGV2ZW50IG9uIHRoZSB0cmFpbGluZyBpY29uIGVsZW1lbnQuIFRoaXMgaXMgdXNlZCB0b1xuICAgKiBwcmV2ZW50IHRoZSByaXBwbGUgZnJvbSBhY3RpdmF0aW5nIG9uIGludGVyYWN0aW9uIHdpdGggdGhlIHRyYWlsaW5nIGljb24uXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRyYWlsaW5nSWNvbkludGVyYWN0aW9uXyhldnQpIHtcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVRyYWlsaW5nSWNvbkludGVyYWN0aW9uKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQ0hJUF9FWElUKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcEZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIHRhYmluZGV4PVwiMFwiXG4gICAgdi1vbj1cIiRsaXN0ZW5lcnNcIj5cbiAgICA8aVxuICAgICAgdi1pZj1cImhhdmVsZWFkaW5nSWNvblwiXG4gICAgICByZWY9XCJsZWFkaW5nSWNvblwiXG4gICAgICA6Y2xhc3M9XCJsZWFkaW5nQ2xhc3Nlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1jaGlwX19pY29uIG1kYy1jaGlwX19pY29uLS1sZWFkaW5nXCJcbiAgICA+e3sgbGVhZGluZ0ljb24gfX08L2k+XG4gICAgPGRpdlxuICAgICAgdi1pZj1cImlzRmlsdGVyXCJcbiAgICAgIGNsYXNzPVwibWRjLWNoaXBfX2NoZWNrbWFya1wiPlxuICAgICAgPHN2Z1xuICAgICAgICBjbGFzcz1cIm1kYy1jaGlwX19jaGVja21hcmstc3ZnXCJcbiAgICAgICAgdmlld0JveD1cIi0yIC0zIDMwIDMwXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3M9XCJtZGMtY2hpcF9fY2hlY2ttYXJrLXBhdGhcIlxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBzdHJva2U9XCJibGFja1wiXG4gICAgICAgICAgZD1cIk0xLjczLDEyLjkxIDguMSwxOS4yOCAyMi43OSw0LjU5XCIvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1jaGlwX190ZXh0XCI+XG4gICAgICA8c2xvdC8+XG4gICAgPC9kaXY+XG4gICAgPGlcbiAgICAgIHYtaWY9XCJoYXZldHJhaWxpbmdJY29uXCJcbiAgICAgIHJlZj1cInRyYWlsaW5nSWNvblwiXG4gICAgICA6Y2xhc3M9XCJ0cmFpbGluZ0NsYXNzZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtY2hpcF9faWNvbiBtZGMtY2hpcF9faWNvbi0tdHJhaWxpbmdcIlxuICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgID57eyB0cmFpbGluZ0ljb24gfX08L2k+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmFwcGx5UGFzc2l2ZVxuPHNjcmlwdD5cbmltcG9ydCBNRENDaGlwRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvY2hpcHMvY2hpcC9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgQ3VzdG9tTGlua01peGluLCBlbWl0Q3VzdG9tRXZlbnQsIGFwcGx5UGFzc2l2ZSB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hpcCcsXG4gIG1peGluczogW0N1c3RvbUxpbmtNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgbGVhZGluZ0ljb246IFtTdHJpbmddLFxuICAgIHRyYWlsaW5nSWNvbjogW1N0cmluZ10sXG4gICAgbGVhZGluZ0ljb25DbGFzc2VzOiBbT2JqZWN0XSxcbiAgICB0cmFpbGluZ0ljb25DbGFzc2VzOiBbT2JqZWN0XVxuICB9LFxuICBpbmplY3Q6IFsnbWRjQ2hpcFNldCddLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtY2hpcCc6IHRydWVcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzRmlsdGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjQ2hpcFNldCAmJiB0aGlzLm1kY0NoaXBTZXQuZmlsdGVyXG4gICAgfSxcbiAgICBoYXZlbGVhZGluZ0ljb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmxlYWRpbmdJY29uIHx8IHRoaXMubGVhZGluZ0ljb25DbGFzc2VzXG4gICAgfSxcbiAgICBoYXZldHJhaWxpbmdJY29uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy50cmFpbGluZ0ljb24gfHwgdGhpcy50cmFpbGluZ0ljb25DbGFzc2VzXG4gICAgfSxcbiAgICBsZWFkaW5nQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAge1xuICAgICAgICAgICdtYXRlcmlhbC1pY29ucyc6ICEhdGhpcy5sZWFkaW5nSWNvblxuICAgICAgICB9LFxuICAgICAgICB0aGlzLmxlYWRpbmdJY29uQ2xhc3Nlc1xuICAgICAgKVxuICAgIH0sXG4gICAgdHJhaWxpbmdDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLnRyYWlsaW5nSWNvblxuICAgICAgICB9LFxuICAgICAgICB0aGlzLnRyYWlsaW5nSWNvbkNsYXNzZXNcbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0NoaXBGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzc1RvTGVhZGluZ0ljb246IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmhhdmVsZWFkaW5nSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGVhZGluZ0ljb24uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzc0Zyb21MZWFkaW5nSWNvbjogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGF2ZWxlYWRpbmdJY29uKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5sZWFkaW5nSWNvbi5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICh0YXJnZXQsIGNsYXNzTmFtZSkgPT5cbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciksXG4gICAgICBub3RpZnlJbnRlcmFjdGlvbjogKCkgPT4ge1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgTURDQ2hpcEZvdW5kYXRpb24uc3RyaW5ncy5JTlRFUkFDVElPTl9FVkVOVCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlwOiB0aGlzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbjogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCd0cmFpbGluZ0ljb25DbGljaycpXG4gICAgICAgIGVtaXRDdXN0b21FdmVudChcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLlRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpcDogdGhpc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICB9LFxuXG4gICAgICByZWdpc3RlclRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMudHJhaWxpbmdJY29uKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy50cmFpbGluZ0ljb24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIGV2dFR5cGUsXG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy50cmFpbGluZ0ljb24pIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLnRyYWlsaW5nSWNvbi5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgZXZ0VHlwZSxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBhcHBseVBhc3NpdmUoKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vdGlmeVJlbW92YWw6ICgpID0+XG4gICAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLlJFTU9WQUxfRVZFTlQsXG4gICAgICAgICAgeyBjaGlwOiB0aGlzIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApLFxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOiBwcm9wZXJ0eU5hbWUgPT5cbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKSxcbiAgICAgIHNldFN0eWxlUHJvcGVydHk6IChwcm9wZXJ0eSwgdmFsdWUpID0+XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgcHJvcGVydHksIHZhbHVlKVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlU2VsZWN0ZWQoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24udG9nZ2xlU2VsZWN0ZWQoKVxuICAgIH0sXG4gICAgaXNTZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uaXNTZWxlY3RlZCgpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hpcCBTZXQuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgQ2hpcCBTZXQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoaXBTZXRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYW5kIHJldHVybnMgYSBuZXcgY2hpcCBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHRleHQsIGxlYWRpbmcgaWNvbiwgYW5kIHRyYWlsaW5nIGljb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7P0VsZW1lbnR9IGxlYWRpbmdJY29uXG4gICAqIEBwYXJhbSB7P0VsZW1lbnR9IHRyYWlsaW5nSWNvblxuICAgKiBAcmV0dXJuIHshRWxlbWVudH1cbiAgICovXG4gIGFwcGVuZENoaXAodGV4dCwgbGVhZGluZ0ljb24sIHRyYWlsaW5nSWNvbikge31cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY2hpcCBvYmplY3QgZnJvbSB0aGUgY2hpcCBzZXQuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gY2hpcFxuICAgKi9cbiAgcmVtb3ZlQ2hpcChjaGlwKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGlwU2V0QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIENISVBfU0VMRUNUT1I6ICcubWRjLWNoaXAnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBDSE9JQ0U6ICdtZGMtY2hpcC1zZXQtLWNob2ljZScsXG4gIEZJTFRFUjogJ21kYy1jaGlwLXNldC0tZmlsdGVyJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDQ2hpcFNldEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENDaGlwRm91bmRhdGlvbiBmcm9tICcuLi9jaGlwL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0NoaXBTZXRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENDaGlwU2V0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0NoaXBTZXRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0NoaXBTZXRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDQ2hpcFNldEFkYXB0ZXJ9ICovICh7XG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGFwcGVuZENoaXA6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2hpcDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDQ2hpcFNldEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoaXBTZXRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0ZWQgY2hpcHMgaW4gdGhlIHNldC4gT25seSB1c2VkIGZvciBjaG9pY2UgY2hpcCBzZXQgb3IgZmlsdGVyIGNoaXAgc2V0LlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8IU1EQ0NoaXBGb3VuZGF0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfID0gW107XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmNoaXBJbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVDaGlwSW50ZXJhY3Rpb25fKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5jaGlwUmVtb3ZhbEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVDaGlwUmVtb3ZhbF8oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RJT05fRVZFTlQsIHRoaXMuY2hpcEludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoXG4gICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLlJFTU9WQUxfRVZFTlQsIHRoaXMuY2hpcFJlbW92YWxIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RJT05fRVZFTlQsIHRoaXMuY2hpcEludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuUkVNT1ZBTF9FVkVOVCwgdGhpcy5jaGlwUmVtb3ZhbEhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGNoaXAgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiB0ZXh0LCBsZWFkaW5nIGljb24sIGFuZCB0cmFpbGluZyBpY29uLFxuICAgKiBhZGRlZCB0byB0aGUgcm9vdCBjaGlwIHNldCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0gez9FbGVtZW50fSBsZWFkaW5nSWNvblxuICAgKiBAcGFyYW0gez9FbGVtZW50fSB0cmFpbGluZ0ljb25cbiAgICogQHJldHVybiB7IUVsZW1lbnR9XG4gICAqL1xuICBhZGRDaGlwKHRleHQsIGxlYWRpbmdJY29uLCB0cmFpbGluZ0ljb24pIHtcbiAgICBjb25zdCBjaGlwRWwgPSB0aGlzLmFkYXB0ZXJfLmFwcGVuZENoaXAodGV4dCwgbGVhZGluZ0ljb24sIHRyYWlsaW5nSWNvbik7XG4gICAgcmV0dXJuIGNoaXBFbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBjaGlwLiBEZXNlbGVjdHMgYWxsIG90aGVyIGNoaXBzIGlmIHRoZSBjaGlwIHNldCBpcyBvZiB0aGUgY2hvaWNlIHZhcmlhbnQuXG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBGb3VuZGF0aW9ufSBjaGlwRm91bmRhdGlvblxuICAgKi9cbiAgc2VsZWN0KGNoaXBGb3VuZGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5DSE9JQ0UpKSB7XG4gICAgICB0aGlzLmRlc2VsZWN0QWxsXygpO1xuICAgIH1cbiAgICBjaGlwRm91bmRhdGlvbi5zZXRTZWxlY3RlZCh0cnVlKTtcbiAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfLnB1c2goY2hpcEZvdW5kYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gY2hpcC5cbiAgICogQHBhcmFtIHshTURDQ2hpcEZvdW5kYXRpb259IGNoaXBGb3VuZGF0aW9uXG4gICAqL1xuICBkZXNlbGVjdChjaGlwRm91bmRhdGlvbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zZWxlY3RlZENoaXBzXy5pbmRleE9mKGNoaXBGb3VuZGF0aW9uKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5zZWxlY3RlZENoaXBzXy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBjaGlwRm91bmRhdGlvbi5zZXRTZWxlY3RlZChmYWxzZSk7XG4gIH1cblxuICAvKiogRGVzZWxlY3RzIGFsbCBzZWxlY3RlZCBjaGlwcy4gKi9cbiAgZGVzZWxlY3RBbGxfKCkge1xuICAgIHRoaXMuc2VsZWN0ZWRDaGlwc18uZm9yRWFjaCgoY2hpcEZvdW5kYXRpb24pID0+IHtcbiAgICAgIGNoaXBGb3VuZGF0aW9uLnNldFNlbGVjdGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNoaXAgaW50ZXJhY3Rpb24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2hpcEludGVyYWN0aW9uXyhldnQpIHtcbiAgICBjb25zdCBjaGlwRm91bmRhdGlvbiA9IGV2dC5kZXRhaWwuY2hpcC5mb3VuZGF0aW9uO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuQ0hPSUNFKSB8fCB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuRklMVEVSKSkge1xuICAgICAgaWYgKGNoaXBGb3VuZGF0aW9uLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLmRlc2VsZWN0KGNoaXBGb3VuZGF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0KGNoaXBGb3VuZGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZXZlbnQgd2hlbiBhIGNoaXAgaXMgcmVtb3ZlZC5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2hpcFJlbW92YWxfKGV2dCkge1xuICAgIGNvbnN0IHtjaGlwfSA9IGV2dC5kZXRhaWw7XG4gICAgdGhpcy5kZXNlbGVjdChjaGlwLmZvdW5kYXRpb24pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2hpcChjaGlwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGlwU2V0Rm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgdi1vbj1cIiRsaXN0ZW5lcnNcIj5cbiAgICA8c2xvdC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENDaGlwU2V0Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvZm91bmRhdGlvbidcbmltcG9ydCBNRENDaGlwRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvY2hpcHMvY2hpcC9mb3VuZGF0aW9uJ1xuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNoaXAtc2V0JyxcbiAgcHJvcHM6IHtcbiAgICBjaG9pY2U6IFtCb29sZWFuXSxcbiAgICBmaWx0ZXI6IFtCb29sZWFuXSxcbiAgICBpbnB1dDogW0Jvb2xlYW5dXG4gIH0sXG4gIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHsgbWRjQ2hpcFNldDogdGhpcyB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1jaGlwLXNldCc6IHRydWUsXG4gICAgICAgICdtZGMtY2hpcC1zZXQtLWNob2ljZSc6IHRoaXMuY2hvaWNlLFxuICAgICAgICAnbWRjLWNoaXAtc2V0LS1maWx0ZXInOiB0aGlzLmZpbHRlcixcbiAgICAgICAgJ21kYy1jaGlwLXNldC0taW5wdXQnOiB0aGlzLmlucHV0XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENDaGlwU2V0Rm91bmRhdGlvbih7XG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgYXBwZW5kQ2hpcDogKHRleHQsIGxlYWRpbmdJY29uLCB0cmFpbGluZ0ljb24pID0+IHtcbiAgICAgICAgY29uc3QgY2hpcFRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGNoaXBUZXh0RWwuY2xhc3NMaXN0LmFkZChNRENDaGlwRm91bmRhdGlvbi5jc3NDbGFzc2VzLlRFWFQpXG4gICAgICAgIGNoaXBUZXh0RWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXG5cbiAgICAgICAgY29uc3QgY2hpcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgY2hpcEVsLmNsYXNzTGlzdC5hZGQoTURDQ2hpcEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5DSElQKVxuICAgICAgICBpZiAobGVhZGluZ0ljb24pIHtcbiAgICAgICAgICBjaGlwRWwuYXBwZW5kQ2hpbGQobGVhZGluZ0ljb24pXG4gICAgICAgIH1cbiAgICAgICAgY2hpcEVsLmFwcGVuZENoaWxkKGNoaXBUZXh0RWwpXG4gICAgICAgIGlmICh0cmFpbGluZ0ljb24pIHtcbiAgICAgICAgICBjaGlwRWwuYXBwZW5kQ2hpbGQodHJhaWxpbmdJY29uKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdF8uYXBwZW5kQ2hpbGQoY2hpcEVsKVxuICAgICAgICByZXR1cm4gY2hpcEVsXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2hpcDogY2hpcCA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlwcy5pbmRleE9mKGNoaXApXG4gICAgICAgIHRoaXMuY2hpcHMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICBjaGlwLnJlbW92ZSgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHt9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0NoaXAgZnJvbSAnLi9tZGMtY2hpcC52dWUnXG5pbXBvcnQgbWRjQ2hpcFNldCBmcm9tICcuL21kYy1jaGlwLXNldC52dWUnXG5cbmV4cG9ydCB7IG1kY0NoaXAsIG1kY0NoaXBTZXQgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjQ2hpcCxcbiAgbWRjQ2hpcFNldFxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCB7TURDRm91bmRhdGlvbiwgTURDQ29tcG9uZW50fTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWRpYWxvZycsXG4gIE9QRU46ICdtZGMtZGlhbG9nLS1vcGVuJyxcbiAgQU5JTUFUSU5HOiAnbWRjLWRpYWxvZy0tYW5pbWF0aW5nJyxcbiAgQkFDS0RST1A6ICdtZGMtZGlhbG9nX19iYWNrZHJvcCcsXG4gIFNDUk9MTF9MT0NLOiAnbWRjLWRpYWxvZy1zY3JvbGwtbG9jaycsXG4gIEFDQ0VQVF9CVE46ICdtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tYWNjZXB0JyxcbiAgQ0FOQ0VMX0JUTjogJ21kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uLS1jYW5jZWwnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIE9QRU5fRElBTE9HX1NFTEVDVE9SOiAnLm1kYy1kaWFsb2ctLW9wZW4nLFxuICBESUFMT0dfU1VSRkFDRV9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19zdXJmYWNlJyxcbiAgQUNDRVBUX1NFTEVDVE9SOiAnLm1kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uLS1hY2NlcHQnLFxuICBBQ0NFUFRfRVZFTlQ6ICdNRENEaWFsb2c6YWNjZXB0JyxcbiAgQ0FOQ0VMX0VWRU5UOiAnTURDRGlhbG9nOmNhbmNlbCcsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDRGlhbG9nRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYWRkQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKC8qIHRhcmdldDogRXZlbnRUYXJnZXQsIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeUFjY2VwdDogKCkgPT4ge30sXG4gICAgICBub3RpZnlDYW5jZWw6ICgpID0+IHt9LFxuICAgICAgdHJhcEZvY3VzT25TdXJmYWNlOiAoKSA9PiB7fSxcbiAgICAgIHVudHJhcEZvY3VzT25TdXJmYWNlOiAoKSA9PiB7fSxcbiAgICAgIGlzRGlhbG9nOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKGV2dC50YXJnZXQsIGNzc0NsYXNzZXMuQkFDS0RST1ApKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVEaWFsb2dDbGlja18oZXZ0KTtcbiAgICB0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgJiYgZXZ0LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZ0LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG4gIH07XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCBkaWFsb2cgaXMgY2xlYW5lZCB1cCB3aGVuIGRlc3Ryb3llZFxuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udW50cmFwRm9jdXNPblN1cmZhY2UoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpYWxvZ0NsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgYWNjZXB0KHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5QWNjZXB0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgY2FuY2VsKHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgaGFuZGxlRGlhbG9nQ2xpY2tfKGV2dCkge1xuICAgIGNvbnN0IHt0YXJnZXR9ID0gZXZ0O1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3ModGFyZ2V0LCBjc3NDbGFzc2VzLkFDQ0VQVF9CVE4pKSB7XG4gICAgICB0aGlzLmFjY2VwdCh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNzc0NsYXNzZXMuQ0FOQ0VMX0JUTikpIHtcbiAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzRGlhbG9nKGV2dC50YXJnZXQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgZWxlbWVudERvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCB8fCBlbDtcbiAgdmFyIGJhc2ljVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG5cbiAgLy8gQSBub2RlIGlzIFwiYXZhaWxhYmxlXCIgaWZcbiAgLy8gLSBpdCdzIGNvbXB1dGVkIHN0eWxlXG4gIHZhciBpc1VuYXZhaWxhYmxlID0gY3JlYXRlSXNVbmF2YWlsYWJsZShlbGVtZW50RG9jdW1lbnQpO1xuXG4gIHZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICAgJ2lucHV0JyxcbiAgICAnc2VsZWN0JyxcbiAgICAnYVtocmVmXScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnW3RhYmluZGV4XScsXG4gIF07XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJykpO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVDb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgaWYgKFxuICAgICAgY2FuZGlkYXRlU2VsZWN0b3JzLnNvbWUoZnVuY3Rpb24oY2FuZGlkYXRlU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoY2FuZGlkYXRlcyk7XG4gICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjYW5kaWRhdGUsIGNhbmRpZGF0ZUluZGV4QXR0ciwgY2FuZGlkYXRlSW5kZXg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2FuZGlkYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2ldO1xuICAgIGNhbmRpZGF0ZUluZGV4QXR0ciA9IHBhcnNlSW50KGNhbmRpZGF0ZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKVxuICAgIGNhbmRpZGF0ZUluZGV4ID0gaXNOYU4oY2FuZGlkYXRlSW5kZXhBdHRyKSA/IGNhbmRpZGF0ZS50YWJJbmRleCA6IGNhbmRpZGF0ZUluZGV4QXR0cjtcblxuICAgIGlmIChcbiAgICAgIGNhbmRpZGF0ZUluZGV4IDwgMFxuICAgICAgfHwgKGNhbmRpZGF0ZS50YWdOYW1lID09PSAnSU5QVVQnICYmIGNhbmRpZGF0ZS50eXBlID09PSAnaGlkZGVuJylcbiAgICAgIHx8IGNhbmRpZGF0ZS5kaXNhYmxlZFxuICAgICAgfHwgaXNVbmF2YWlsYWJsZShjYW5kaWRhdGUsIGVsZW1lbnREb2N1bWVudClcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjYW5kaWRhdGVJbmRleCA9PT0gMCkge1xuICAgICAgYmFzaWNUYWJiYWJsZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZUluZGV4LFxuICAgICAgICBub2RlOiBjYW5kaWRhdGUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGFiYmFibGVOb2RlcyA9IG9yZGVyZWRUYWJiYWJsZXNcbiAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleCA/IGEuaW5kZXggLSBiLmluZGV4IDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG4gICAgfSlcbiAgICAubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhLm5vZGVcbiAgICB9KTtcblxuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0YWJiYWJsZU5vZGVzLCBiYXNpY1RhYmJhYmxlcyk7XG5cbiAgcmV0dXJuIHRhYmJhYmxlTm9kZXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUlzVW5hdmFpbGFibGUoZWxlbWVudERvY3VtZW50KSB7XG4gIC8vIE5vZGUgY2FjaGUgbXVzdCBiZSByZWZyZXNoZWQgb24gZXZlcnkgY2hlY2ssIGluIGNhc2VcbiAgLy8gdGhlIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQgaGFzIGNoYW5nZWRcbiAgdmFyIGlzT2ZmQ2FjaGUgPSBbXTtcblxuICAvLyBcIm9mZlwiIG1lYW5zIGBkaXNwbGF5OiBub25lO2AsIGFzIG9wcG9zZWQgdG8gXCJoaWRkZW5cIixcbiAgLy8gd2hpY2ggbWVhbnMgYHZpc2liaWxpdHk6IGhpZGRlbjtgLiBnZXRDb21wdXRlZFN0eWxlXG4gIC8vIGFjY3VyYXRlbHkgcmVmbGVjdHMgdmlzaWJsaXR5IGluIGNvbnRleHQgYnV0IG5vdFxuICAvLyBcIm9mZlwiIHN0YXRlLCBzbyB3ZSBuZWVkIHRvIHJlY3Vyc2l2ZWx5IGNoZWNrIHBhcmVudHMuXG5cbiAgZnVuY3Rpb24gaXNPZmYobm9kZSwgbm9kZUNvbXB1dGVkU3R5bGUpIHtcbiAgICBpZiAobm9kZSA9PT0gZWxlbWVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gRmluZCB0aGUgY2FjaGVkIG5vZGUgKEFycmF5LnByb3RvdHlwZS5maW5kIG5vdCBhdmFpbGFibGUgaW4gSUU5KVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBpc09mZkNhY2hlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXNPZmZDYWNoZVtpXVswXSA9PT0gbm9kZSkgcmV0dXJuIGlzT2ZmQ2FjaGVbaV1bMV07XG4gICAgfVxuXG4gICAgbm9kZUNvbXB1dGVkU3R5bGUgPSBub2RlQ29tcHV0ZWRTdHlsZSB8fCBlbGVtZW50RG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIGlmIChub2RlQ29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHJlc3VsdCA9IGlzT2ZmKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgfVxuXG4gICAgaXNPZmZDYWNoZS5wdXNoKFtub2RlLCByZXN1bHRdKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gaXNVbmF2YWlsYWJsZShub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVsZW1lbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICBpZiAoaXNPZmYobm9kZSwgY29tcHV0ZWRTdHlsZSkpIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbic7XG4gIH1cbn1cbiIsInZhciB0YWJiYWJsZSA9IHJlcXVpcmUoJ3RhYmJhYmxlJyk7XG5cbnZhciBsaXN0ZW5pbmdGb2N1c1RyYXAgPSBudWxsO1xuXG5mdW5jdGlvbiBmb2N1c1RyYXAoZWxlbWVudCwgdXNlck9wdGlvbnMpIHtcbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBbXTtcbiAgdmFyIGZpcnN0VGFiYmFibGVOb2RlID0gbnVsbDtcbiAgdmFyIGxhc3RUYWJiYWJsZU5vZGUgPSBudWxsO1xuICB2YXIgbm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uID0gbnVsbDtcbiAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHZhciB0YWJFdmVudCA9IG51bGw7XG5cbiAgdmFyIGNvbnRhaW5lciA9ICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpXG4gICAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpXG4gICAgOiBlbGVtZW50O1xuXG4gIHZhciBjb25maWcgPSB1c2VyT3B0aW9ucyB8fCB7fTtcbiAgY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlID0gKHVzZXJPcHRpb25zICYmIHVzZXJPcHRpb25zLnJldHVybkZvY3VzT25EZWFjdGl2YXRlICE9PSB1bmRlZmluZWQpXG4gICAgPyB1c2VyT3B0aW9ucy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZVxuICAgIDogdHJ1ZTtcbiAgY29uZmlnLmVzY2FwZURlYWN0aXZhdGVzID0gKHVzZXJPcHRpb25zICYmIHVzZXJPcHRpb25zLmVzY2FwZURlYWN0aXZhdGVzICE9PSB1bmRlZmluZWQpXG4gICAgPyB1c2VyT3B0aW9ucy5lc2NhcGVEZWFjdGl2YXRlc1xuICAgIDogdHJ1ZTtcblxuICB2YXIgdHJhcCA9IHtcbiAgICBhY3RpdmF0ZTogYWN0aXZhdGUsXG4gICAgZGVhY3RpdmF0ZTogZGVhY3RpdmF0ZSxcbiAgICBwYXVzZTogcGF1c2UsXG4gICAgdW5wYXVzZTogdW5wYXVzZSxcbiAgfTtcblxuICByZXR1cm4gdHJhcDtcblxuICBmdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAoYWN0aXZlKSByZXR1cm47XG5cbiAgICB2YXIgZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zID0ge1xuICAgICAgb25BY3RpdmF0ZTogKGFjdGl2YXRlT3B0aW9ucyAmJiBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlXG4gICAgICAgIDogY29uZmlnLm9uQWN0aXZhdGUsXG4gICAgfTtcblxuICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgbm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgIGlmIChkZWZhdWx0ZWRBY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZSkge1xuICAgICAgZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGUoZGVhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAoIWFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgdmFyIGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zID0ge1xuICAgICAgcmV0dXJuRm9jdXM6IChkZWFjdGl2YXRlT3B0aW9ucyAmJiBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1cyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzXG4gICAgICAgIDogY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlLFxuICAgICAgb25EZWFjdGl2YXRlOiAoZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlICE9PSB1bmRlZmluZWQpXG4gICAgICAgID8gZGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlXG4gICAgICAgIDogY29uZmlnLm9uRGVhY3RpdmF0ZSxcbiAgICB9O1xuXG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAoZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlKSB7XG4gICAgICBkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucy5vbkRlYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnlGb2N1cyhub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgYWN0aXZlID0gZmFsc2U7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAocGF1c2VkIHx8ICFhY3RpdmUpIHJldHVybjtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoIXBhdXNlZCB8fCAhYWN0aXZlKSByZXR1cm47XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFhY3RpdmUpIHJldHVybjtcblxuICAgIC8vIFRoZXJlIGNhbiBiZSBvbmx5IG9uZSBsaXN0ZW5pbmcgZm9jdXMgdHJhcCBhdCBhIHRpbWVcbiAgICBpZiAobGlzdGVuaW5nRm9jdXNUcmFwKSB7XG4gICAgICBsaXN0ZW5pbmdGb2N1c1RyYXAucGF1c2UoKTtcbiAgICB9XG4gICAgbGlzdGVuaW5nRm9jdXNUcmFwID0gdHJhcDtcblxuICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICB0cnlGb2N1cyhmaXJzdEZvY3VzTm9kZSgpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGNoZWNrRm9jdXMsIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBpZiAoIWFjdGl2ZSB8fCBsaXN0ZW5pbmdGb2N1c1RyYXAgIT09IHRyYXApIHJldHVybjtcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgY2hlY2tGb2N1cywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcblxuICAgIGxpc3RlbmluZ0ZvY3VzVHJhcCA9IG51bGw7XG5cbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVGb3JPcHRpb24ob3B0aW9uTmFtZSkge1xuICAgIHZhciBvcHRpb25WYWx1ZSA9IGNvbmZpZ1tvcHRpb25OYW1lXTtcbiAgICB2YXIgbm9kZSA9IG9wdGlvblZhbHVlO1xuICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9uVmFsdWUpO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBvcHRpb25OYW1lICsgJ2AgcmVmZXJzIHRvIG5vIGtub3duIG5vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbm9kZSA9IG9wdGlvblZhbHVlKCk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgJyArIG9wdGlvbk5hbWUgKyAnYCBkaWQgbm90IHJldHVybiBhIG5vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJzdEZvY3VzTm9kZSgpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAoZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJykgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgbm9kZSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSB0YWJiYWJsZU5vZGVzWzBdIHx8IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhblxcJ3QgaGF2ZSBhIGZvY3VzLXRyYXAgd2l0aG91dCBhdCBsZWFzdCBvbmUgZm9jdXNhYmxlIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBvbiBtb3VzZWRvd24gYW5kIHRvdWNoc3RhcnQgaW5zdGVhZCBvZiBjbGlja1xuICAvLyBzbyB0aGF0IGl0IHByZWNlZGVzIHRoZSBmb2N1cyBldmVudFxuICBmdW5jdGlvbiBjaGVja1BvaW50ZXJEb3duKGUpIHtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzICYmICFjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICBkZWFjdGl2YXRlKHsgcmV0dXJuRm9jdXM6IGZhbHNlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xpY2soZSkge1xuICAgIGlmIChjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMpIHJldHVybjtcbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tGb2N1cyhlKSB7XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAvLyBDaGVja2luZyBmb3IgYSBibHVyIG1ldGhvZCBoZXJlIHJlc29sdmVzIGEgRmlyZWZveCBpc3N1ZSAoIzE1KVxuICAgIGlmICh0eXBlb2YgZS50YXJnZXQuYmx1ciA9PT0gJ2Z1bmN0aW9uJykgZS50YXJnZXQuYmx1cigpO1xuXG4gICAgaWYgKHRhYkV2ZW50KSB7XG4gICAgICByZWFkanVzdEZvY3VzKHRhYkV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0tleShlKSB7XG4gICAgaWYgKGUua2V5ID09PSAnVGFiJyB8fCBlLmtleUNvZGUgPT09IDkpIHtcbiAgICAgIGhhbmRsZVRhYihlKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmVzY2FwZURlYWN0aXZhdGVzICE9PSBmYWxzZSAmJiBpc0VzY2FwZUV2ZW50KGUpKSB7XG4gICAgICBkZWFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVGFiKGUpIHtcbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG5cbiAgICBpZiAoZS50YXJnZXQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpICYmIE51bWJlcihlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIDwgMCkge1xuICAgICAgcmV0dXJuIHRhYkV2ZW50ID0gZTtcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGN1cnJlbnRGb2N1c0luZGV4ID0gdGFiYmFibGVOb2Rlcy5pbmRleE9mKGUudGFyZ2V0KTtcblxuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICBpZiAoZS50YXJnZXQgPT09IGZpcnN0VGFiYmFibGVOb2RlIHx8IHRhYmJhYmxlTm9kZXMuaW5kZXhPZihlLnRhcmdldCkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnlGb2N1cyhsYXN0VGFiYmFibGVOb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnlGb2N1cyh0YWJiYWJsZU5vZGVzW2N1cnJlbnRGb2N1c0luZGV4IC0gMV0pO1xuICAgIH1cblxuICAgIGlmIChlLnRhcmdldCA9PT0gbGFzdFRhYmJhYmxlTm9kZSkgcmV0dXJuIHRyeUZvY3VzKGZpcnN0VGFiYmFibGVOb2RlKTtcblxuICAgIHRyeUZvY3VzKHRhYmJhYmxlTm9kZXNbY3VycmVudEZvY3VzSW5kZXggKyAxXSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUYWJiYWJsZU5vZGVzKCkge1xuICAgIHRhYmJhYmxlTm9kZXMgPSB0YWJiYWJsZShjb250YWluZXIpO1xuICAgIGZpcnN0VGFiYmFibGVOb2RlID0gdGFiYmFibGVOb2Rlc1swXTtcbiAgICBsYXN0VGFiYmFibGVOb2RlID0gdGFiYmFibGVOb2Rlc1t0YWJiYWJsZU5vZGVzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZGp1c3RGb2N1cyhlKSB7XG4gICAgaWYgKGUuc2hpZnRLZXkpIHJldHVybiB0cnlGb2N1cyhsYXN0VGFiYmFibGVOb2RlKTtcblxuICAgIHRyeUZvY3VzKGZpcnN0VGFiYmFibGVOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0VzY2FwZUV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnRXNjYXBlJyB8fCBlLmtleSA9PT0gJ0VzYycgfHwgZS5rZXlDb2RlID09PSAyNztcbn1cblxuZnVuY3Rpb24gdHJ5Rm9jdXMobm9kZSkge1xuICBpZiAoIW5vZGUgfHwgIW5vZGUuZm9jdXMpIHJldHVybjtcbiAgaWYgKG5vZGUgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICByZXR1cm47XG5cbiAgbm9kZS5mb2N1cygpO1xuICBpZiAobm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICBub2RlLnNlbGVjdCgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNUcmFwO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUZvY3VzVHJhcCBmcm9tICdmb2N1cy10cmFwJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvY3VzVHJhcEluc3RhbmNlKHN1cmZhY2VFbCwgYWNjZXB0QnV0dG9uRWwsIGZvY3VzVHJhcEZhY3RvcnkgPSBjcmVhdGVGb2N1c1RyYXApIHtcbiAgcmV0dXJuIGZvY3VzVHJhcEZhY3Rvcnkoc3VyZmFjZUVsLCB7XG4gICAgaW5pdGlhbEZvY3VzOiBhY2NlcHRCdXR0b25FbCxcbiAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogdHJ1ZSxcbiAgfSk7XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxhc2lkZVxuICAgIHJlZj1cInJvb3RcIlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgOmFyaWEtbGFiZWxsZWRieT1cIidsYWJlbCcgKyB2bWFfdWlkX1wiXG4gICAgOmFyaWEtZGVzY3JpYmVkYnk9XCInZGVzYycgKyB2bWFfdWlkX1wiXG4gICAgY2xhc3M9XCJtZGMtZGlhbG9nXCJcbiAgICByb2xlPVwiYWxlcnRkaWFsb2dcIlxuICA+XG4gICAgPGRpdlxuICAgICAgcmVmPVwic3VyZmFjZVwiXG4gICAgICA6Y2xhc3M9XCJzdXJmYWNlQ2xhc3Nlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX3N1cmZhY2VcIj5cbiAgICAgIDxoZWFkZXIgY2xhc3M9XCJtZGMtZGlhbG9nX19oZWFkZXJcIj5cbiAgICAgICAgPGgyXG4gICAgICAgICAgOmlkPVwiJ2xhYmVsJyArIHZtYV91aWRfXCJcbiAgICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2hlYWRlcl9fdGl0bGVcIj5cbiAgICAgICAgICB7eyB0aXRsZSB9fVxuICAgICAgICA8L2gyPlxuICAgICAgPC9oZWFkZXI+XG4gICAgICA8c2VjdGlvblxuICAgICAgICA6aWQ9XCInZGVzYycgKyB2bWFfdWlkX1wiXG4gICAgICAgIDpjbGFzcz1cImJvZHlDbGFzc2VzXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtZGlhbG9nX19ib2R5XCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgICA8Zm9vdGVyIGNsYXNzPVwibWRjLWRpYWxvZ19fZm9vdGVyXCI+XG4gICAgICAgIDxtZGNCdXR0b25cbiAgICAgICAgICB2LWlmPVwiY2FuY2VsXCJcbiAgICAgICAgICByZWY9XCJjYW5jZWxcIlxuICAgICAgICAgIDpjbGFzcz1cInsnbWRjLWRpYWxvZ19fYWN0aW9uJzphY2NlbnR9XCJcbiAgICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uIG1kYy1kaWFsb2dfX2Zvb3Rlcl9fYnV0dG9uLS1jYW5jZWxcIlxuICAgICAgICAgIEBjbGljaz1cIm9uQ2FuY2VsXCJcbiAgICAgICAgPnt7IGNhbmNlbCB9fTwvbWRjQnV0dG9uPlxuICAgICAgICA8bWRjQnV0dG9uXG4gICAgICAgICAgcmVmPVwiYWNjZXB0XCJcbiAgICAgICAgICA6Y2xhc3M9XCJ7J21kYy1kaWFsb2dfX2FjdGlvbic6YWNjZW50fVwiXG4gICAgICAgICAgOmRpc2FibGVkPVwiYWNjZXB0RGlzYWJsZWRcIlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24gbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWFjY2VwdFwiXG4gICAgICAgICAgQGNsaWNrPVwib25BY2NlcHRcIlxuICAgICAgICA+e3sgYWNjZXB0IH19PC9tZGNCdXR0b24+XG4gICAgICA8L2Zvb3Rlcj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRpYWxvZ19fYmFja2Ryb3BcIi8+XG4gIDwvYXNpZGU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0RpYWxvZ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RpYWxvZy9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UgfSBmcm9tICdAbWF0ZXJpYWwvZGlhbG9nL3V0aWwnXG5pbXBvcnQgeyBtZGNCdXR0b24gfSBmcm9tICcuLi9idXR0b24nXG5pbXBvcnQgeyBWTUFVbmlxdWVJZE1peGluIH0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRpYWxvZycsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBtZGNCdXR0b246IG1kY0J1dHRvblxuICB9LFxuICBtaXhpbnM6IFtWTUFVbmlxdWVJZE1peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgIGFjY2VwdDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdPaycgfSxcbiAgICBhY2NlcHREaXNhYmxlZDogQm9vbGVhbixcbiAgICBjYW5jZWw6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnQ2FuY2VsJyB9LFxuICAgIGFjY2VudDogQm9vbGVhbixcbiAgICBzY3JvbGxhYmxlOiBCb29sZWFuLFxuICAgIG9wZW46IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRoZW1lLS1kYXJrJzogdGhpcy5kYXJrXG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIHN1cmZhY2VDbGFzc2VzOiB7fSxcbiAgICAgIGJvZHlDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtZGlhbG9nX19ib2R5LS1zY3JvbGxhYmxlJzogdGhpcy5zY3JvbGxhYmxlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDogeyBvcGVuOiAnb25PcGVuXycgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvY3VzVHJhcCA9IGNyZWF0ZUZvY3VzVHJhcEluc3RhbmNlKFxuICAgICAgdGhpcy4kcmVmcy5zdXJmYWNlLFxuICAgICAgdGhpcy4kcmVmcy5hY2NlcHRcbiAgICApXG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDRGlhbG9nRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBhZGRCb2R5Q2xhc3M6IGNsYXNzTmFtZSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogY2xhc3NOYW1lID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICByZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKmV2dCwgaGFuZGxlciovKSA9PiB7XG4gICAgICAgIC8vIFZNQV9IQUNLOiBoYW5kbGUgYnV0dG9uIGNsaWNrcyBvdXJzZWx2ZXNcbiAgICAgICAgLy8gdGhpcy4kcmVmcy5zdXJmYWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLypldnQsIGhhbmRsZXIqLykgPT4ge1xuICAgICAgICAvLyBWTUFfSEFDSzogaGFuZGxlIGJ1dHRvbiBjbGlja3Mgb3Vyc2VsdmVzXG4gICAgICAgIC8vIHRoaXMuJHJlZnMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHRoaXMuJHJlZnMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlciksXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgIHRoaXMuJGVtaXQoJ2FjY2VwdCcpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdjYW5jZWwnKVxuICAgICAgfSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4gdGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKSxcbiAgICAgIHVudHJhcEZvY3VzT25TdXJmYWNlOiAoKSA9PiB0aGlzLmZvY3VzVHJhcC5kZWFjdGl2YXRlKCksXG4gICAgICBpc0RpYWxvZzogZWwgPT4gdGhpcy4kcmVmcy5zdXJmYWNlID09PSBlbFxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25PcGVuXyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBvbkNhbmNlbCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jYW5jZWwodHJ1ZSlcbiAgICB9LFxuICAgIG9uQWNjZXB0KCkge1xuICAgICAgaWYgKHRoaXMuJGxpc3RlbmVyc1sndmFsaWRhdGUnXSkge1xuICAgICAgICB0aGlzLiRlbWl0KCd2YWxpZGF0ZScsIHtcbiAgICAgICAgICBhY2NlcHQ6IChub3RpZnkgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBub3RpZnkgPSBmYWxzZSwgdGhlIGRpYWxvZyB3aWxsIGNsb3NlXG4gICAgICAgICAgICAvLyBidXQgdGhlIG5vdGlmeUFjY2VwdCBtZXRob2Qgd2lsbCBub3QgYmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIG5vdGlmeSBsaXN0ZW5lcnMgdGhlIG9wZW4gc3RhdGVcbiAgICAgICAgICAgIC8vIGlzIGNoYW5naW5nLlxuICAgICAgICAgICAgaWYgKCFub3RpZnkpIHtcbiAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uYWNjZXB0KG5vdGlmeSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uYWNjZXB0KHRydWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93KCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgIH0sXG4gICAgY2xvc2UoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEaWFsb2cgZnJvbSAnLi9tZGMtZGlhbG9nLnZ1ZSdcblxuZXhwb3J0IHsgbWRjRGlhbG9nIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0RpYWxvZ1xufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPG5hdiBjbGFzcz1cIm1kYy1wZXJtYW5lbnQtZHJhd2VyIG1kYy1kcmF3ZXItLXBlcm1hbmVudCBtZGMtdHlwb2dyYXBoeVwiPlxuICAgIDxuYXYgY2xhc3M9XCJtZGMtZHJhd2VyX19jb250ZW50XCI+XG4gICAgICA8ZGl2IFxuICAgICAgICB2LWlmPVwidG9vbGJhclNwYWNlclwiIFxuICAgICAgICBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIvPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L25hdj5cbiAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXBlcm1hbmVudC1kcmF3ZXInLFxuICBwcm9wczoge1xuICAgICd0b29sYmFyLXNwYWNlcic6IEJvb2xlYW5cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID1cbiAgJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCAnICtcbiAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgW3RhYmluZGV4XSwgW2NvbnRlbnRlZGl0YWJsZV0nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBzZXRUcmFuc2xhdGVYOiAoLyogdmFsdWU6IG51bWJlciB8IG51bGwgKi8pID0+IHt9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IC8qIE5vZGVMaXN0ICovIHt9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogKC8qIGVsOiBFbGVtZW50ICovKSA9PiB7fSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICBtYWtlRWxlbWVudFVudGFiYmFibGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNsb3NlOiAoKSA9PiB7fSxcbiAgICAgIGlzUnRsOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyLCByb290Q3NzQ2xhc3MsIGFuaW1hdGluZ0Nzc0NsYXNzLCBvcGVuQ3NzQ2xhc3MpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5yb290Q3NzQ2xhc3NfID0gcm9vdENzc0NsYXNzO1xuICAgIHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfID0gYW5pbWF0aW5nQ3NzQ2xhc3M7XG4gICAgdGhpcy5vcGVuQ3NzQ2xhc3NfID0gb3BlbkNzc0NsYXNzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG5cbiAgICB0aGlzLmluZXJ0XyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoU3RhcnRfKGV2dCk7XG4gICAgdGhpcy5jb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVG91Y2hNb3ZlXyhldnQpO1xuICAgIHRoaXMuY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVG91Y2hFbmRfKGV2dCk7XG4gICAgdGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQua2V5ICYmIGV2dC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2dC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29uc3QgUk9PVCA9IHRoaXMucm9vdENzc0NsYXNzXztcbiAgICBjb25zdCBPUEVOID0gdGhpcy5vcGVuQ3NzQ2xhc3NfO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKFJPT1QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Uk9PVH0gY2xhc3MgcmVxdWlyZWQgaW4gcm9vdCBlbGVtZW50LmApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNOZWNlc3NhcnlEb20oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1aXJlZCBET00gbm9kZXMgbWlzc2luZyBpbiAke1JPT1R9IGNvbXBvbmVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhPUEVOKSkge1xuICAgICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXRhYmluYXRlXygpO1xuICAgICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hzdGFydCcsIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaG1vdmUnLCB0aGlzLmNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaGVuZCcsIHRoaXMuY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hzdGFydCcsIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNobW92ZScsIHRoaXMuY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hlbmQnLCB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8pO1xuICAgIC8vIERlcmVnaXN0ZXIgdGhlIGRvY3VtZW50IGtleWRvd24gaGFuZGxlciBqdXN0IGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgd2hpbGUgdGhlIG1lbnUgaXMgb3Blbi5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5vcGVuQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLnJldGFiaW5hdGVfKCk7XG4gICAgLy8gRGVib3VuY2UgbXVsdGlwbGUgY2FsbHNcbiAgICBpZiAoIXRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlPcGVuKCk7XG4gICAgfVxuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLm9wZW5Dc3NDbGFzc18pO1xuICAgIHRoaXMuZGV0YWJpbmF0ZV8oKTtcbiAgICAvLyBEZWJvdW5jZSBtdWx0aXBsZSBjYWxsc1xuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuXztcbiAgfVxuXG4gIC8qKlxuICAgKiAgUmVuZGVyIGFsbCBjaGlsZHJlbiBvZiB0aGUgZHJhd2VyIGluZXJ0IHdoZW4gaXQncyBjbG9zZWQuXG4gICAqL1xuICBkZXRhYmluYXRlXygpIHtcbiAgICBpZiAodGhpcy5pbmVydF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTtcbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zYXZlRWxlbWVudFRhYlN0YXRlKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5tYWtlRWxlbWVudFVudGFiYmFibGUoZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5lcnRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgTWFrZSBhbGwgY2hpbGRyZW4gb2YgdGhlIGRyYXdlciB0YWJiYWJsZSBhZ2FpbiB3aGVuIGl0J3Mgb3Blbi5cbiAgICovXG4gIHJldGFiaW5hdGVfKCkge1xuICAgIGlmICghdGhpcy5pbmVydF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTtcbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluZXJ0XyA9IGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hTdGFydF8oZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKHRoaXMub3BlbkNzc0NsYXNzXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRpcmVjdGlvbl8gPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCkgPyAtMSA6IDE7XG4gICAgdGhpcy5kcmF3ZXJXaWR0aF8gPSB0aGlzLmFkYXB0ZXJfLmdldERyYXdlcldpZHRoKCk7XG4gICAgdGhpcy5zdGFydFhfID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5wYWdlWCA6IGV2dC5wYWdlWDtcbiAgICB0aGlzLmN1cnJlbnRYXyA9IHRoaXMuc3RhcnRYXztcblxuICAgIHRoaXMudXBkYXRlUmFmXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZURyYXdlcl8uYmluZCh0aGlzKSk7XG4gIH1cblxuICBoYW5kbGVUb3VjaE1vdmVfKGV2dCkge1xuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50WF8gPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLnBhZ2VYIDogZXZ0LnBhZ2VYO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hFbmRfKGV2dCkge1xuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcmVwYXJlRm9yVG91Y2hFbmRfKCk7XG5cbiAgICAvLyBEaWQgdGhlIHVzZXIgY2xvc2UgdGhlIGRyYXdlciBieSBtb3JlIHRoYW4gNTAlP1xuICAgIGlmIChNYXRoLmFicyh0aGlzLm5ld1Bvc2l0aW9uXyAvIHRoaXMuZHJhd2VyV2lkdGhfKSA+PSAwLjUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJpZ2dlcmluZyBhbiBvcGVuIGhlcmUgbWVhbnMgd2UnbGwgZ2V0IGEgbmljZSBhbmltYXRpb24gYmFjayB0byB0aGUgZnVsbHkgb3BlbiBzdGF0ZS5cbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBhcmVGb3JUb3VjaEVuZF8oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVSYWZfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFRyYW5zbGF0ZVgobnVsbCk7XG4gIH1cblxuICB1cGRhdGVEcmF3ZXJfKCkge1xuICAgIHRoaXMudXBkYXRlUmFmXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZURyYXdlcl8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2xhdGVYKHRoaXMubmV3UG9zaXRpb25fKTtcbiAgfVxuXG4gIGdldCBuZXdQb3NpdGlvbl8oKSB7XG4gICAgbGV0IG5ld1BvcyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5kaXJlY3Rpb25fID09PSAxKSB7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1pbigwLCB0aGlzLmN1cnJlbnRYXyAtIHRoaXMuc3RhcnRYXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWF4KDAsIHRoaXMuY3VycmVudFhfIC0gdGhpcy5zdGFydFhfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG5cbiAgaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZVxuICAgIC8vIGlmIHRoZSBldmVudCB0YXJnZXQgaXMgdGhlIHJvb3QgZXZlbnQgdGFyZ2V0IGN1cnJlbnRseSB0cmFuc2l0aW9uaW5nLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIGlmICh0aGlzLmlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZXZ0LnRhcmdldCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIH1cbiAgfTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQge01EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbn0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWRyYXdlci0tcGVyc2lzdGVudCcsXG4gIE9QRU46ICdtZGMtZHJhd2VyLS1vcGVuJyxcbiAgQU5JTUFUSU5HOiAnbWRjLWRyYXdlci0tYW5pbWF0aW5nJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBEUkFXRVJfU0VMRUNUT1I6ICcubWRjLWRyYXdlci0tcGVyc2lzdGVudCAubWRjLWRyYXdlcl9fZHJhd2VyJyxcbiAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICBPUEVOX0VWRU5UOiAnTURDUGVyc2lzdGVudERyYXdlcjpvcGVuJyxcbiAgQ0xPU0VfRVZFTlQ6ICdNRENQZXJzaXN0ZW50RHJhd2VyOmNsb3NlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbn0gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIHtcbiAgICAgIGlzRHJhd2VyOiAoKSA9PiBmYWxzZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpLFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5ST09ULFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcsXG4gICAgICBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyhlbCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmlzRHJhd2VyKGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgVEFCX0RBVEEgPSAnZGF0YS1tZGMtdGFiaW5kZXgnO1xuY29uc3QgVEFCX0RBVEFfSEFORExFRCA9ICdkYXRhLW1kYy10YWJpbmRleC1oYW5kbGVkJztcblxubGV0IHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLy8gUmVtYXAgdG91Y2ggZXZlbnRzIHRvIHBvaW50ZXIgZXZlbnRzLCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdG91Y2ggZXZlbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHJlbWFwRXZlbnQoZXZlbnROYW1lLCBnbG9iYWxPYmogPSB3aW5kb3cpIHtcbiAgaWYgKCEoJ29udG91Y2hzdGFydCcgaW4gZ2xvYmFsT2JqLmRvY3VtZW50KSkge1xuICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICByZXR1cm4gJ3BvaW50ZXJkb3duJztcbiAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgcmV0dXJuICdwb2ludGVybW92ZSc7XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgcmV0dXJuICdwb2ludGVydXAnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXZlbnROYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbi8vIENob29zZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gdXNlIG9uIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBjb25zdCBlbCA9IGdsb2JhbE9iai5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUgPSAoJ3RyYW5zZm9ybScgaW4gZWwuc3R5bGUgPyAndHJhbnNmb3JtJyA6ICctd2Via2l0LXRyYW5zZm9ybScpO1xuICAgIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPSB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWU7XG4gIH1cblxuICByZXR1cm4gc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcbn1cblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBDU1MgcHJvcGVydGllcy5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMoZ2xvYmFsT2JqID0gd2luZG93KSB7XG4gIGlmICgnQ1NTJyBpbiBnbG9iYWxPYmopIHtcbiAgICByZXR1cm4gZ2xvYmFsT2JqLkNTUy5zdXBwb3J0cygnKC0tY29sb3I6IHJlZCknKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGFuZCBpZiBzbywgdXNlIHRoZW0uXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8vIFNhdmUgdGhlIHRhYiBzdGF0ZSBmb3IgYW4gZWxlbWVudC5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlRWxlbWVudFRhYlN0YXRlKGVsKSB7XG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoVEFCX0RBVEEsIGVsLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSk7XG4gIH1cbiAgZWwuc2V0QXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQsIHRydWUpO1xufVxuXG4vLyBSZXN0b3JlIHRoZSB0YWIgc3RhdGUgZm9yIGFuIGVsZW1lbnQsIGlmIGl0IHdhcyBzYXZlZC5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKSB7XG4gIC8vIE9ubHkgbW9kaWZ5IGVsZW1lbnRzIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCwgaW4gY2FzZSBhbnl0aGluZyB3YXMgZHluYW1pY2FsbHkgYWRkZWQgc2luY2Ugd2Ugc2F2ZWQgc3RhdGUuXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCkpIHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKFRBQl9EQVRBKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIGVsLmdldEF0dHJpYnV0ZShUQUJfREFUQSkpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFRBQl9EQVRBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGFzaWRlXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgY2xhc3M9XCJtZGMtcGVyc2lzdGVudC1kcmF3ZXIgbWRjLWRyYXdlci0tcGVyc2lzdGVudCBtZGMtdHlwb2dyYXBoeVwiPlxuICAgIDxuYXZcbiAgICAgIHJlZj1cImRyYXdlclwiXG4gICAgICBjbGFzcz1cIm1kYy1kcmF3ZXJfX2RyYXdlclwiPlxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwidG9vbGJhclNwYWNlclwiXG4gICAgICAgIGNsYXNzPVwibWRjLWRyYXdlcl9fdG9vbGJhci1zcGFjZXJcIi8+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvbmF2PlxuICA8L2FzaWRlPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3BlcnNpc3RlbnQvZm91bmRhdGlvbidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL2RyYXdlci91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdvcGVuJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuLFxuICAgIG9wZW46IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge31cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbjogJ19yZWZyZXNoJ1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IHsgRk9DVVNBQkxFX0VMRU1FTlRTIH0gPSBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5zdHJpbmdzXG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHV0aWwucmVtYXBFdmVudChldnQpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgdXRpbC5hcHBseVBhc3NpdmUoKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHV0aWwucmVtYXBFdmVudChldnQpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgdXRpbC5hcHBseVBhc3NpdmUoKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGdldERyYXdlcldpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyYXdlci5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFRyYW5zbGF0ZVg6IHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgdXRpbC5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUoKSxcbiAgICAgICAgICB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiBgdHJhbnNsYXRlWCgke3ZhbHVlfXB4KWBcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGdldEZvY3VzYWJsZUVsZW1lbnRzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyYXdlci5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUylcbiAgICAgIH0sXG4gICAgICBzYXZlRWxlbWVudFRhYlN0YXRlOiBlbCA9PiB7XG4gICAgICAgIHV0aWwuc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiBlbCA9PiB7XG4gICAgICAgIHV0aWwucmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICBtYWtlRWxlbWVudFVudGFiYmFibGU6IGVsID0+IHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeU9wZW46ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdHJ1ZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJylcbiAgICAgIH0sXG4gICAgICBpc1J0bDogKCkgPT4ge1xuICAgICAgICAvKiBnbG9iYWwgZ2V0Q29tcHV0ZWRTdHlsZSAqL1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJ1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgaXNEcmF3ZXI6IGVsID0+IHtcbiAgICAgICAgcmV0dXJuIGVsID09PSB0aGlzLiRyZWZzLmRyYXdlclxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLl9yZWZyZXNoKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIF9yZWZyZXNoKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWRyYXdlci0tdGVtcG9yYXJ5JyxcbiAgT1BFTjogJ21kYy1kcmF3ZXItLW9wZW4nLFxuICBBTklNQVRJTkc6ICdtZGMtZHJhd2VyLS1hbmltYXRpbmcnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1kcmF3ZXItc2Nyb2xsLWxvY2snLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIERSQVdFUl9TRUxFQ1RPUjogJy5tZGMtZHJhd2VyLS10ZW1wb3JhcnkgLm1kYy1kcmF3ZXJfX2RyYXdlcicsXG4gIE9QQUNJVFlfVkFSX05BTUU6ICctLW1kYy10ZW1wb3JhcnktZHJhd2VyLW9wYWNpdHknLFxuICBGT0NVU0FCTEVfRUxFTUVOVFMsXG4gIE9QRU5fRVZFTlQ6ICdNRENUZW1wb3JhcnlEcmF3ZXI6b3BlbicsXG4gIENMT1NFX0VWRU5UOiAnTURDVGVtcG9yYXJ5RHJhd2VyOmNsb3NlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbn0gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwge1xuICAgICAgYWRkQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaXNEcmF3ZXI6ICgpID0+IGZhbHNlLFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICgvKiB0YXJnZXQ6IEV2ZW50VGFyZ2V0LCBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlciksXG4gICAgICBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuUk9PVCxcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcsXG4gICAgICBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG5cbiAgICB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKGV2dC50YXJnZXQsIGNzc0NsYXNzZXMuUk9PVCkpIHtcbiAgICAgICAgdGhpcy5jbG9zZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG5cbiAgICAvLyBNYWtlIGJyb3dzZXIgYXdhcmUgb2YgY3VzdG9tIHByb3BlcnR5IGJlaW5nIHVzZWQgaW4gdGhpcyBlbGVtZW50LlxuICAgIC8vIFdvcmthcm91bmQgZm9yIGNlcnRhaW4gdHlwZXMgb2YgaGFyZC10by1yZXByb2R1Y2UgaGVpc2VuYnVncy5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKDApO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMuZGlzYWJsZVNjcm9sbF8oKTtcbiAgICAvLyBNYWtlIHN1cmUgY3VzdG9tIHByb3BlcnR5IHZhbHVlcyBhcmUgY2xlYXJlZCBiZWZvcmUgc3RhcnRpbmcuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgnJyk7XG5cbiAgICBzdXBlci5vcGVuKCk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICAvLyBNYWtlIHN1cmUgY3VzdG9tIHByb3BlcnR5IHZhbHVlcyBhcmUgY2xlYXJlZCBiZWZvcmUgbWFraW5nIGFueSBjaGFuZ2VzLlxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoJycpO1xuXG4gICAgc3VwZXIuY2xvc2UoKTtcbiAgfVxuXG4gIHByZXBhcmVGb3JUb3VjaEVuZF8oKSB7XG4gICAgc3VwZXIucHJlcGFyZUZvclRvdWNoRW5kXygpO1xuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgnJyk7XG4gIH1cblxuICB1cGRhdGVEcmF3ZXJfKCkge1xuICAgIHN1cGVyLnVwZGF0ZURyYXdlcl8oKTtcblxuICAgIGNvbnN0IG5ld09wYWNpdHkgPSBNYXRoLm1heCgwLCAxICsgdGhpcy5kaXJlY3Rpb25fICogKHRoaXMubmV3UG9zaXRpb25fIC8gdGhpcy5kcmF3ZXJXaWR0aF8pKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKG5ld09wYWNpdHkpO1xuICB9XG5cbiAgaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyhlbCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmlzRHJhd2VyKGVsKTtcbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIHN1cGVyLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG4gICAgaWYgKCF0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgIH1cbiAgfTtcblxuICBkaXNhYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZEJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxuXG4gIGVuYWJsZVNjcm9sbF8oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVCb2R5Q2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGFzaWRlXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgY2xhc3M9XCJtZGMtdGVtcG9yYXJ5LWRyYXdlciBtZGMtZHJhd2VyLS10ZW1wb3JhcnkgbWRjLXR5cG9ncmFwaHlcIj5cbiAgICA8bmF2XG4gICAgICByZWY9XCJkcmF3ZXJcIlxuICAgICAgY2xhc3M9XCJtZGMtZHJhd2VyX19kcmF3ZXJcIj5cbiAgICAgIDxkaXZcbiAgICAgICAgdi1pZj1cInRvb2xiYXJTcGFjZXJcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIvPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L25hdj5cbiAgPC9hc2lkZT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3RlbXBvcmFyeS9mb3VuZGF0aW9uJ1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3V0aWwnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10ZW1wb3JhcnktZHJhd2VyJyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgb3BlbjogQm9vbGVhbixcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW46ICdfcmVmcmVzaCdcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBGT0NVU0FCTEVfRUxFTUVOVFMsXG4gICAgICBPUEFDSVRZX1ZBUl9OQU1FXG4gICAgfSA9IE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uc3RyaW5nc1xuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBhZGRCb2R5Q2xhc3M6IGNsYXNzTmFtZSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogY2xhc3NOYW1lID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHV0aWwucmVtYXBFdmVudChldnQpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgdXRpbC5hcHBseVBhc3NpdmUoKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHV0aWwucmVtYXBFdmVudChldnQpLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgdXRpbC5hcHBseVBhc3NpdmUoKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGdldERyYXdlcldpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyYXdlci5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFRyYW5zbGF0ZVg6IHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgdXRpbC5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUoKSxcbiAgICAgICAgICB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiBgdHJhbnNsYXRlWCgke3ZhbHVlfXB4KWBcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh1dGlsLnN1cHBvcnRzQ3NzQ3VzdG9tUHJvcGVydGllcygpKSB7XG4gICAgICAgICAgdGhpcy4kZWwuc3R5bGUuc2V0UHJvcGVydHkoT1BBQ0lUWV9WQVJfTkFNRSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICB9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogZWwgPT4ge1xuICAgICAgICB1dGlsLnNhdmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZTogZWwgPT4ge1xuICAgICAgICB1dGlsLnJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgbWFrZUVsZW1lbnRVbnRhYmJhYmxlOiBlbCA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRydWUpXG4gICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScpXG4gICAgICB9LFxuICAgICAgaXNSdGw6ICgpID0+IHtcbiAgICAgICAgLyogZ2xvYmFsIGdldENvbXB1dGVkU3R5bGUgKi9cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCdcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGlzRHJhd2VyOiBlbCA9PiBlbCA9PT0gdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5fcmVmcmVzaCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBfcmVmcmVzaCgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XHJcbiAgPGNvbXBvbmVudCBcbiAgICByZWY9XCJkcmF3ZXJcIiBcbiAgICA6aXM9XCJ0eXBlXCJcclxuICAgIHYtbW9kZWw9XCJvcGVuX1wiIFxuICAgIDp0b29sYmFyLXNwYWNlcj1cInRvb2xiYXJTcGFjZXJcIlxyXG4gICAgY2xhc3M9XCJtZGMtZHJhd2VyXCJcclxuICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXHJcbiAgICBAb3Blbj1cIiRlbWl0KCdvcGVuJylcIlxyXG4gICAgQGNsb3NlPVwiJGVtaXQoJ2Nsb3NlJylcIiA+XHJcbiAgICA8c2xvdCAvPlxyXG4gIDwvY29tcG9uZW50PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IG1kY1Blcm1hbmVudERyYXdlciBmcm9tICcuL21kYy1wZXJtYW5lbnQtZHJhd2VyLnZ1ZSdcclxuaW1wb3J0IG1kY1BlcnNpc3RlbnREcmF3ZXIgZnJvbSAnLi9tZGMtcGVyc2lzdGVudC1kcmF3ZXIudnVlJ1xyXG5pbXBvcnQgbWRjVGVtcG9yYXJ5RHJhd2VyIGZyb20gJy4vbWRjLXRlbXBvcmFyeS1kcmF3ZXIudnVlJ1xyXG5cclxuY29uc3QgbWVkaWEgPSBuZXcgY2xhc3Mge1xyXG4gIGdldCBzbWFsbCgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMuX3NtYWxsIHx8ICh0aGlzLl9zbWFsbCA9IHdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LXdpZHRoOiA4MzlweCknKSlcclxuICAgIClcclxuICB9XHJcblxyXG4gIGdldCBsYXJnZSgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMuX2xhcmdlIHx8ICh0aGlzLl9sYXJnZSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXdpZHRoOiAxMjAwcHgpJykpXHJcbiAgICApXHJcbiAgfVxyXG59KClcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWRyYXdlcicsXHJcbiAgY29tcG9uZW50czoge1xyXG4gICAgJ21kYy1wZXJtYW5lbnQtZHJhd2VyJzogbWRjUGVybWFuZW50RHJhd2VyLFxyXG4gICAgJ21kYy1wZXJzaXN0ZW50LWRyYXdlcic6IG1kY1BlcnNpc3RlbnREcmF3ZXIsXHJcbiAgICAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInOiBtZGNUZW1wb3JhcnlEcmF3ZXJcclxuICB9LFxyXG4gIG1vZGVsOiB7XHJcbiAgICBwcm9wOiAnb3BlbicsXHJcbiAgICBldmVudDogJ2NoYW5nZSdcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBvcGVuOiBCb29sZWFuLFxyXG4gICAgcGVybWFuZW50OiBCb29sZWFuLFxyXG4gICAgcGVyc2lzdGVudDogQm9vbGVhbixcclxuICAgIHRlbXBvcmFyeTogQm9vbGVhbixcclxuICAgIGRyYXdlclR5cGU6IHtcclxuICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICB2YWxpZGF0b3I6IHZhbCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCBpbiBbJ3RlbXBvcmFyeScsICdwZXJzaXN0ZW50JywgJ3Blcm1hbmVudCddXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0b29sYmFyU3BhY2VyOiBCb29sZWFuLFxyXG4gICAgdG9nZ2xlT246IFN0cmluZyxcclxuICAgIHRvZ2dsZU9uU291cmNlOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlIH0sXHJcbiAgICBvcGVuT246IFN0cmluZyxcclxuICAgIG9wZW5PblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9LFxyXG4gICAgY2xvc2VPbjogU3RyaW5nLFxyXG4gICAgY2xvc2VPblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9XHJcbiAgfSxcclxuICBwcm92aWRlKCkge1xyXG4gICAgcmV0dXJuIHsgbWRjRHJhd2VyOiB0aGlzIH1cclxuICB9LFxyXG4gIGRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzbWFsbDogZmFsc2UsXHJcbiAgICAgIGxhcmdlOiBmYWxzZSxcclxuICAgICAgb3Blbl86IGZhbHNlXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgdHlwZSgpIHtcclxuICAgICAgaWYgKHRoaXMucGVybWFuZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICdtZGMtcGVybWFuZW50LWRyYXdlcidcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnBlcnNpc3RlbnQpIHtcclxuICAgICAgICByZXR1cm4gJ21kYy1wZXJzaXN0ZW50LWRyYXdlcidcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnRlbXBvcmFyeSkge1xyXG4gICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmRyYXdlclR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgJ3Blcm1hbmVudCc6XHJcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXBlcm1hbmVudC1kcmF3ZXInXHJcbiAgICAgICAgICBjYXNlICdwZXJzaXN0ZW50JzpcclxuICAgICAgICAgICAgcmV0dXJuICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXHJcbiAgICAgICAgICBjYXNlICd0ZW1wb3JhcnknOlxyXG4gICAgICAgICAgICByZXR1cm4gJ21kYy10ZW1wb3JhcnktZHJhd2VyJ1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc21hbGwgPyAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInIDogJ21kYy1wZXJzaXN0ZW50LWRyYXdlcidcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpc1Blcm1hbmVudCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGVybWFuZW50IHx8IHRoaXMudHlwZSA9PT0gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xyXG4gICAgfSxcclxuICAgIGlzUGVyc2lzdGVudCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnR5cGUgPT09ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXHJcbiAgICB9LFxyXG4gICAgaXNUZW1wb3JhcnkoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLnR5cGUgPT09ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcidcclxuICAgIH0sXHJcbiAgICBpc1Jlc3BvbnNpdmUoKSB7XHJcbiAgICAgIHJldHVybiAhKFxyXG4gICAgICAgIHRoaXMucGVybWFuZW50IHx8XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50IHx8XHJcbiAgICAgICAgdGhpcy50ZW1wb3JhcnkgfHxcclxuICAgICAgICB0aGlzLmRyYXdlclR5cGVcclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgd2F0Y2g6IHtcclxuICAgIG9wZW46ICdvbk9wZW5fJ1xyXG4gIH0sXHJcbiAgY3JlYXRlZCgpIHtcclxuICAgIGlmICh3aW5kb3cgJiYgd2luZG93Lm1hdGNoTWVkaWEpIHtcclxuICAgICAgdGhpcy5zbWFsbCA9IG1lZGlhLnNtYWxsLm1hdGNoZXNcclxuICAgICAgdGhpcy5sYXJnZSA9IG1lZGlhLmxhcmdlLm1hdGNoZXNcclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICBpZiAodGhpcy50b2dnbGVPbikge1xyXG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UgPSB0aGlzLnRvZ2dsZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcclxuICAgICAgdGhpcy50b2dnbGVPbkV2ZW50U291cmNlLiRvbih0aGlzLnRvZ2dsZU9uLCB0aGlzLnRvZ2dsZURyYXdlcilcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wZW5Pbikge1xyXG4gICAgICB0aGlzLm9wZW5PbkV2ZW50U291cmNlID0gdGhpcy5vcGVuT25Tb3VyY2UgfHwgdGhpcy4kcm9vdFxyXG4gICAgICB0aGlzLm9wZW5PbkV2ZW50U291cmNlLiRvbih0aGlzLm9wZW5PbiwgdGhpcy5vcGVuRHJhd2VyKVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY2xvc2VPbikge1xyXG4gICAgICB0aGlzLmNsb3NlT25FdmVudFNvdXJjZSA9IHRoaXMuY2xvc2VPblNvdXJjZSB8fCB0aGlzLiRyb290XHJcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlLiRvbih0aGlzLmNsb3NlT24sIHRoaXMuY2xvc2VEcmF3ZXIpXHJcbiAgICB9XHJcbiAgICBtZWRpYS5zbWFsbC5hZGRMaXN0ZW5lcih0aGlzLnJlZnJlc2hNZWRpYSlcclxuICAgIG1lZGlhLmxhcmdlLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gdGhpcy5yZWZyZXNoTWVkaWEoKSlcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICBtZWRpYS5zbWFsbC5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hNZWRpYSlcclxuICAgIG1lZGlhLmxhcmdlLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG5cclxuICAgIGlmICh0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UpIHtcclxuICAgICAgdGhpcy50b2dnbGVPbkV2ZW50U291cmNlLiRvZmYodGhpcy50b2dnbGVPbiwgdGhpcy50b2dnbGVEcmF3ZXIpXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5vcGVuT25FdmVudFNvdXJjZSkge1xyXG4gICAgICB0aGlzLm9wZW5PbkV2ZW50U291cmNlLiRvZmYodGhpcy5vcGVuT24sIHRoaXMub3BlbkRyYXdlcilcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNsb3NlT25FdmVudFNvdXJjZSkge1xyXG4gICAgICB0aGlzLmNsb3NlT25FdmVudFNvdXJjZS4kb2ZmKHRoaXMuY2xvc2VPbiwgdGhpcy5jbG9zZURyYXdlcilcclxuICAgIH1cclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIG9uT3Blbl8odmFsdWUpIHtcclxuICAgICAgdGhpcy5pc1Blcm1hbmVudCB8fCAodGhpcy5vcGVuXyA9IHZhbHVlKVxyXG4gICAgfSxcclxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XHJcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGV2ZW50KVxyXG4gICAgICB0aGlzLiRyb290LiRlbWl0KCd2bWE6bGF5b3V0JylcclxuICAgIH0sXHJcbiAgICBvcGVuRHJhd2VyKCkge1xyXG4gICAgICB0aGlzLm9wZW5fID0gdHJ1ZVxyXG4gICAgfSxcclxuICAgIGNsb3NlRHJhd2VyKCkge1xyXG4gICAgICB0aGlzLmlzUGVybWFuZW50IHx8ICh0aGlzLm9wZW5fID0gZmFsc2UpXHJcbiAgICB9LFxyXG4gICAgdG9nZ2xlRHJhd2VyKCkge1xyXG4gICAgICB0aGlzLmlzUGVybWFuZW50IHx8XHJcbiAgICAgICAgKHRoaXMuaXNPcGVuKCkgPyB0aGlzLmNsb3NlRHJhd2VyKCkgOiB0aGlzLm9wZW5EcmF3ZXIoKSlcclxuICAgIH0sXHJcbiAgICBpc09wZW4oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmlzUGVybWFuZW50IHx8IHRoaXMub3Blbl9cclxuICAgIH0sXHJcbiAgICByZWZyZXNoTWVkaWEoKSB7XHJcbiAgICAgIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzXHJcbiAgICAgIHRoaXMubGFyZ2UgPSBtZWRpYS5sYXJnZS5tYXRjaGVzXHJcbiAgICAgIGlmICh0aGlzLmlzUmVzcG9uc2l2ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhcmdlKSB7XHJcbiAgICAgICAgICB0aGlzLm9wZW5EcmF3ZXIoKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlRHJhd2VyKClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXItbGF5b3V0XCI+XG4gICAgPHNsb3QgLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1sYXlvdXQnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGhlYWRlciBcbiAgICB2LWlmPVwic2hvd1wiIFxuICAgIGNsYXNzPVwibWRjLWRyYXdlci1oZWFkZXIgbWRjLWRyYXdlcl9faGVhZGVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2hlYWRlci1jb250ZW50XCI+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvZGl2PlxuICA8L2hlYWRlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWhlYWRlcicsXG4gIHByb3BzOiB7XG4gICAgcGVybWFuZW50OiBCb29sZWFuLFxuICAgIHBlcnNpc3RlbnQ6IEJvb2xlYW4sXG4gICAgdGVtcG9yYXJ5OiBCb29sZWFuXG4gIH0sXG4gIGluamVjdDogWydtZGNEcmF3ZXInXSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzaG93KCkge1xuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5IHx8IHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnBlcm1hbmVudCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh0aGlzLnRlbXBvcmFyeSAmJiB0aGlzLm1kY0RyYXdlci5pc1RlbXBvcmFyeSkgfHxcbiAgICAgICAgICAodGhpcy5wZXJzaXN0ZW50ICYmIHRoaXMubWRjRHJhd2VyLmlzUGVyc2lzdGVudCkgfHxcbiAgICAgICAgICAodGhpcy5wZXJtYW5lbnQgJiYgdGhpcy5tZGNEcmF3ZXIuaXNQZXJtYW5lbnQpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPG5hdiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgY2xhc3M9XCJtZGMtZHJhd2VyLWxpc3QgbWRjLWxpc3RcIj5cbiAgICA8c2xvdC8+XG4gIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItbGlzdCcsXG4gIHByb3BzOiB7XG4gICAgZGVuc2U6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLWxpc3QtLWRlbnNlJzogdGhpcy5kZW5zZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XHJcbiAgPGN1c3RvbS1saW5rIFxuICAgIDpsaW5rPVwibGlua1wiXHJcbiAgICA6Y2xhc3M9XCJbY2xhc3NlcywgaXRlbUNsYXNzZXNdXCJcclxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIGNsYXNzPVwibWRjLWRyYXdlci1pdGVtIG1kYy1saXN0LWl0ZW1cIlxyXG4gICAgdi1vbj1cIm15bGlzdGVuZXJzXCI+XHJcbiAgICA8c3BhbiBcbiAgICAgIHYtaWY9XCJoYXNTdGFydERldGFpbFwiIFxuICAgICAgY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19ncmFwaGljXCI+XHJcbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIj5cclxuICAgICAgICA8aSBcbiAgICAgICAgICBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCIgXG4gICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3sgc3RhcnRJY29uIH19PC9pPlxyXG4gICAgICA8L3Nsb3Q+XHJcbiAgICA8L3NwYW4+XHJcbiAgICA8c2xvdC8+XHJcbiAgPC9jdXN0b20tbGluaz5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWRyYXdlci1pdGVtJyxcclxuICBpbmplY3Q6IFsnbWRjRHJhd2VyJ10sXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBzdGFydEljb246IFN0cmluZyxcclxuICAgIHRlbXBvcmFyeUNsb3NlOiB7XHJcbiAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH0sXHJcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW4sXHJcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiB7XHJcbiAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgZGVmYXVsdDogJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCdcclxuICAgIH1cclxuICB9LFxyXG4gIGRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGFzc2VzOiB7fSxcclxuICAgICAgc3R5bGVzOiB7fVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIG15bGlzdGVuZXJzKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnRoaXMuJGxpc3RlbmVycyxcclxuICAgICAgICBjbGljazogZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLm1kY0RyYXdlci5pc1RlbXBvcmFyeSAmJlxyXG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUNsb3NlICYmXHJcbiAgICAgICAgICAgIHRoaXMubWRjRHJhd2VyLmNsb3NlRHJhd2VyKClcclxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGl0ZW1DbGFzc2VzKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgICdtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWQnOiB0aGlzLmFjdGl2YXRlZFxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgaGFzU3RhcnREZXRhaWwoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0SWNvbiB8fCB0aGlzLiRzbG90c1snc3RhcnQtZGV0YWlsJ11cclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXHJcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5kZXN0cm95KClcclxuICAgIHRoaXMucmlwcGxlID0gbnVsbFxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICA8aHIgY2xhc3M9XCJtZGMtbGlzdC1kaXZpZGVyXCI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1kaXZpZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEcmF3ZXIgZnJvbSAnLi9tZGMtZHJhd2VyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJMYXlvdXQgZnJvbSAnLi9tZGMtZHJhd2VyLWxheW91dC52dWUnXG5pbXBvcnQgbWRjRHJhd2VySGVhZGVyIGZyb20gJy4vbWRjLWRyYXdlci1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckxpc3QgZnJvbSAnLi9tZGMtZHJhd2VyLWxpc3QudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckl0ZW0gZnJvbSAnLi9tZGMtZHJhd2VyLWl0ZW0udnVlJ1xuaW1wb3J0IG1kY0RyYXdlckRpdmlkZXIgZnJvbSAnLi9tZGMtZHJhd2VyLWRpdmlkZXIudnVlJ1xuXG5leHBvcnQge1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLWVsZXZhdGlvblwiLz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZWxldmF0aW9uJyxcbiAgcHJvcHM6IHt9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0VsZXZhdGlvbiBmcm9tICcuL21kYy1lbGV2YXRpb24udnVlJ1xuXG5leHBvcnQgeyBtZGNFbGV2YXRpb24gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRWxldmF0aW9uXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWJ1dHRvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgOmhyZWY9XCJocmVmXCJcbiAgICA6bGluaz1cImxpbmtcIiBcbiAgICBjbGFzcz1cIm1kYy1mYWJcIiBcbiAgICB2LW9uPVwibGlzdGVuZXJzXCIgPlxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWZhYl9faWNvblwiPlxuICAgICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgICA8L3NwYW4+XG4gIDwvY3VzdG9tLWJ1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUJ1dHRvbk1peGluIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZU1peGluIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZmFiJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZyxcbiAgICBtaW5pOiBCb29sZWFuLFxuICAgIGFic29sdXRlOiBCb29sZWFuLFxuICAgIGZpeGVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogdGhpcy5pY29uLFxuICAgICAgICAnbWRjLWZhYi0tbWluaSc6IHRoaXMubWluaSxcbiAgICAgICAgJ21kYy1mYWItLWFic29sdXRlJzogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgJ21kYy1mYWItLWZpeGVkJzogdGhpcy5maXhlZFxuICAgICAgfSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaWNvbigpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtYXRlcmlhbC1pY29ucycsIHRoaXMuaWNvbilcbiAgICB9LFxuICAgIG1pbmkoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWZhYi0tbWluaScsIHRoaXMubWluaSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRkFCIGZyb20gJy4vbWRjLWZhYi52dWUnXG5cbmV4cG9ydCB7IG1kY0ZBQiB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNGQUJcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRJTEVTX1NFTEVDVE9SOiAnLm1kYy1ncmlkLWxpc3RfX3RpbGVzJyxcbiAgVElMRV9TRUxFQ1RPUjogJy5tZGMtZ3JpZC10aWxlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7c3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENHcmlkTGlzdEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0TnVtYmVyT2ZUaWxlczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBzZXRTdHlsZUZvclRpbGVzRWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDR3JpZExpc3RGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWxpZ25DZW50ZXIoKTtcbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IDA7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFsaWduQ2VudGVyKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG4gIGFsaWduQ2VudGVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZUZyYW1lXyAhPT0gMCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFsaWduQ2VudGVyXygpO1xuICAgICAgdGhpcy5yZXNpemVGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG4gIGFsaWduQ2VudGVyXygpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZlRpbGVzKCkgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBncmlkV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4KDApO1xuICAgIGNvbnN0IHRpbGVzV2lkdGggPSBpdGVtV2lkdGggKiBNYXRoLmZsb29yKGdyaWRXaWR0aCAvIGl0ZW1XaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvclRpbGVzRWxlbWVudCgnd2lkdGgnLCBgJHt0aWxlc1dpZHRofXB4YCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1ncmlkLWxpc3RcIj5cbiAgICA8dWwgXG4gICAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICAgIGNsYXNzPVwibWRjLWdyaWQtbGlzdF9fdGlsZXNcIj5cbiAgICAgIDxzbG90Lz5cbiAgICA8L3VsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDR3JpZExpc3RGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9ncmlkLWxpc3QvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtbGlzdCcsXG4gIHByb3BzOiB7XG4gICAgd2lkdGg6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgcmF0aW86IFN0cmluZyxcbiAgICAnbmFycm93LWd1dHRlcic6IEJvb2xlYW4sXG4gICAgJ2hlYWRlci1jYXB0aW9uJzogQm9vbGVhbixcbiAgICAnaWNvbi1hbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2ljb24tYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnd2l0aC1zdXBwb3J0LXRleHQnOiBCb29sZWFuLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuXG4gIH0sXG4gIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHsgbWRjR3JpZDogdGhpcyB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGxldCBjbGFzc2VzID0ge31cblxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0tdGlsZS1ndXR0ZXItMSddID0gdGhpcy5uYXJyb3dHdXR0ZXJcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLWhlYWRlci1jYXB0aW9uJ10gPSB0aGlzLmhlYWRlckNhcHRpb25cbiAgICAgIGNsYXNzZXNbYG1kYy1ncmlkLWxpc3QtLXRpbGUtYXNwZWN0LSR7dGhpcy5yYXRpb31gXSA9IHRoaXMucmF0aW9cbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXdpdGgtaWNvbi1hbGlnbi1zdGFydCddID0gdGhpcy5pY29uQWxpZ25TdGFydFxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0td2l0aC1pY29uLWFsaWduLWVuZCddID0gdGhpcy5pY29uQWxpZ25FbmRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXR3b2xpbmUtY2FwdGlvbiddID0gdGhpcy53aXRoU3VwcG9ydFRleHRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSddID0gIXRoaXMuaW50ZXJhY3RpdmVcblxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9LFxuICAgIHN0eWxlcygpIHtcbiAgICAgIHZhciBkZWZhdWx0V2lkdGggPSAyMDBcbiAgICAgIHJldHVybiB7XG4gICAgICAgICctLW1kYy1ncmlkLWxpc3QtdGlsZS13aWR0aCc6IGAke3RoaXMud2lkdGggfHwgZGVmYXVsdFdpZHRofXB4YFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDR3JpZExpc3RGb3VuZGF0aW9uKHtcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mVGlsZXM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUlxuICAgICAgICApLmxlbmd0aFxuICAgICAgfSxcbiAgICAgIGdldE9mZnNldFdpZHRoRm9yVGlsZUF0SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUlxuICAgICAgICApW2luZGV4XS5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlRm9yVGlsZXNFbGVtZW50OiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRVNfU0VMRUNUT1JcbiAgICAgICAgKS5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIFxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIlxuICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZVwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyBsaXN0ZW5lcnMgOiBjbGlja0xpc3RlbmVyXCI+XG4gICAgPGRpdiBcbiAgICAgIHYtaWY9XCJjb3ZlclwiIFxuICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCI+XG4gICAgICA8ZGl2IFxuICAgICAgICA6c3R5bGU9XCJ7IGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgc3JjICsgJyknIH1cIlxuICAgICAgICBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3ByaW1hcnktY29udGVudFwiLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IFxuICAgICAgdi1lbHNlIFxuICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCI+XG4gICAgICA8aW1nIFxuICAgICAgICA6c3JjPVwic3JjXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fcHJpbWFyeS1jb250ZW50XCIgPlxuICAgIDwvZGl2PlxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cInRpdGxlIHx8IHN1cHBvcnRUZXh0XCIgXG4gICAgICBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3NlY29uZGFyeVwiPlxuICAgICAgPGkgXG4gICAgICAgIHYtaWY9XCJpY29uXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9faWNvbiBtYXRlcmlhbC1pY29uc1wiPnt7IGljb24gfX08L2k+XG4gICAgICA8c3BhbiBcbiAgICAgICAgdi1pZj1cInRpdGxlXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fdGl0bGVcIj57eyB0aXRsZSB9fTwvc3Bhbj5cbiAgICAgIDxzcGFuIFxuICAgICAgICB2LWlmPVwic3VwcG9ydFRleHRcIiBcbiAgICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19zdXBwb3J0LXRleHRcIj57eyBzdXBwb3J0VGV4dCB9fTwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gIDwvbGk+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtdGlsZScsXG4gIGluamVjdDogWydtZGNHcmlkJ10sXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgc3JjOiBTdHJpbmcsXG4gICAgY292ZXI6IEJvb2xlYW4sXG4gICAgaWNvbjogU3RyaW5nLFxuICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgJ3N1cHBvcnQtdGV4dCc6IFN0cmluZyxcbiAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsaWNrTGlzdGVuZXIoKSB7XG4gICAgICByZXR1cm4geyBjbGljazogZSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZSkgfVxuICAgIH0sXG4gICAgaXRlbUNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tc2VsZWN0ZWQnOiB0aGlzLnNlbGVjdGVkLFxuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzSW50ZXJhY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNHcmlkICYmIHRoaXMubWRjR3JpZC5pbnRlcmFjdGl2ZVxuICAgIH0sXG4gICAgaGFzU3RhcnREZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydEljb24gfHwgdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfSxcbiAgICBoYXNFbmREZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmRJY29uIHx8IHRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXNJbnRlcmFjdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWRkUmlwcGxlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmlwcGxlKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlICYmIHRoaXMuYWRkUmlwcGxlKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBhZGRSaXBwbGUoKSB7XG4gICAgICBpZiAoIXRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgICByaXBwbGUuaW5pdCgpXG4gICAgICAgIHRoaXMucmlwcGxlID0gcmlwcGxlXG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVSaXBwbGUoKSB7XG4gICAgICBpZiAodGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IHRoaXMucmlwcGxlXG4gICAgICAgIHRoaXMucmlwcGxlID0gbnVsbFxuICAgICAgICByaXBwbGUuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0dyaWRMaXN0IGZyb20gJy4vbWRjLWdyaWQtbGlzdC52dWUnXG5pbXBvcnQgbWRjR3JpZFRpbGUgZnJvbSAnLi9tZGMtZ3JpZC10aWxlLnZ1ZSdcblxuZXhwb3J0IHsgbWRjR3JpZExpc3QsIG1kY0dyaWRUaWxlIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0dyaWRMaXN0LFxuICBtZGNHcmlkVGlsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiIFxuICAgIGNsYXNzPVwibWRjLWljb24gbWRjLWljb24tLW1hdGVyaWFsXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1pY29uJyxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0ljb24gZnJvbSAnLi9tZGMtaWNvbi52dWUnXHJcblxyXG5leHBvcnQgeyBtZGNJY29uIH1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0ljb25cclxufSlcclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBJY29uIFRvZ2dsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBpbm5lciB0ZXh0XG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIGV2ZW50IGRpc3BhdGNoXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5cbmNsYXNzIE1EQ0ljb25Ub2dnbGVBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAqL1xuICBzZXRUZXh0KHRleHQpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VGFiSW5kZXgoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gdGFiSW5kZXggKi9cbiAgc2V0VGFiSW5kZXgodGFiSW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHIobmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKG5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuICBybUF0dHIobmFtZSkge31cblxuICAvKiogQHBhcmFtIHshSWNvblRvZ2dsZUV2ZW50fSBldnREYXRhICovXG4gIG5vdGlmeUNoYW5nZShldnREYXRhKSB7fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzT246IGJvb2xlYW4sXG4gKiB9fVxuICovXG5sZXQgSWNvblRvZ2dsZUV2ZW50O1xuXG5leHBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1pY29uLXRvZ2dsZScsXG4gIERJU0FCTEVEOiAnbWRjLWljb24tdG9nZ2xlLS1kaXNhYmxlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIERBVEFfVE9HR0xFX09OOiAnZGF0YS10b2dnbGUtb24nLFxuICBEQVRBX1RPR0dMRV9PRkY6ICdkYXRhLXRvZ2dsZS1vZmYnLFxuICBBUklBX1BSRVNTRUQ6ICdhcmlhLXByZXNzZWQnLFxuICBBUklBX0RJU0FCTEVEOiAnYXJpYS1kaXNhYmxlZCcsXG4gIEFSSUFfTEFCRUw6ICdhcmlhLWxhYmVsJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDSWNvblRvZ2dsZTpjaGFuZ2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDSWNvblRvZ2dsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBzZXRUZXh0OiAoLyogdGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHNldFRhYkluZGV4OiAoLyogdGFiSW5kZXg6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBnZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmcgKi8gJycsXG4gICAgICBzZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtQXR0cjogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiBJY29uVG9nZ2xlRXZlbnQgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMub25fID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5kaXNhYmxlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSAtMTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0ljb25Ub2dnbGVTdGF0ZX0gKi9cbiAgICB0aGlzLnRvZ2dsZU9uRGF0YV8gPSBudWxsO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/SWNvblRvZ2dsZVN0YXRlfSAqL1xuICAgIHRoaXMudG9nZ2xlT2ZmRGF0YV8gPSBudWxsO1xuXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy50b2dnbGVGcm9tRXZ0XygpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmtleXVwSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2dnbGVGcm9tRXZ0XygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUb2dnbGVEYXRhKCk7XG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gIH1cblxuICByZWZyZXNoVG9nZ2xlRGF0YSgpIHtcbiAgICBjb25zdCB7REFUQV9UT0dHTEVfT04sIERBVEFfVE9HR0xFX09GRn0gPSBNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIHRoaXMudG9nZ2xlT25EYXRhXyA9IHRoaXMucGFyc2VKc29uRGF0YUF0dHJfKERBVEFfVE9HR0xFX09OKTtcbiAgICB0aGlzLnRvZ2dsZU9mZkRhdGFfID0gdGhpcy5wYXJzZUpzb25EYXRhQXR0cl8oREFUQV9UT0dHTEVfT0ZGKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRvZ2dsZUZyb21FdnRfKCkge1xuICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgY29uc3Qge29uXzogaXNPbn0gPSB0aGlzO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKC8qKiBAdHlwZSB7IUljb25Ub2dnbGVFdmVudH0gKi8gKHtpc09ufSkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzT24oKSB7XG4gICAgcmV0dXJuIHRoaXMub25fO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IGlzT24gKi9cbiAgdG9nZ2xlKGlzT24gPSAhdGhpcy5vbl8pIHtcbiAgICB0aGlzLm9uXyA9IGlzT247XG5cbiAgICBjb25zdCB7QVJJQV9MQUJFTCwgQVJJQV9QUkVTU0VEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICBpZiAodGhpcy5vbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICdmYWxzZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHtjc3NDbGFzczogY2xhc3NUb1JlbW92ZX0gPVxuICAgICAgICB0aGlzLm9uXyA/IHRoaXMudG9nZ2xlT2ZmRGF0YV8gOiB0aGlzLnRvZ2dsZU9uRGF0YV87XG5cbiAgICBpZiAoY2xhc3NUb1JlbW92ZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjbGFzc1RvUmVtb3ZlKTtcbiAgICB9XG5cbiAgICBjb25zdCB7Y29udGVudCwgbGFiZWwsIGNzc0NsYXNzfSA9IHRoaXMub25fID8gdGhpcy50b2dnbGVPbkRhdGFfIDogdGhpcy50b2dnbGVPZmZEYXRhXztcblxuICAgIGlmIChjc3NDbGFzcykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRleHQoY29udGVudCk7XG4gICAgfVxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfTEFCRUwsIGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFBdHRyXG4gICAqIEByZXR1cm4geyFJY29uVG9nZ2xlU3RhdGV9XG4gICAqL1xuICBwYXJzZUpzb25EYXRhQXR0cl8oZGF0YUF0dHIpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLmFkYXB0ZXJfLmdldEF0dHIoZGF0YUF0dHIpO1xuICAgIGlmICghdmFsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUgeyFJY29uVG9nZ2xlU3RhdGV9ICovIChKU09OLnBhcnNlKHZhbCkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBpc0Rpc2FibGVkO1xuXG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0FSSUFfRElTQUJMRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiSW5kZXgoLTEpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJJbmRleCh0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyKEFSSUFfRElTQUJMRUQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzS2V5Ym9hcmRBY3RpdmF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNIYW5kbGluZ0tleWRvd25fO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAga2V5OiBzdHJpbmcsXG4gKiAgIGtleUNvZGU6IG51bWJlclxuICogfX1cbiAqL1xubGV0IEtleWJvYXJkS2V5O1xuXG4vKipcbiAqIEBwYXJhbSB7IUtleWJvYXJkS2V5fSBrZXlib2FyZEtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGFjZShrZXlib2FyZEtleSkge1xuICByZXR1cm4ga2V5Ym9hcmRLZXkua2V5ID09PSAnU3BhY2UnIHx8IGtleWJvYXJkS2V5LmtleUNvZGUgPT09IDMyO1xufVxuXG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBJY29uVG9nZ2xlU3RhdGUge31cblxuLyoqXG4gKiBUaGUgYXJpYS1sYWJlbCB2YWx1ZSBvZiB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBhcmlhLWxhYmVsLlxuICogQGV4cG9ydCB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuSWNvblRvZ2dsZVN0YXRlLnByb3RvdHlwZS5sYWJlbDtcblxuLyoqXG4gKiBUaGUgdGV4dCBmb3IgdGhlIGljb24gdG9nZ2xlLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gdGV4dC5cbiAqIEBleHBvcnQge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbkljb25Ub2dnbGVTdGF0ZS5wcm90b3R5cGUuY29udGVudDtcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBDU1MgY2xhc3MuXG4gKiBAZXhwb3J0IHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5JY29uVG9nZ2xlU3RhdGUucHJvdG90eXBlLmNzc0NsYXNzO1xuXG5leHBvcnQgZGVmYXVsdCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cInRhYkluZGV4XCJcbiAgICA6ZGF0YS10b2dnbGUtb249XCJ0b2dnbGVPbkRhdGFcIiBcbiAgICA6ZGF0YS10b2dnbGUtb2ZmPVwidG9nZ2xlT2ZmRGF0YVwiXG4gICAgY2xhc3M9XCJtZGMtaWNvbi10b2dnbGVcIlxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIGFyaWEtcHJlc3NlZD1cImZhbHNlXCI+XG4gICAgPGkgXG4gICAgICA6Y2xhc3M9XCJpY29uQ2xhc3Nlc1wiIFxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3sgdGV4dCB9fTwvaT5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvaWNvbi10b2dnbGUvZm91bmRhdGlvbidcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1pY29uLXRvZ2dsZScsXG4gIHByb3BzOiB7XG4gICAgdG9nZ2xlT246IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgdG9nZ2xlT2ZmOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIHZhbHVlOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGFjY2VudDogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtaWNvbi10b2dnbGUtLWFjY2VudCc6IHRoaXMuYWNjZW50XG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGljb25DbGFzc2VzOiB7fSxcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgdGV4dDogJydcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdG9nZ2xlT25EYXRhKCkge1xuICAgICAgbGV0IHRvZ2dsZSA9IHRoaXMudG9nZ2xlT25cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRvZ2dsZSAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0eXBlb2YgdG9nZ2xlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdG9nZ2xlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvZ2dsZS5pY29uIHx8IHRvZ2dsZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEoKSB7XG4gICAgICBsZXQgdG9nZ2xlID0gdGhpcy50b2dnbGVPZmZcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRvZ2dsZSAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0eXBlb2YgdG9nZ2xlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdG9nZ2xlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvZ2dsZS5pY29uIHx8IHRvZ2dsZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHZhbHVlKVxuICAgIH0sXG4gICAgZGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQoZGlzYWJsZWQpXG4gICAgfSxcbiAgICB0b2dnbGVPbkRhdGEoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIGFjY2VudCh2YWx1ZSkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1pY29uLXRvZ2dsZS0tc2Vjb25kYXJ5JywgdmFsdWUpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmljb25DbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5pY29uQ2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBzZXRUZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dFxuICAgICAgfSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiB0aGlzLnRhYkluZGV4LFxuICAgICAgc2V0VGFiSW5kZXg6IHRhYkluZGV4ID0+IHtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IHRhYkluZGV4XG4gICAgICB9LFxuICAgICAgZ2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5nZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgc2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBybUF0dHI6IG5hbWUgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2dERhdGEuaXNPbilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHRoaXMudmFsdWUpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB0aGlzLmZvdW5kYXRpb24uaXNLZXlib2FyZEFjdGl2YXRlZCgpXG4gICAgfSlcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjSUNvblRvZ2dsZSBmcm9tICcuL21kYy1pY29uLXRvZ2dsZS52dWUnXG5cbmV4cG9ydCB7IG1kY0lDb25Ub2dnbGUgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjSUNvblRvZ2dsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLXRvb2xiYXItd3JhcHBlclwiPlxuICAgICAgPHNsb3QgbmFtZT1cInRvb2xiYXJcIiAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwLS1tYWluLWNvbnRhaW5lclwiPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLWRyYXdlci13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJkcmF3ZXJcIiAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWFwcC0tY29udGVudC13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWFwcCdcbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjTGF5b3V0QXBwIGZyb20gJy4vbWRjLWxheW91dC1hcHAudnVlJ1xuXG5leHBvcnQgeyBtZGNMYXlvdXRBcHAgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGF5b3V0QXBwXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1ncmlkX19pbm5lclwiPlxuICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWdyaWQnLFxuICBwcm9wczoge1xuICAgICdmaXhlZC1jb2x1bW4td2lkdGgnOiBCb29sZWFuLFxuICAgICdhbGlnbi1sZWZ0JzogQm9vbGVhbixcbiAgICAnYWxpZ24tcmlnaHQnOiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtbGF5b3V0LWdyaWQnOiB0cnVlLFxuICAgICAgICAnbWRjLWxheW91dC1ncmlkLS1maXhlZC1jb2x1bW4td2lkdGgnOiB0aGlzLmZpeGVkQ29sdW1uV2lkdGgsXG4gICAgICAgICdtZGMtbGF5b3V0LWdyaWQtLWFsaWduLWxlZnQnOiB0aGlzLmFsaWduTGVmdCxcbiAgICAgICAgJ21kYy1sYXlvdXQtZ3JpZC0tYWxpZ24tcmlnaHQnOiB0aGlzLmFsaWduUmlnaHRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1sYXlvdXQtY2VsbCBtZGMtbGF5b3V0LWdyaWRfX2NlbGxcIj5cbiAgICA8c2xvdC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmNvbnN0IHNwYW5PcHRpb25zID0ge1xuICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICBkZWZhdWx0OiBudWxsLFxuICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG51bSA9IE51bWJlcih2YWx1ZSlcbiAgICByZXR1cm4gaXNGaW5pdGUobnVtKSAmJiBudW0gPD0gMTIgJiYgbnVtID4gMFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1sYXlvdXQtY2VsbCcsXG4gIHByb3BzOiB7XG4gICAgc3Bhbjogc3Bhbk9wdGlvbnMsXG4gICAgb3JkZXI6IHNwYW5PcHRpb25zLFxuICAgIHBob25lOiBzcGFuT3B0aW9ucyxcbiAgICB0YWJsZXQ6IHNwYW5PcHRpb25zLFxuICAgIGRlc2t0b3A6IHNwYW5PcHRpb25zLFxuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbJ3RvcCcsICdib3R0b20nLCAnbWlkZGxlJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBsZXQgY2xhc3NlcyA9IFtdXG5cbiAgICAgIGlmICh0aGlzLnNwYW4pIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLnNwYW59YClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3JkZXIpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLW9yZGVyLSR7dGhpcy5vcmRlcn1gKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5waG9uZSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3Bhbi0ke3RoaXMucGhvbmV9LXBob25lYClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGFibGV0KSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy50YWJsZXR9LXRhYmxldGApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRlc2t0b3ApIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLmRlc2t0b3B9LWRlc2t0b3BgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hbGlnbikge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tYWxpZ24tJHt0aGlzLmFsaWdufWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGFzc2VzXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtaW5uZXItZ3JpZCBtZGMtbGF5b3V0LWdyaWRfX2lubmVyXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWlubmVyLWdyaWQnXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xheW91dEdyaWQgZnJvbSAnLi9tZGMtbGF5b3V0LWdyaWQudnVlJ1xuaW1wb3J0IG1kY0xheW91dENlbGwgZnJvbSAnLi9tZGMtbGF5b3V0LWNlbGwudnVlJ1xuaW1wb3J0IG1kY0xheW91dElubmVyR3JpZCBmcm9tICcuL21kYy1sYXlvdXQtaW5uZXItZ3JpZC52dWUnXG5cbmV4cG9ydCB7IG1kY0xheW91dEdyaWQsIG1kY0xheW91dENlbGwsIG1kY0xheW91dElubmVyR3JpZCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMYXlvdXRHcmlkLFxuICBtZGNMYXlvdXRDZWxsLFxuICBtZGNMYXlvdXRJbm5lckdyaWRcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQ0xPU0VEX0NMQVNTOiAnbWRjLWxpbmVhci1wcm9ncmVzcy0tY2xvc2VkJyxcbiAgSU5ERVRFUk1JTkFURV9DTEFTUzogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWluZGV0ZXJtaW5hdGUnLFxuICBSRVZFUlNFRF9DTEFTUzogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLXJldmVyc2VkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBQUklNQVJZX0JBUl9TRUxFQ1RPUjogJy5tZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhcicsXG4gIEJVRkZFUl9TRUxFQ1RPUjogJy5tZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXInLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHt0cmFuc2Zvcm1TdHlsZVByb3BlcnRpZXN9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0UHJpbWFyeUJhcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge30sXG4gICAgICBnZXRCdWZmZXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHt9LFxuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gZmFsc2UsXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoLyogZWw6IEVsZW1lbnQsIHN0eWxlUHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmRldGVybWluYXRlXyA9ICF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DTEFTUyk7XG4gICAgdGhpcy5yZXZlcnNlXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgdGhpcy5wcm9ncmVzc18gPSAwO1xuICB9XG5cbiAgc2V0RGV0ZXJtaW5hdGUoaXNEZXRlcm1pbmF0ZSkge1xuICAgIHRoaXMuZGV0ZXJtaW5hdGVfID0gaXNEZXRlcm1pbmF0ZTtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCB0aGlzLnByb2dyZXNzXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCAxKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0QnVmZmVyKCksIDEpO1xuICAgIH1cbiAgfVxuXG4gIHNldFByb2dyZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5wcm9ncmVzc18gPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0QnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGV0ZXJtaW5hdGVfKSB7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldEJ1ZmZlcigpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0UmV2ZXJzZShpc1JldmVyc2VkKSB7XG4gICAgdGhpcy5yZXZlcnNlXyA9IGlzUmV2ZXJzZWQ7XG4gICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQ0xPU0VEX0NMQVNTKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5DTE9TRURfQ0xBU1MpO1xuICB9XG5cbiAgc2V0U2NhbGVfKGVsLCBzY2FsZVZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSAnc2NhbGVYKCcgKyBzY2FsZVZhbHVlICsgJyknO1xuICAgIHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcy5mb3JFYWNoKCh0cmFuc2Zvcm1TdHlsZVByb3BlcnR5KSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKGVsLCB0cmFuc2Zvcm1TdHlsZVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgcm9sZT1cInByb2dyZXNzYmFyXCIgXG4gICAgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2J1ZmZlcmluZy1kb3RzXCIvPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJidWZmZXJcIiBcbiAgICAgIGNsYXNzPVwibWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyXCIvPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJwcmltYXJ5XCIgXG4gICAgICBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXItaW5uZXJcIi8+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19zZWNvbmRhcnktYmFyXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2Jhci1pbm5lclwiLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lYXItcHJvZ3Jlc3MvZm91bmRhdGlvbidcblxuY29uc3QgUHJvZ3Jlc3NQcm9wVHlwZSA9IHtcbiAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPj0gMCAmJiBOdW1iZXIodmFsdWUpIDw9IDFcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGluZWFyLXByb2dyZXNzJyxcbiAgcHJvcHM6IHtcbiAgICBvcGVuOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfSxcbiAgICBpbmRldGVybWluYXRlOiBCb29sZWFuLFxuICAgIHJldmVyc2U6IEJvb2xlYW4sXG4gICAgYWNjZW50OiBCb29sZWFuLFxuICAgIHByb2dyZXNzOiBQcm9ncmVzc1Byb3BUeXBlLFxuICAgIGJ1ZmZlcjogUHJvZ3Jlc3NQcm9wVHlwZVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7ICdtZGMtbGluZWFyLXByb2dyZXNzLS1hY2NlbnQnOiB0aGlzLmFjY2VudCB9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvZ3Jlc3MoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIH0sXG4gICAgYnVmZmVyKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEJ1ZmZlcihOdW1iZXIodGhpcy5idWZmZXIpKVxuICAgIH0sXG4gICAgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREZXRlcm1pbmF0ZSghdGhpcy5pbmRldGVybWluYXRlKVxuICAgIH0sXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIGdldFByaW1hcnlCYXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucHJpbWFyeVxuICAgICAgfSxcbiAgICAgIGdldEJ1ZmZlcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5idWZmZXJcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAoZWwsIHN0eWxlUHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW3N0eWxlUHJvcGVydHldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRCdWZmZXIoTnVtYmVyKHRoaXMuYnVmZmVyKSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGV0ZXJtaW5hdGUoIXRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMaW5lYXJQcm9ncmVzcyBmcm9tICcuL21kYy1saW5lYXItcHJvZ3Jlc3MudnVlJ1xuXG5leHBvcnQgeyBtZGNMaW5lYXJQcm9ncmVzcyB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMaW5lYXJQcm9ncmVzc1xufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHVsIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1saXN0XCI+XG4gICAgPHNsb3QvPlxuICA8L3VsPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0JyxcbiAgcHJvcHM6IHtcbiAgICBkZW5zZTogQm9vbGVhbixcbiAgICBhdmF0YXJMaXN0OiBCb29sZWFuLFxuICAgIHR3b0xpbmU6IEJvb2xlYW4sXG4gICAgYm9yZGVyZWQ6IEJvb2xlYW4sXG4gICAgaW50ZXJhY3RpdmU6IEJvb2xlYW5cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNMaXN0OiB0aGlzIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtbGlzdC0tYXZhdGFyLWxpc3QnOiB0aGlzLmF2YXRhckxpc3QsXG4gICAgICAgICdtZGMtbGlzdC0tdHdvLWxpbmUnOiB0aGlzLnR3b0xpbmUsXG4gICAgICAgICdtZGMtbGlzdC0tYm9yZGVyZWQnOiB0aGlzLmJvcmRlcmVkLFxuICAgICAgICAnbWRjLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSc6ICF0aGlzLmludGVyYWN0aXZlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIFxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIiAgIFxuICAgIGNsYXNzPVwibWRjLWxpc3QtaXRlbVwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyAkbGlzdGVuZXJzIDoge31cIj5cblxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cImhhc1N0YXJ0RGV0YWlsXCIgXG4gICAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX2dyYXBoaWNcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIi8+XG4gICAgPC9zcGFuPlxuXG4gICAgPHNwYW4gXG4gICAgICB2LWlmPVwiaGFzU2Vjb25kYXJ5XCIgXG4gICAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX3RleHRcIj5cbiAgICAgIDxzbG90Lz5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fc2Vjb25kYXJ5LXRleHRcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cInNlY29uZGFyeVwiLz5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gICAgPHNsb3Qgdi1lbHNlLz5cblxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cImhhc0VuZERldGFpbFwiIFxuICAgICAgY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19tZXRhXCI+XG4gICAgICA8c2xvdCBuYW1lPVwiZW5kLWRldGFpbFwiLz5cbiAgICA8L3NwYW4+XG5cbiAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1pdGVtJyxcbiAgaW5qZWN0OiBbJ21kY0xpc3QnXSxcbiAgcHJvcHM6IHtcbiAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJzogdGhpcy5zZWxlY3RlZCxcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCc6IHRoaXMuYWN0aXZhdGVkXG4gICAgICB9XG4gICAgfSxcbiAgICBpc0ludGVyYWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QuaW50ZXJhY3RpdmVcbiAgICB9LFxuICAgIGhhc1NlY29uZGFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzbG90c1snc2Vjb25kYXJ5J10gJiYgKHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QudHdvTGluZSlcbiAgICB9LFxuICAgIGhhc0VuZERldGFpbCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzSW50ZXJhY3RpdmUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZFJpcHBsZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuaXNJbnRlcmFjdGl2ZSAmJiB0aGlzLmFkZFJpcHBsZSgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYWRkUmlwcGxlKCkge1xuICAgICAgaWYgKCF0aGlzLnJpcHBsZSkge1xuICAgICAgICBsZXQgcmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICAgICAgcmlwcGxlLmluaXQoKVxuICAgICAgICB0aGlzLnJpcHBsZSA9IHJpcHBsZVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlUmlwcGxlKCkge1xuICAgICAgaWYgKHRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSB0aGlzLnJpcHBsZVxuICAgICAgICB0aGlzLnJpcHBsZSA9IG51bGxcbiAgICAgICAgcmlwcGxlLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgcm9sZT1cInNlcGFyYXRvclwiIFxuICAgIGNsYXNzPVwibWRjLWxpc3QtZGl2aWRlclwiLz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1kaXZpZGVyJyxcbiAgcHJvcHM6IHtcbiAgICBpbnNldDogQm9vbGVhbixcbiAgICBwYWRkZWQ6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLWluc2V0JzogdGhpcy5pbnNldCxcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLXBhZGRlZCc6IHRoaXMucGFkZGVkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1saXN0LWdyb3VwXCI+PHNsb3QvPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoMyBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWhlYWRlciBtZGMtbGlzdC1ncm91cF9fc3ViaGVhZGVyXCI+PHNsb3QvPjwvaDM+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QtZ3JvdXAtaGVhZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxociBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWRpdmlkZXIgbWRjLWxpc3QtZGl2aWRlclwiPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwLWRpdmlkZXInXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xpc3QgZnJvbSAnLi9tZGMtbGlzdC52dWUnXG5pbXBvcnQgbWRjTGlzdEl0ZW0gZnJvbSAnLi9tZGMtbGlzdC1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNMaXN0RGl2aWRlciBmcm9tICcuL21kYy1saXN0LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cCBmcm9tICcuL21kYy1saXN0LWdyb3VwLnZ1ZSdcbmltcG9ydCBtZGNMaXN0R3JvdXBIZWFkZXIgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cERpdmlkZXIgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC1kaXZpZGVyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjTGlzdCxcbiAgbWRjTGlzdEl0ZW0sXG4gIG1kY0xpc3REaXZpZGVyLFxuICBtZGNMaXN0R3JvdXAsXG4gIG1kY0xpc3RHcm91cEhlYWRlcixcbiAgbWRjTGlzdEdyb3VwRGl2aWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGlzdCxcbiAgbWRjTGlzdEl0ZW0sXG4gIG1kY0xpc3REaXZpZGVyLFxuICBtZGNMaXN0R3JvdXAsXG4gIG1kY0xpc3RHcm91cEhlYWRlcixcbiAgbWRjTGlzdEdyb3VwRGl2aWRlclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgTWVudS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBmb2N1c1xuICogLSBwb3NpdGlvblxuICogLSBkaW1lbnNpb25zXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENNZW51QWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaGFzTmVjZXNzYXJ5RG9tKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0KHRhcmdldCwgYXR0cmlidXRlTmFtZSkge31cblxuICAvKiogQHJldHVybiB7eyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSAqL1xuICBnZXRJbm5lckRpbWVuc2lvbnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBoYXNBbmNob3IoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfX0gKi9cbiAgZ2V0QW5jaG9yRGltZW5zaW9ucygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3sgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gKi9cbiAgZ2V0V2luZG93RGltZW5zaW9ucygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TnVtYmVyT2ZJdGVtcygpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlciAqL1xuICByZWdpc3RlckJvZHlDbGlja0hhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0KHRhcmdldCkge31cblxuICAvKiogQHBhcmFtIHt7aW5kZXg6IG51bWJlcn19IGV2dERhdGEgKi9cbiAgbm90aWZ5U2VsZWN0ZWQoZXZ0RGF0YSkge31cblxuICBub3RpZnlDYW5jZWwoKSB7fVxuXG4gIHNhdmVGb2N1cygpIHt9XG5cbiAgcmVzdG9yZUZvY3VzKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICBmb2N1cygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0Rm9jdXNlZEl0ZW1JbmRleCgpIC8qIG51bWJlciAqLyB7fVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gaW5kZXggKi9cbiAgZm9jdXNJdGVtQXRJbmRleChpbmRleCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luICovXG4gIHNldFRyYW5zZm9ybU9yaWdpbihvcmlnaW4pIHt9XG5cbiAgLyoqIEBwYXJhbSB7e1xuICAqICAgdG9wOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICByaWdodDogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAqICAgYm90dG9tOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICBsZWZ0OiAoc3RyaW5nfHVuZGVmaW5lZClcbiAgKiB9fSBwb3NpdGlvbiAqL1xuICBzZXRQb3NpdGlvbihwb3NpdGlvbikge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAqL1xuICBzZXRNYXhIZWlnaHQoaGVpZ2h0KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleChpbmRleCwgYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKi9cbiAgcm1BdHRyRm9yT3B0aW9uQXRJbmRleChpbmRleCwgYXR0cikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleChpbmRleCwgY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGNsYXNzTmFtZSkge31cbn1cblxuZXhwb3J0IHtNRENNZW51QWRhcHRlcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLW1lbnUnLFxuICBPUEVOOiAnbWRjLW1lbnUtLW9wZW4nLFxuICBBTklNQVRJTkdfT1BFTjogJ21kYy1tZW51LS1hbmltYXRpbmctb3BlbicsXG4gIEFOSU1BVElOR19DTE9TRUQ6ICdtZGMtbWVudS0tYW5pbWF0aW5nLWNsb3NlZCcsXG4gIFNFTEVDVEVEX0xJU1RfSVRFTTogJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgSVRFTVNfU0VMRUNUT1I6ICcubWRjLW1lbnVfX2l0ZW1zJyxcbiAgU0VMRUNURURfRVZFTlQ6ICdNRENNZW51OnNlbGVjdGVkJyxcbiAgQ0FOQ0VMX0VWRU5UOiAnTURDTWVudTpjYW5jZWwnLFxuICBBUklBX0RJU0FCTEVEX0FUVFI6ICdhcmlhLWRpc2FibGVkJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgLy8gQW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgdHJpZ2dlcmluZyBhIHNlbGVjdGVkIGV2ZW50IG9uIHRoZSBtZW51LiBOb3RlIHRoYXQgdGhpcyB0aW1lXG4gIC8vIHdpbGwgbW9zdCBsaWtlbHkgYmUgYnVtcGVkIHVwIG9uY2UgaW50ZXJhY3RpdmUgbGlzdHMgYXJlIHN1cHBvcnRlZCB0byBhbGxvdyBmb3IgdGhlIHJpcHBsZSB0b1xuICAvLyBhbmltYXRlIGJlZm9yZSBjbG9zaW5nIHRoZSBtZW51XG4gIFNFTEVDVEVEX1RSSUdHRVJfREVMQVk6IDUwLFxuICAvLyBUb3RhbCBkdXJhdGlvbiBvZiBtZW51IG9wZW4gYW5pbWF0aW9uLlxuICBUUkFOU0lUSU9OX09QRU5fRFVSQVRJT046IDEyMCxcbiAgLy8gVG90YWwgZHVyYXRpb24gb2YgbWVudSBjbG9zZSBhbmltYXRpb24uXG4gIFRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT046IDc1LFxuICAvLyBNYXJnaW4gbGVmdCB0byB0aGUgZWRnZSBvZiB0aGUgdmlld3BvcnQgd2hlbiBtZW51IGlzIGF0IG1heGltdW0gcG9zc2libGUgaGVpZ2h0LlxuICBNQVJHSU5fVE9fRURHRTogMzIsXG4gIC8vIFJhdGlvIG9mIGFuY2hvciB3aWR0aCB0byBtZW51IHdpZHRoIGZvciBzd2l0Y2hpbmcgZnJvbSBjb3JuZXIgcG9zaXRpb25pbmcgdG8gY2VudGVyIHBvc2l0aW9uaW5nLlxuICBBTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTzogMC42NyxcbiAgLy8gUmF0aW8gb2YgdmVydGljYWwgb2Zmc2V0IHRvIG1lbnUgaGVpZ2h0IGZvciBzd2l0Y2hpbmcgZnJvbSBjb3JuZXIgdG8gbWlkLXdheSBvcmlnaW4gcG9zaXRpb25pbmcuXG4gIE9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTzogMC4xLFxufTtcblxuLyoqXG4gKiBFbnVtIGZvciBiaXRzIGluIHRoZSB7QHNlZSBDb3JuZXIpIGJpdG1hcC5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IENvcm5lckJpdCA9IHtcbiAgQk9UVE9NOiAxLFxuICBDRU5URVI6IDIsXG4gIFJJR0hUOiA0LFxuICBGTElQX1JUTDogOCxcbn07XG5cbi8qKlxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGFuIGVsZW1lbnQgY29ybmVyIGZvciBwb3NpdGlvbmluZyB0aGUgbWVudS5cbiAqXG4gKiBUaGUgU1RBUlQgY29uc3RhbnRzIG1hcCB0byBMRUZUIGlmIGVsZW1lbnQgZGlyZWN0aW9uYWxpdHkgaXMgbGVmdFxuICogdG8gcmlnaHQgYW5kIFJJR0hUIGlmIHRoZSBkaXJlY3Rpb25hbGl0eSBpcyByaWdodCB0byBsZWZ0LlxuICogTGlrZXdpc2UgRU5EIG1hcHMgdG8gUklHSFQgb3IgTEVGVCBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbmFsaXR5LlxuICpcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IENvcm5lciA9IHtcbiAgVE9QX0xFRlQ6IDAsXG4gIFRPUF9SSUdIVDogQ29ybmVyQml0LlJJR0hULFxuICBCT1RUT01fTEVGVDogQ29ybmVyQml0LkJPVFRPTSxcbiAgQk9UVE9NX1JJR0hUOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LlJJR0hULFxuICBUT1BfU1RBUlQ6IENvcm5lckJpdC5GTElQX1JUTCxcbiAgVE9QX0VORDogQ29ybmVyQml0LkZMSVBfUlRMIHwgQ29ybmVyQml0LlJJR0hULFxuICBCT1RUT01fU1RBUlQ6IENvcm5lckJpdC5CT1RUT00gfCBDb3JuZXJCaXQuRkxJUF9SVEwsXG4gIEJPVFRPTV9FTkQ6IENvcm5lckJpdC5CT1RUT00gfCBDb3JuZXJCaXQuUklHSFQgfCBDb3JuZXJCaXQuRkxJUF9SVEwsXG59O1xuXG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVycywgQ29ybmVyQml0LCBDb3JuZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdG9wOiBudW1iZXIsXG4gKiAgIHJpZ2h0OiBudW1iZXIsXG4gKiAgIGJvdHRvbTogbnVtYmVyLFxuICogICBsZWZ0OiBudW1iZXJcbiAqIH19XG4gKi9cbmxldCBBbmNob3JNYXJnaW47XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHZpZXdwb3J0OiB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0sXG4gKiAgIHZpZXdwb3J0RGlzdGFuY2U6IHt0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIGxlZnQ6IG51bWJlcn0sXG4gKiAgIGFuY2hvckhlaWdodDogbnVtYmVyLFxuICogICBhbmNob3JXaWR0aDogbnVtYmVyLFxuICogICBtZW51SGVpZ2h0OiBudW1iZXIsXG4gKiAgIG1lbnVXaWR0aDogbnVtYmVyLFxuICogfX1cbiAqL1xubGV0IEF1dG9MYXlvdXRNZWFzdXJlbWVudHM7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtNRENNZW51QWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVycywgQ29ybmVyLCBDb3JuZXJCaXR9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDTWVudUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENNZW51Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVte2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBDb3JuZXIoKSB7XG4gICAgcmV0dXJuIENvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENNZW51QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENNZW51QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ01lbnVBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IGZhbHNlLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiBmYWxzZSxcbiAgICAgIGdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0OiAoKSA9PiB7fSxcbiAgICAgIGdldElubmVyRGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT4gZmFsc2UsXG4gICAgICBnZXRBbmNob3JEaW1lbnNpb25zOiAoKSA9PiAoe30pLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGdldE51bWJlck9mSXRlbXM6ICgpID0+IDAsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0OiAoKSA9PiAwLFxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHNhdmVGb2N1czogKCkgPT4ge30sXG4gICAgICByZXN0b3JlRm9jdXM6ICgpID0+IHt9LFxuICAgICAgaXNGb2N1c2VkOiAoKSA9PiBmYWxzZSxcbiAgICAgIGZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IC0xLFxuICAgICAgZm9jdXNJdGVtQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4gZmFsc2UsXG4gICAgICBzZXRUcmFuc2Zvcm1PcmlnaW46ICgpID0+IHt9LFxuICAgICAgc2V0UG9zaXRpb246ICgpID0+IHt9LFxuICAgICAgc2V0TWF4SGVpZ2h0OiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHJGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHJtQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENNZW51QWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENNZW51Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlUG9zc2libGVTZWxlY3RlZF8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUtleWJvYXJkRG93bl8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5rZXl1cEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVLZXlib2FyZFVwXyhldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRG9jdW1lbnRDbGlja18oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gMDtcbiAgICAvKiogQHByaXZhdGUgeyF7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19ICovXG4gICAgdGhpcy5kaW1lbnNpb25zXztcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLml0ZW1IZWlnaHRfO1xuICAgIC8qKiBAcHJpdmF0ZSB7Q29ybmVyfSAqL1xuICAgIHRoaXMuYW5jaG9yQ29ybmVyXyA9IENvcm5lci5UT1BfU1RBUlQ7XG4gICAgLyoqIEBwcml2YXRlIHtBbmNob3JNYXJnaW59ICovXG4gICAgdGhpcy5hbmNob3JNYXJnaW5fID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH07XG4gICAgLyoqIEBwcml2YXRlIHs/QXV0b0xheW91dE1lYXN1cmVtZW50c30gKi9cbiAgICB0aGlzLm1lYXN1cmVzXyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IC0xO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnF1aWNrT3Blbl8gPSBmYWxzZTtcblxuICAgIC8vIEEga2V5dXAgZXZlbnQgb24gdGhlIG1lbnUgbmVlZHMgdG8gaGF2ZSBhIGNvcnJlc3BvbmRpbmcga2V5ZG93blxuICAgIC8vIGV2ZW50IG9uIHRoZSBtZW51LiBJZiB0aGUgdXNlciBvcGVucyB0aGUgbWVudSB3aXRoIGEga2V5ZG93biBldmVudCBvbiBhXG4gICAgLy8gYnV0dG9uLCB0aGUgbWVudSB3aWxsIG9ubHkgZ2V0IHRoZSBrZXkgdXAgZXZlbnQgY2F1c2luZyBidWdneSBiZWhhdmlvciB3aXRoIHNlbGVjdGVkIGVsZW1lbnRzLlxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGZhbHNlO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7Uk9PVCwgT1BFTn0gPSBNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKFJPT1QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Uk9PVH0gY2xhc3MgcmVxdWlyZWQgaW4gcm9vdCBlbGVtZW50LmApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNOZWNlc3NhcnlEb20oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1aXJlZCBET00gbm9kZXMgbWlzc2luZyBpbiAke1JPT1R9IGNvbXBvbmVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhPUEVOKSkge1xuICAgICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8pO1xuICAgIC8vIENhbmNlbCBhbnkgY3VycmVudGx5IHJ1bm5pbmcgYW5pbWF0aW9ucy5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDb3JuZXJ9IGNvcm5lciBEZWZhdWx0IGFuY2hvciBjb3JuZXIgYWxpZ25tZW50IG9mIHRvcC1sZWZ0IG1lbnUgY29ybmVyLlxuICAgKi9cbiAgc2V0QW5jaG9yQ29ybmVyKGNvcm5lcikge1xuICAgIHRoaXMuYW5jaG9yQ29ybmVyXyA9IGNvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBbmNob3JNYXJnaW59IG1hcmdpbiA0LXBsZXQgb2YgbWFyZ2lucyBmcm9tIGFuY2hvci5cbiAgICovXG4gIHNldEFuY2hvck1hcmdpbihtYXJnaW4pIHtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8udG9wID0gdHlwZW9mIG1hcmdpbi50b3AgPT09ICdudW1iZXInID8gbWFyZ2luLnRvcCA6IDA7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0ID0gdHlwZW9mIG1hcmdpbi5yaWdodCA9PT0gJ251bWJlcicgPyBtYXJnaW4ucmlnaHQgOiAwO1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b20gPSB0eXBlb2YgbWFyZ2luLmJvdHRvbSA9PT0gJ251bWJlcicgPyBtYXJnaW4uYm90dG9tIDogMDtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdCA9IHR5cGVvZiBtYXJnaW4ubGVmdCA9PT0gJ251bWJlcicgPyBtYXJnaW4ubGVmdCA6IDA7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSByZW1lbWJlclNlbGVjdGlvbiAqL1xuICBzZXRSZW1lbWJlclNlbGVjdGlvbihyZW1lbWJlclNlbGVjdGlvbikge1xuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb25fID0gcmVtZW1iZXJTZWxlY3Rpb247XG4gICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KC0xKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHF1aWNrT3BlbiAqL1xuICBzZXRRdWlja09wZW4ocXVpY2tPcGVuKSB7XG4gICAgdGhpcy5xdWlja09wZW5fID0gcXVpY2tPcGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P251bWJlcn0gZm9jdXNJbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZm9jdXNPbk9wZW5fKGZvY3VzSW5kZXgpIHtcbiAgICBpZiAoZm9jdXNJbmRleCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBpbnN0YW5jZSBvZiBNRENNZW51IHJlbWVtYmVycyBzZWxlY3Rpb25zLCBhbmQgdGhlIHVzZXIgaGFzXG4gICAgICAvLyBtYWRlIGEgc2VsZWN0aW9uLCB0aGVuIGZvY3VzIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW1cbiAgICAgIGlmICh0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXyAmJiB0aGlzLnNlbGVjdGVkSW5kZXhfID49IDApIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXMoKTtcbiAgICAgIC8vIElmIHRoYXQgZG9lc24ndCB3b3JrLCBmb2N1cyBmaXJzdCBpdGVtIGluc3RlYWQuXG4gICAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoZm9jdXNJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3MgYW5kIGNhbmNlbCB0aGUgbWVudSBpZiBub3QgYSBjaGlsZCBsaXN0LWl0ZW1cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRG9jdW1lbnRDbGlja18oZXZ0KSB7XG4gICAgbGV0IGVsID0gZXZ0LnRhcmdldDtcblxuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXRJbmRleEZvckV2ZW50VGFyZ2V0KGVsKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgdGhpcy5jbG9zZShldnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUga2V5cyB0aGF0IHdlIHdhbnQgdG8gcmVwZWF0IG9uIGhvbGQgKHRhYiBhbmQgYXJyb3dzKS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlS2V5Ym9hcmREb3duXyhldnQpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIEFsdCwgQ3RybCBvciBNZXRhIGFyZSBwcmVzc2VkLlxuICAgIGlmIChldnQuYWx0S2V5IHx8IGV2dC5jdHJsS2V5IHx8IGV2dC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7a2V5Q29kZSwga2V5LCBzaGlmdEtleX0gPSBldnQ7XG4gICAgY29uc3QgaXNUYWIgPSBrZXkgPT09ICdUYWInIHx8IGtleUNvZGUgPT09IDk7XG4gICAgY29uc3QgaXNBcnJvd1VwID0ga2V5ID09PSAnQXJyb3dVcCcgfHwga2V5Q29kZSA9PT0gMzg7XG4gICAgY29uc3QgaXNBcnJvd0Rvd24gPSBrZXkgPT09ICdBcnJvd0Rvd24nIHx8IGtleUNvZGUgPT09IDQwO1xuICAgIGNvbnN0IGlzU3BhY2UgPSBrZXkgPT09ICdTcGFjZScgfHwga2V5Q29kZSA9PT0gMzI7XG4gICAgY29uc3QgaXNFbnRlciA9IGtleSA9PT0gJ0VudGVyJyB8fCBrZXlDb2RlID09PSAxMztcbiAgICAvLyBUaGUgbWVudSBuZWVkcyB0byBrbm93IGlmIHRoZSBrZXlkb3duIGV2ZW50IHdhcyB0cmlnZ2VyZWQgb24gdGhlIG1lbnVcbiAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGlzRW50ZXIgfHwgaXNTcGFjZTtcblxuICAgIGNvbnN0IGZvY3VzZWRJdGVtSW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzZWRJdGVtSW5kZXgoKTtcbiAgICBjb25zdCBsYXN0SXRlbUluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZkl0ZW1zKCkgLSAxO1xuXG4gICAgaWYgKHNoaWZ0S2V5ICYmIGlzVGFiICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChsYXN0SXRlbUluZGV4KTtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghc2hpZnRLZXkgJiYgaXNUYWIgJiYgZm9jdXNlZEl0ZW1JbmRleCA9PT0gbGFzdEl0ZW1JbmRleCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KDApO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIEFycm93e1VwLERvd259IGFuZCBzcGFjZSBkbyBub3QgY2F1c2UgaW5hZHZlcnRlbnQgc2Nyb2xsaW5nXG4gICAgaWYgKGlzQXJyb3dVcCB8fCBpc0Fycm93RG93biB8fCBpc1NwYWNlKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJvd1VwKSB7XG4gICAgICBpZiAoZm9jdXNlZEl0ZW1JbmRleCA9PT0gMCB8fCB0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChsYXN0SXRlbUluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChmb2N1c2VkSXRlbUluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Fycm93RG93bikge1xuICAgICAgaWYgKGZvY3VzZWRJdGVtSW5kZXggPT09IGxhc3RJdGVtSW5kZXggfHwgdGhpcy5hZGFwdGVyXy5pc0ZvY3VzZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoZm9jdXNlZEl0ZW1JbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBrZXlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byByZXBlYXQgb24gaG9sZCAoRW50ZXIsIFNwYWNlLCBFc2NhcGUpLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVLZXlib2FyZFVwXyhldnQpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIEFsdCwgQ3RybCBvciBNZXRhIGFyZSBwcmVzc2VkLlxuICAgIGlmIChldnQuYWx0S2V5IHx8IGV2dC5jdHJsS2V5IHx8IGV2dC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7a2V5Q29kZSwga2V5fSA9IGV2dDtcbiAgICBjb25zdCBpc0VudGVyID0ga2V5ID09PSAnRW50ZXInIHx8IGtleUNvZGUgPT09IDEzO1xuICAgIGNvbnN0IGlzU3BhY2UgPSBrZXkgPT09ICdTcGFjZScgfHwga2V5Q29kZSA9PT0gMzI7XG4gICAgY29uc3QgaXNFc2NhcGUgPSBrZXkgPT09ICdFc2NhcGUnIHx8IGtleUNvZGUgPT09IDI3O1xuXG4gICAgaWYgKGlzRW50ZXIgfHwgaXNTcGFjZSkge1xuICAgICAgLy8gSWYgdGhlIGtleWRvd24gZXZlbnQgZGlkbid0IG9jY3VyIG9uIHRoZSBtZW51LCB0aGVuIGl0IHNob3VsZFxuICAgICAgLy8gZGlzcmVnYXJkIHRoZSBwb3NzaWJsZSBzZWxlY3RlZCBldmVudC5cbiAgICAgIGlmICh0aGlzLmtleURvd25XaXRoaW5NZW51Xykge1xuICAgICAgICB0aGlzLmhhbmRsZVBvc3NpYmxlU2VsZWN0ZWRfKGV2dCk7XG4gICAgICB9XG4gICAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0VzY2FwZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDYW5jZWwoKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb3NzaWJsZVNlbGVjdGVkXyhldnQpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldChldnQudGFyZ2V0LCBzdHJpbmdzLkFSSUFfRElTQUJMRURfQVRUUikgPT09ICd0cnVlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0SW5kZXhGb3JFdmVudFRhcmdldChldnQudGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlYm91bmNlIG11bHRpcGxlIHNlbGVjdGlvbnNcbiAgICBpZiAodGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfID0gMDtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIGlmICh0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXykge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgodGFyZ2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCh7aW5kZXg6IHRhcmdldEluZGV4fSk7XG4gICAgfSwgbnVtYmVycy5TRUxFQ1RFRF9UUklHR0VSX0RFTEFZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBdXRvTGF5b3V0TWVhc3VyZW1lbnRzfSBNZWFzdXJlbWVudHMgdXNlZCB0byBwb3NpdGlvbiBtZW51IHBvcHVwLlxuICAgKi9cbiAgZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18oKSB7XG4gICAgY29uc3QgYW5jaG9yUmVjdCA9IHRoaXMuYWRhcHRlcl8uZ2V0QW5jaG9yRGltZW5zaW9ucygpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5hZGFwdGVyXy5nZXRXaW5kb3dEaW1lbnNpb25zKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgdmlld3BvcnREaXN0YW5jZToge1xuICAgICAgICB0b3A6IGFuY2hvclJlY3QudG9wLFxuICAgICAgICByaWdodDogdmlld3BvcnQud2lkdGggLSBhbmNob3JSZWN0LnJpZ2h0LFxuICAgICAgICBsZWZ0OiBhbmNob3JSZWN0LmxlZnQsXG4gICAgICAgIGJvdHRvbTogdmlld3BvcnQuaGVpZ2h0IC0gYW5jaG9yUmVjdC5ib3R0b20sXG4gICAgICB9LFxuICAgICAgYW5jaG9ySGVpZ2h0OiBhbmNob3JSZWN0LmhlaWdodCxcbiAgICAgIGFuY2hvcldpZHRoOiBhbmNob3JSZWN0LndpZHRoLFxuICAgICAgbWVudUhlaWdodDogdGhpcy5kaW1lbnNpb25zXy5oZWlnaHQsXG4gICAgICBtZW51V2lkdGg6IHRoaXMuZGltZW5zaW9uc18ud2lkdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgY29ybmVyIG9mIHRoZSBhbmNob3IgZnJvbSB3aGljaCB0byBhbmltYXRlIGFuZCBwb3NpdGlvbiB0aGUgbWVudS5cbiAgICogQHJldHVybiB7Q29ybmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0T3JpZ2luQ29ybmVyXygpIHtcbiAgICAvLyBEZWZhdWx0czogb3BlbiBmcm9tIHRoZSB0b3AgbGVmdC5cbiAgICBsZXQgY29ybmVyID0gQ29ybmVyLlRPUF9MRUZUO1xuXG4gICAgY29uc3Qge3ZpZXdwb3J0RGlzdGFuY2UsIGFuY2hvckhlaWdodCwgYW5jaG9yV2lkdGgsIG1lbnVIZWlnaHQsIG1lbnVXaWR0aH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IGF2YWlsYWJsZVRvcCA9IGlzQm90dG9tQWxpZ25lZCA/IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0ICsgdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbVxuICAgICAgOiB2aWV3cG9ydERpc3RhbmNlLnRvcCArIHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgY29uc3QgYXZhaWxhYmxlQm90dG9tID0gaXNCb3R0b21BbGlnbmVkID8gdmlld3BvcnREaXN0YW5jZS5ib3R0b20gLSB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tXG4gICAgICA6IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tICsgYW5jaG9ySGVpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcblxuICAgIGNvbnN0IHRvcE92ZXJmbG93ID0gbWVudUhlaWdodCAtIGF2YWlsYWJsZVRvcDtcbiAgICBjb25zdCBib3R0b21PdmVyZmxvdyA9IG1lbnVIZWlnaHQgLSBhdmFpbGFibGVCb3R0b207XG4gICAgaWYgKGJvdHRvbU92ZXJmbG93ID4gMCAmJiB0b3BPdmVyZmxvdyA8IGJvdHRvbU92ZXJmbG93KSB7XG4gICAgICBjb3JuZXIgfD0gQ29ybmVyQml0LkJPVFRPTTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1J0bCA9IHRoaXMuYWRhcHRlcl8uaXNSdGwoKTtcbiAgICBjb25zdCBpc0ZsaXBSdGwgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5GTElQX1JUTCk7XG4gICAgY29uc3QgYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LlJJR0hUKTtcbiAgICBjb25zdCBpc0FsaWduZWRSaWdodCA9IChhdm9pZEhvcml6b250YWxPdmVybGFwICYmICFpc1J0bCkgfHxcbiAgICAgICghYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCAmJiBpc0ZsaXBSdGwgJiYgaXNSdGwpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUxlZnQgPSBpc0FsaWduZWRSaWdodCA/IHZpZXdwb3J0RGlzdGFuY2UubGVmdCArIGFuY2hvcldpZHRoICsgdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDpcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2UubGVmdCArIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuICAgIGNvbnN0IGF2YWlsYWJsZVJpZ2h0ID0gaXNBbGlnbmVkUmlnaHQgPyB2aWV3cG9ydERpc3RhbmNlLnJpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDpcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2UucmlnaHQgKyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuXG4gICAgY29uc3QgbGVmdE92ZXJmbG93ID0gbWVudVdpZHRoIC0gYXZhaWxhYmxlTGVmdDtcbiAgICBjb25zdCByaWdodE92ZXJmbG93ID0gbWVudVdpZHRoIC0gYXZhaWxhYmxlUmlnaHQ7XG5cbiAgICBpZiAoKGxlZnRPdmVyZmxvdyA8IDAgJiYgaXNBbGlnbmVkUmlnaHQgJiYgaXNSdGwpIHx8XG4gICAgICAgIChhdm9pZEhvcml6b250YWxPdmVybGFwICYmICFpc0FsaWduZWRSaWdodCAmJiBsZWZ0T3ZlcmZsb3cgPCAwKSB8fFxuICAgICAgICAocmlnaHRPdmVyZmxvdyA+IDAgJiYgbGVmdE92ZXJmbG93IDwgcmlnaHRPdmVyZmxvdykpIHtcbiAgICAgIGNvcm5lciB8PSBDb3JuZXJCaXQuUklHSFQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSG9yaXpvbnRhbCBvZmZzZXQgb2YgbWVudSBvcmlnaW4gY29ybmVyIGZyb20gY29ycmVzcG9uZGluZyBhbmNob3IgY29ybmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SG9yaXpvbnRhbE9yaWdpbk9mZnNldF8oY29ybmVyKSB7XG4gICAgY29uc3Qge2FuY2hvcldpZHRofSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzUmlnaHRBbGlnbmVkID0gQm9vbGVhbihjb3JuZXIgJiBDb3JuZXJCaXQuUklHSFQpO1xuICAgIGNvbnN0IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5SSUdIVCk7XG4gICAgbGV0IHggPSAwO1xuICAgIGlmIChpc1JpZ2h0QWxpZ25lZCkge1xuICAgICAgY29uc3QgcmlnaHRPZmZzZXQgPSBhdm9pZEhvcml6b250YWxPdmVybGFwID8gYW5jaG9yV2lkdGggLSB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdCA6IHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodDtcbiAgICAgIHggPSByaWdodE9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVmdE9mZnNldCA9IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA6IHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuICAgICAgeCA9IGxlZnRPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgT3JpZ2luIGNvcm5lciBvZiB0aGUgbWVudS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBWZXJ0aWNhbCBvZmZzZXQgb2YgbWVudSBvcmlnaW4gY29ybmVyIGZyb20gY29ycmVzcG9uZGluZyBhbmNob3IgY29ybmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VmVydGljYWxPcmlnaW5PZmZzZXRfKGNvcm5lcikge1xuICAgIGNvbnN0IHt2aWV3cG9ydCwgdmlld3BvcnREaXN0YW5jZSwgYW5jaG9ySGVpZ2h0LCBtZW51SGVpZ2h0fSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzQm90dG9tQWxpZ25lZCA9IEJvb2xlYW4oY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSk7XG4gICAgY29uc3Qge01BUkdJTl9UT19FREdFfSA9IE1EQ01lbnVGb3VuZGF0aW9uLm51bWJlcnM7XG4gICAgY29uc3QgYXZvaWRWZXJ0aWNhbE92ZXJsYXAgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IGNhbk92ZXJsYXBWZXJ0aWNhbGx5ID0gIWF2b2lkVmVydGljYWxPdmVybGFwO1xuICAgIGxldCB5ID0gMDtcblxuICAgIGlmIChpc0JvdHRvbUFsaWduZWQpIHtcbiAgICAgIHkgPSBhdm9pZFZlcnRpY2FsT3ZlcmxhcCA/IGFuY2hvckhlaWdodCAtIHRoaXMuYW5jaG9yTWFyZ2luXy50b3AgOiAtdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbTtcbiAgICAgIC8vIGFkanVzdCBmb3Igd2hlbiBtZW51IGNhbiBvdmVybGFwIGFuY2hvciwgYnV0IHRvbyB0YWxsIHRvIGJlIGFsaWduZWQgdG8gYm90dG9tXG4gICAgICAvLyBhbmNob3IgY29ybmVyLiBCb3R0b20gbWFyZ2luIGlzIGlnbm9yZWQgaW4gc3VjaCBjYXNlcy5cbiAgICAgIGlmIChjYW5PdmVybGFwVmVydGljYWxseSAmJiBtZW51SGVpZ2h0ID4gdmlld3BvcnREaXN0YW5jZS50b3AgKyBhbmNob3JIZWlnaHQpIHtcbiAgICAgICAgeSA9IC0oTWF0aC5taW4obWVudUhlaWdodCwgdmlld3BvcnQuaGVpZ2h0IC0gTUFSR0lOX1RPX0VER0UpIC0gKHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBhdm9pZFZlcnRpY2FsT3ZlcmxhcCA/IChhbmNob3JIZWlnaHQgKyB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tKSA6IHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgICAvLyBhZGp1c3QgZm9yIHdoZW4gbWVudSBjYW4gb3ZlcmxhcCBhbmNob3IsIGJ1dCB0b28gdGFsbCB0byBiZSBhbGlnbmVkIHRvIHRvcFxuICAgICAgLy8gYW5jaG9yIGNvcm5lcnMuIFRvcCBtYXJnaW4gaXMgaWdub3JlZCBpbiB0aGF0IGNhc2UuXG4gICAgICBpZiAoY2FuT3ZlcmxhcFZlcnRpY2FsbHkgJiYgbWVudUhlaWdodCA+IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tICsgYW5jaG9ySGVpZ2h0KSB7XG4gICAgICAgIHkgPSAtKE1hdGgubWluKG1lbnVIZWlnaHQsIHZpZXdwb3J0LmhlaWdodCAtIE1BUkdJTl9UT19FREdFKSAtICh2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSArIGFuY2hvckhlaWdodCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWF4aW11bSBoZWlnaHQgb2YgdGhlIG1lbnUsIGJhc2VkIG9uIGF2YWlsYWJsZSBzcGFjZS4gMCBpbmRpY2F0ZXMgc2hvdWxkIG5vdCBiZSBzZXQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNZW51TWF4SGVpZ2h0Xyhjb3JuZXIpIHtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICBjb25zdCB7dmlld3BvcnREaXN0YW5jZX0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pO1xuXG4gICAgLy8gV2hlbiBtYXhpbXVtIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkLCBpdCBpcyBoYW5kbGVkIGZyb20gY3NzLlxuICAgIGlmICh0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKSB7XG4gICAgICBpZiAoaXNCb3R0b21BbGlnbmVkKSB7XG4gICAgICAgIG1heEhlaWdodCA9IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEhlaWdodCA9IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tIC0gdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4SGVpZ2h0O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGF1dG9Qb3NpdGlvbl8oKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0FuY2hvcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBtZWFzdXJlbWVudHMgZm9yIGF1dG9wb3NpdGlvbiBtZXRob2RzIHJldXNlLlxuICAgIHRoaXMubWVhc3VyZXNfID0gdGhpcy5nZXRBdXRvTGF5b3V0TWVhc3VyZW1lbnRzXygpO1xuXG4gICAgY29uc3QgY29ybmVyID0gdGhpcy5nZXRPcmlnaW5Db3JuZXJfKCk7XG4gICAgY29uc3QgbWF4TWVudUhlaWdodCA9IHRoaXMuZ2V0TWVudU1heEhlaWdodF8oY29ybmVyKTtcbiAgICBsZXQgdmVydGljYWxBbGlnbm1lbnQgPSAoY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSkgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIGxldCBob3Jpem9udGFsQWxpZ25tZW50ID0gKGNvcm5lciAmIENvcm5lckJpdC5SSUdIVCkgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIGNvbnN0IGhvcml6b250YWxPZmZzZXQgPSB0aGlzLmdldEhvcml6b250YWxPcmlnaW5PZmZzZXRfKGNvcm5lcik7XG4gICAgY29uc3QgdmVydGljYWxPZmZzZXQgPSB0aGlzLmdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgW2hvcml6b250YWxBbGlnbm1lbnRdOiBob3Jpem9udGFsT2Zmc2V0ID8gaG9yaXpvbnRhbE9mZnNldCArICdweCcgOiAnMCcsXG4gICAgICBbdmVydGljYWxBbGlnbm1lbnRdOiB2ZXJ0aWNhbE9mZnNldCA/IHZlcnRpY2FsT2Zmc2V0ICsgJ3B4JyA6ICcwJyxcbiAgICB9O1xuICAgIGNvbnN0IHthbmNob3JXaWR0aCwgbWVudUhlaWdodCwgbWVudVdpZHRofSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIC8vIENlbnRlciBhbGlnbiB3aGVuIGFuY2hvciB3aWR0aCBpcyBjb21wYXJhYmxlIG9yIGdyZWF0ZXIgdGhhbiBtZW51LCBvdGhlcndpc2Uga2VlcCBjb3JuZXIuXG4gICAgaWYgKGFuY2hvcldpZHRoIC8gbWVudVdpZHRoID4gbnVtYmVycy5BTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTykge1xuICAgICAgaG9yaXpvbnRhbEFsaWdubWVudCA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIC8vIEFkanVzdCB2ZXJ0aWNhbCBvcmlnaW4gd2hlbiBtZW51IGlzIHBvc2l0aW9uZWQgd2l0aCBzaWduaWZpY2FudCBvZmZzZXQgZnJvbSBhbmNob3IuIFRoaXMgaXMgZG9uZSBzbyB0aGF0XG4gICAgLy8gc2NhbGUgYW5pbWF0aW9uIGlzIFwiYW5jaG9yZWRcIiBvbiB0aGUgYW5jaG9yLlxuICAgIGlmICghKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pICYmXG4gICAgICAgIE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0IC8gbWVudUhlaWdodCkgPiBudW1iZXJzLk9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTykge1xuICAgICAgY29uc3QgdmVydGljYWxPZmZzZXRQZXJjZW50ID0gTWF0aC5hYnModmVydGljYWxPZmZzZXQgLyBtZW51SGVpZ2h0KSAqIDEwMDtcbiAgICAgIGNvbnN0IG9yaWdpblBlcmNlbnQgPSAoY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSkgPyAxMDAgLSB2ZXJ0aWNhbE9mZnNldFBlcmNlbnQgOiB2ZXJ0aWNhbE9mZnNldFBlcmNlbnQ7XG4gICAgICB2ZXJ0aWNhbEFsaWdubWVudCA9IE1hdGgucm91bmQob3JpZ2luUGVyY2VudCAqIDEwMCkgLyAxMDAgKyAnJSc7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2Zvcm1PcmlnaW4oYCR7aG9yaXpvbnRhbEFsaWdubWVudH0gJHt2ZXJ0aWNhbEFsaWdubWVudH1gKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1heEhlaWdodChtYXhNZW51SGVpZ2h0ID8gbWF4TWVudUhlaWdodCArICdweCcgOiAnJyk7XG5cbiAgICAvLyBDbGVhciBtZWFzdXJlcyBhZnRlciBwb3NpdGlvbmluZyBpcyBjb21wbGV0ZS5cbiAgICB0aGlzLm1lYXN1cmVzXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgbWVudS5cbiAgICogQHBhcmFtIHt7Zm9jdXNJbmRleDogP251bWJlcn09fSBvcHRpb25zXG4gICAqL1xuICBvcGVuKHtmb2N1c0luZGV4ID0gbnVsbH0gPSB7fSkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2F2ZUZvY3VzKCk7XG5cbiAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19PUEVOKTtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5kaW1lbnNpb25zXyA9IHRoaXMuYWRhcHRlcl8uZ2V0SW5uZXJEaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLmF1dG9Qb3NpdGlvbl8oKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIHRoaXMuZm9jdXNPbk9wZW5fKGZvY3VzSW5kZXgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckJvZHlDbGlja0hhbmRsZXIodGhpcy5kb2N1bWVudENsaWNrSGFuZGxlcl8pO1xuICAgICAgaWYgKCF0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19PUEVOKTtcbiAgICAgICAgfSwgbnVtYmVycy5UUkFOU0lUSU9OX09QRU5fRFVSQVRJT04pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZ0XG4gICAqL1xuICBjbG9zZShldnQgPSBudWxsKSB7XG4gICAgY29uc3QgdGFyZ2V0SXNEaXNhYmxlZCA9IGV2dCA/XG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0KGV2dC50YXJnZXQsIHN0cmluZ3MuQVJJQV9ESVNBQkxFRF9BVFRSKSA9PT0gJ3RydWUnIDpcbiAgICAgIGZhbHNlO1xuXG4gICAgaWYgKHRhcmdldElzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfKTtcblxuICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HX0NMT1NFRCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19DTE9TRUQpO1xuICAgICAgICB9LCBudW1iZXJzLlRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT04pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVzdG9yZUZvY3VzKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3Blbl87XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRTZWxlY3RlZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgaXRlbSB0byBzZXQgYXMgc2VsZWN0ZWQuXG4gICAqL1xuICBzZXRTZWxlY3RlZEluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnNlbGVjdGVkSW5kZXhfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJldlNlbGVjdGVkSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuICAgIGlmIChwcmV2U2VsZWN0ZWRJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJtQXR0ckZvck9wdGlvbkF0SW5kZXgocHJldlNlbGVjdGVkSW5kZXgsICdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJtQ2xhc3NGb3JPcHRpb25BdEluZGV4KHByZXZTZWxlY3RlZEluZGV4LCBjc3NDbGFzc2VzLlNFTEVDVEVEX0xJU1RfSVRFTSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mSXRlbXMoKSA/IGluZGV4IDogLTE7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleF8gPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfLCAnYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfLCBjc3NDbGFzc2VzLlNFTEVDVEVEX0xJU1RfSVRFTSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7TURDTWVudUZvdW5kYXRpb24sIEFuY2hvck1hcmdpbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG5sZXQgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBwcm9wZXJ0eSB0byB1c2Ugb24gdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqIEBwYXJhbSB7IVdpbmRvd30gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKGdsb2JhbE9iaiwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBjb25zdCBlbCA9IGdsb2JhbE9iai5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUgPSAoJ3RyYW5zZm9ybScgaW4gZWwuc3R5bGUgPyAndHJhbnNmb3JtJyA6ICd3ZWJraXRUcmFuc2Zvcm0nKTtcbiAgICBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID0gdHJhbnNmb3JtUHJvcGVydHlOYW1lO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG59XG5cbi8qKlxuICogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiB0aGUgbWluaW11bSBhbmQgdGhlIG1heGltdW0sIHJldHVybmluZyB0aGUgY2xhbXBlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlYXNpbmcgdmFsdWUgdG8gYXBwbHkgYXQgdGltZSB0LCBmb3IgYSBnaXZlbiBjdWJpYyBiZXppZXIgY3VydmUuXG4gKiBDb250cm9sIHBvaW50cyBQMCBhbmQgUDMgYXJlIGFzc3VtZWQgdG8gYmUgKDAsMCkgYW5kICgxLDEpLCByZXNwZWN0aXZlbHkuXG4gKiBQYXJhbWV0ZXJzIGFyZSBhcyBmb2xsb3dzOlxuICogLSB0aW1lOiBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBhbmltYXRpb24sIHNjYWxlZCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiAtIHgxOiBUaGUgeCB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAxLlxuICogLSB5MTogVGhlIHkgdmFsdWUgb2YgY29udHJvbCBwb2ludCBQMS5cbiAqIC0geDI6IFRoZSB4IHZhbHVlIG9mIGNvbnRyb2wgcG9pbnQgUDIuXG4gKiAtIHkyOiBUaGUgeSB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBiZXppZXJQcm9ncmVzcyh0aW1lLCB4MSwgeTEsIHgyLCB5Mikge1xuICByZXR1cm4gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8oc29sdmVQb3NpdGlvbkZyb21YVmFsdWVfKHRpbWUsIHgxLCB4MiksIHkxLCB5Mik7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBhIHNpbmdsZSBjb29yZGluYXRlIGF0IGEgcG9zaXRpb24gcG9pbnQgYmV0d2VlbiAwIGFuZCAxLlxuICogYzEgYW5kIGMyIGFyZSB0aGUgbWF0Y2hpbmcgY29vcmRpbmF0ZSBvbiBjb250cm9sIHBvaW50cyBQMSBhbmQgUDIsIHJlc3BlY3RpdmVseS5cbiAqIENvbnRyb2wgcG9pbnRzIFAwIGFuZCBQMyBhcmUgYXNzdW1lZCB0byBiZSAoMCwwKSBhbmQgKDEsMSksIHJlc3BlY3RpdmVseS5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9iZXppZXIuanMuXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHBhcmFtIHtudW1iZXJ9IGMxXG4gKiBAcGFyYW0ge251bWJlcn0gYzJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCwgYzEsIGMyKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBzdGFydCBhbmQgZW5kLlxuICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICAvLyBTdGVwIG9uZSAtIGZyb20gNCBwb2ludHMgdG8gM1xuICBsZXQgaWMwID0gdCAqIGMxO1xuICBsZXQgaWMxID0gYzEgKyB0ICogKGMyIC0gYzEpO1xuICBjb25zdCBpYzIgPSBjMiArIHQgKiAoMSAtIGMyKTtcblxuICAvLyBTdGVwIHR3byAtIGZyb20gMyBwb2ludHMgdG8gMlxuICBpYzAgKz0gdCAqIChpYzEgLSBpYzApO1xuICBpYzEgKz0gdCAqIChpYzIgLSBpYzEpO1xuXG4gIC8vIEZpbmFsIHN0ZXAgLSBsYXN0IHBvaW50XG4gIHJldHVybiBpYzAgKyB0ICogKGljMSAtIGljMCk7XG59XG5cbi8qKlxuICogUHJvamVjdCBhIHBvaW50IG9udG8gdGhlIEJlemllciBjdXJ2ZSwgZnJvbSBhIGdpdmVuIFguIENhbGN1bGF0ZXMgdGhlIHBvc2l0aW9uIHQgYWxvbmcgdGhlIGN1cnZlLlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2Jlemllci5qcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4VmFsXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzb2x2ZVBvc2l0aW9uRnJvbVhWYWx1ZV8oeFZhbCwgeDEsIHgyKSB7XG4gIGNvbnN0IEVQU0lMT04gPSAxZS02O1xuICBjb25zdCBNQVhfSVRFUkFUSU9OUyA9IDg7XG5cbiAgaWYgKHhWYWwgPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKHhWYWwgPj0gMSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gSW5pdGlhbCBlc3RpbWF0ZSBvZiB0IHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICBsZXQgdCA9IHhWYWw7XG5cbiAgLy8gVHJ5IGdyYWRpZW50IGRlc2NlbnQgdG8gc29sdmUgZm9yIHQuIElmIGl0IHdvcmtzLCBpdCBpcyB2ZXJ5IGZhc3QuXG4gIGxldCB0TWluID0gMDtcbiAgbGV0IHRNYXggPSAxO1xuICBsZXQgdmFsdWUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9JVEVSQVRJT05TOyBpKyspIHtcbiAgICB2YWx1ZSA9IGdldEJlemllckNvb3JkaW5hdGVfKHQsIHgxLCB4Mik7XG4gICAgY29uc3QgZGVyaXZhdGl2ZSA9IChnZXRCZXppZXJDb29yZGluYXRlXyh0ICsgRVBTSUxPTiwgeDEsIHgyKSAtIHZhbHVlKSAvIEVQU0lMT047XG4gICAgaWYgKE1hdGguYWJzKHZhbHVlIC0geFZhbCkgPCBFUFNJTE9OKSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlcml2YXRpdmUpIDwgRVBTSUxPTikge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZSA8IHhWYWwpIHtcbiAgICAgICAgdE1pbiA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0TWF4ID0gdDtcbiAgICAgIH1cbiAgICAgIHQgLT0gKHZhbHVlIC0geFZhbCkgLyBkZXJpdmF0aXZlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBncmFkaWVudCBkZXNjZW50IGdvdCBzdHVjayBpbiBhIGxvY2FsIG1pbmltdW0sIGUuZy4gYmVjYXVzZVxuICAvLyB0aGUgZGVyaXZhdGl2ZSB3YXMgY2xvc2UgdG8gMCwgdXNlIGEgRGljaG90b215IHJlZmluZW1lbnQgaW5zdGVhZC5cbiAgLy8gV2UgbGltaXQgdGhlIG51bWJlciBvZiBpbnRlcmF0aW9ucyB0byA4LlxuICBmb3IgKGxldCBpID0gMDsgTWF0aC5hYnModmFsdWUgLSB4VmFsKSA+IEVQU0lMT04gJiYgaSA8IE1BWF9JVEVSQVRJT05TOyBpKyspIHtcbiAgICBpZiAodmFsdWUgPCB4VmFsKSB7XG4gICAgICB0TWluID0gdDtcbiAgICAgIHQgPSAodCArIHRNYXgpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdE1heCA9IHQ7XG4gICAgICB0ID0gKHQgKyB0TWluKSAvIDI7XG4gICAgfVxuICAgIHZhbHVlID0gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCwgeDEsIHgyKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IHtnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUsIGNsYW1wLCBiZXppZXJQcm9ncmVzc307XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgXG4gICAgcmVmPVwicm9vdFwiIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1tZW51IG1kYy1zaW1wbGUtbWVudVwiIFxuICAgIHRhYmluZGV4PVwiLTFcIj5cbiAgICA8dWwgXG4gICAgICByZWY9XCJpdGVtc1wiIFxuICAgICAgY2xhc3M9XCJtZGMtc2ltcGxlLW1lbnVfX2l0ZW1zIG1kYy1saXN0XCIgXG4gICAgICByb2xlPVwibWVudVwiIFxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICA8c2xvdC8+XG4gICAgPC91bD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgTURDTWVudUZvdW5kYXRpb24gfSBmcm9tICdAbWF0ZXJpYWwvbWVudS9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lIH0gZnJvbSAnQG1hdGVyaWFsL21lbnUvdXRpbCdcbmltcG9ydCB7IGVtaXRDdXN0b21FdmVudCB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51JyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgb3BlbjogW0Jvb2xlYW4sIE9iamVjdF0sXG4gICAgJ3F1aWNrLW9wZW4nOiBCb29sZWFuLFxuICAgICdhbmNob3ItY29ybmVyJzogW1N0cmluZywgTnVtYmVyXSxcbiAgICAnYW5jaG9yLW1hcmdpbic6IE9iamVjdFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBpdGVtczogW11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbjogJ29uT3Blbl8nLFxuICAgIHF1aWNrT3Blbihudikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFF1aWNrT3BlbihudilcbiAgICB9LFxuICAgIGFuY2hvckNvcm5lcihudikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvckNvcm5lcihOdW1iZXIobnYpKVxuICAgIH0sXG4gICAgYW5jaG9yTWFyZ2luKG52KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QW5jaG9yTWFyZ2luKG52KVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCByZWZyZXNoSXRlbXMgPSAoKSA9PiB7XG4gICAgICB0aGlzLml0ZW1zID0gW10uc2xpY2UuY2FsbChcbiAgICAgICAgdGhpcy4kcmVmcy5pdGVtcy5xdWVyeVNlbGVjdG9yQWxsKCcubWRjLWxpc3QtaXRlbVtyb2xlXScpXG4gICAgICApXG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGUnKVxuICAgIH1cbiAgICB0aGlzLnNsb3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHJlZnJlc2hJdGVtcygpKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ01lbnVGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiBCb29sZWFuKHRoaXMuJHJlZnMuaXRlbXMpLFxuICAgICAgZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQ6ICh0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpID0+XG4gICAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSksXG4gICAgICBnZXRJbm5lckRpbWVuc2lvbnM6ICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiB0aGlzLiRyZWZzLml0ZW1zLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuJHJlZnMuaXRlbXMub2Zmc2V0SGVpZ2h0XG4gICAgICB9KSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZGMtbWVudS1hbmNob3InKSxcbiAgICAgIGdldEFuY2hvckRpbWVuc2lvbnM6ICgpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4gKHtcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgfSksXG4gICAgICBnZXROdW1iZXJPZkl0ZW1zOiAoKSA9PiB0aGlzLml0ZW1zLmxlbmd0aCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICByZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldDogdGFyZ2V0ID0+IHRoaXMuaXRlbXMuaW5kZXhPZih0YXJnZXQpLFxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6IGV2dERhdGEgPT4ge1xuICAgICAgICBjb25zdCBldnQgPSB7XG4gICAgICAgICAgaW5kZXg6IGV2dERhdGEuaW5kZXgsXG4gICAgICAgICAgaXRlbTogdGhpcy5pdGVtc1tldnREYXRhLmluZGV4XVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdzZWxlY3QnLCBldnQpXG4gICAgICAgIGVtaXRDdXN0b21FdmVudCh0aGlzLiRlbCwgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCwgZXZ0KVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2FuY2VsJylcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KHRoaXMuJGVsLCBNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLkNBTkNFTF9FVkVOVCwge30pXG4gICAgICB9LFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICB9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0ZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNGb2N1cy5mb2N1cygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJHJlZnMucm9vdCxcbiAgICAgIGZvY3VzOiAoKSA9PiB0aGlzLiRyZWZzLnJvb3QuZm9jdXMoKSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IHRoaXMuaXRlbXMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSxcbiAgICAgIGZvY3VzSXRlbUF0SW5kZXg6IGluZGV4ID0+IHRoaXMuaXRlbXNbaW5kZXhdLmZvY3VzKCksXG4gICAgICBpc1J0bDogKCkgPT5cbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRyZWZzLnJvb3QpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PVxuICAgICAgICAncnRsJyxcbiAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogb3JpZ2luID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KFxuICAgICAgICAgIHRoaXMuc3R5bGVzLFxuICAgICAgICAgIGAke2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZSh3aW5kb3cpfS1vcmlnaW5gLFxuICAgICAgICAgIG9yaWdpblxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgc2V0UG9zaXRpb246IHBvc2l0aW9uID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnbGVmdCcsIHBvc2l0aW9uLmxlZnQpXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ3JpZ2h0JywgcG9zaXRpb24ucmlnaHQpXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ3RvcCcsIHBvc2l0aW9uLnRvcClcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnYm90dG9tJywgcG9zaXRpb24uYm90dG9tKVxuICAgICAgfSxcbiAgICAgIHNldE1heEhlaWdodDogaGVpZ2h0ID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnbWF4LWhlaWdodCcsIGhlaWdodClcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgcm1BdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICAgICAgfSxcbiAgICAgIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZWZyZXNoSXRlbXMoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICBpZiAodGhpcy5hbmNob3JDb3JuZXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvckNvcm5lcihOdW1iZXIodGhpcy5hbmNob3JDb3JuZXIpKVxuICAgIH1cbiAgICBpZiAodGhpcy5hbmNob3JNYXJnaW4gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvck1hcmdpbih0aGlzLmFuY2hvck1hcmdpbilcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IG51bGxcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIG9uT3Blbl8odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ub3Blbih0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiB2b2lkIDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdyhvcHRpb25zKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbihvcHRpb25zKVxuICAgIH0sXG4gICAgaGlkZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfSxcbiAgICBpc09wZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uID8gdGhpcy5mb3VuZGF0aW9uLmlzT3BlbigpIDogZmFsc2VcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bGkgXG4gICAgOnRhYmluZGV4PVwiZGlzYWJsZWQ/Jy0xJzonMCdcIiBcbiAgICA6YXJpYS1kaXNhYmxlZD1cImRpc2FibGVkXCIgXG4gICAgY2xhc3M9XCJtZGMtbWVudS1pdGVtIG1kYy1saXN0LWl0ZW1cIlxuICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gID5cbiAgICA8c2xvdC8+XG4gIDwvbGk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtaXRlbScsXG4gIHByb3BzOiB7XG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBcbiAgICByb2xlPVwic2VwYXJhdG9yXCIgXG4gICAgY2xhc3M9XCJtZGMtbWVudS1kaXZpZGVyIG1kYy1saXN0LWRpdmlkZXJcIi8+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtZGl2aWRlcidcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLW1lbnUtYW5jaG9yXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudS1hbmNob3InXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY01lbnUgZnJvbSAnLi9tZGMtbWVudS52dWUnXG5pbXBvcnQgbWRjTWVudUl0ZW0gZnJvbSAnLi9tZGMtbWVudS1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNNZW51RGl2aWRlciBmcm9tICcuL21kYy1tZW51LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY01lbnVBbmNob3IgZnJvbSAnLi9tZGMtbWVudS1hbmNob3IudnVlJ1xuXG5leHBvcnQgeyBtZGNNZW51LCBtZGNNZW51SXRlbSwgbWRjTWVudURpdmlkZXIsIG1kY01lbnVBbmNob3IgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTWVudSxcbiAgbWRjTWVudUl0ZW0sXG4gIG1kY01lbnVEaXZpZGVyLFxuICBtZGNNZW51QW5jaG9yXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJhZGlvLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENSYWRpb0FkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSAqL1xuICBnZXROYXRpdmVDb250cm9sKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmFkaW9BZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6ICcubWRjLXJhZGlvX19uYXRpdmUtY29udHJvbCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtcmFkaW8nLFxuICBESVNBQkxFRDogJ21kYy1yYWRpby0tZGlzYWJsZWQnLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcbmltcG9ydCBNRENSYWRpb0FkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENSYWRpb0FkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSYWRpb0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENSYWRpb0FkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1JhZGlvQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiAvKiAhTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlICovIHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzQ2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBjaGVja2VkICovXG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGNvbnN0IHtESVNBQkxFRH0gPSBNRENSYWRpb0ZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5hdGl2ZUNvbnRyb2xfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUNvbnRyb2woKSB8fCB7XG4gICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmFkaW9Gb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmNsYXNzPVwiZm9ybUZpZWxkQ2xhc3Nlc1wiXG4gICAgY2xhc3M9XCJtZGMtcmFkaW8td3JhcHBlclwiPlxuICAgIDxkaXZcbiAgICAgIHJlZj1cInJvb3RcIlxuICAgICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtcmFkaW9cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICByZWY9XCJjb250cm9sXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICBjbGFzcz1cIm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2xcIlxuICAgICAgICBAY2hhbmdlPVwic3luY1wiPlxuXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwibWRjLXJhZGlvX19iYWNrZ3JvdW5kXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtcmFkaW9fX291dGVyLWNpcmNsZVwiLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kYy1yYWRpb19faW5uZXItY2lyY2xlXCIvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGxhYmVsXG4gICAgICByZWY9XCJsYWJlbFwiXG4gICAgICA6Zm9yPVwidm1hX3VpZF9cIj48c2xvdD57eyBsYWJlbCB9fTwvc2xvdD48L2xhYmVsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDUmFkaW9Gb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9yYWRpby9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Zvcm0tZmllbGQvZm91bmRhdGlvbidcbmltcG9ydCB7IERpc3BhdGNoRm9jdXNNaXhpbiwgVk1BVW5pcXVlSWRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuaW1wb3J0IHsgYXBwbHlQYXNzaXZlIH0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXJhZGlvJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAncGlja2VkJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIHBpY2tlZDogU3RyaW5nLFxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBmb3JtRmllbGRDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtZm9ybS1maWVsZCc6IHRoaXMubGFiZWwsXG4gICAgICAgICdtZGMtZm9ybS1maWVsZC0tYWxpZ24tZW5kJzogdGhpcy5sYWJlbCAmJiB0aGlzLmFsaWduRW5kXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodmFsdWUpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIC8vIGFkZCBmb3VuZGF0aW9uXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1JhZGlvRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiB0aGlzLiRyZWZzLmNvbnRyb2xcbiAgICB9KVxuXG4gICAgLy8gYWRkIHJpcHBsZVxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm9ybUZpZWxkID0gbmV3IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24oe1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuYWN0aXZhdGUoKVxuICAgICAgfSxcbiAgICAgIGRlYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5kZWFjdGl2YXRlKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICAgIHRoaXMuZm9ybUZpZWxkLmluaXQoKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlIDogdGhpcy5sYWJlbClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZChcbiAgICAgIHRoaXMuY2hlY2tlZCB8fCB0aGlzLnBpY2tlZCA9PSB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKVxuICAgIClcblxuICAgIC8vIHJlZnJlc2ggbW9kZWxcbiAgICB0aGlzLmNoZWNrZWQgJiYgdGhpcy5zeW5jKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvcm1GaWVsZC5kZXN0cm95KClcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBpc0NoZWNrZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmlzQ2hlY2tlZCgpXG4gICAgfSxcbiAgICBzeW5jKCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1JhZGlvIGZyb20gJy4vbWRjLXJhZGlvLnZ1ZSdcblxuZXhwb3J0IHsgbWRjUmFkaW8gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjUmFkaW9cbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEJPWDogJ21kYy1zZWxlY3QtLWJveCcsXG4gIERJU0FCTEVEOiAnbWRjLXNlbGVjdC0tZGlzYWJsZWQnLFxuICBST09UOiAnbWRjLXNlbGVjdCcsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgQ0hBTkdFX0VWRU5UOiAnTURDU2VsZWN0OmNoYW5nZScsXG4gIExJTkVfUklQUExFX1NFTEVDVE9SOiAnLm1kYy1saW5lLXJpcHBsZScsXG4gIExBQkVMX1NFTEVDVE9SOiAnLm1kYy1mbG9hdGluZy1sYWJlbCcsXG4gIE5BVElWRV9DT05UUk9MX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX25hdGl2ZS1jb250cm9sJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENTZWxlY3RGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBmbG9hdExhYmVsOiAoLyogdmFsdWU6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgICAgYWN0aXZhdGVCb3R0b21MaW5lOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVCb3R0b21MaW5lOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0U2VsZWN0ZWRJbmRleDogKCkgPT4gLyogbnVtYmVyICovIC0xLFxuICAgICAgc2V0U2VsZWN0ZWRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgc2V0RGlzYWJsZWQ6ICgvKiBkaXNhYmxlZDogYm9vbGVhbiAqLykgPT4ge30sXG4gICAgICBnZXRWYWx1ZTogKCkgPT4gLyogc3RyaW5nICovICcnLFxuICAgICAgc2V0VmFsdWU6ICgvKiB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU2VsZWN0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVGb2N1c18oZXZ0KTtcbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlQmx1cl8oZXZ0KTtcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVTZWxlY3RfKGV2dCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NoYW5nZScsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjaGFuZ2UnLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXJfKTtcbiAgfVxuXG4gIHNldFNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNlbGVjdGVkSW5kZXgoaW5kZXgpO1xuICAgIHRoaXMuZmxvYXRMYWJlbFdpdGhWYWx1ZV8oKTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KHRoaXMuYWRhcHRlcl8uZ2V0U2VsZWN0ZWRJbmRleCgpKTtcbiAgfVxuXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ1NlbGVjdEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLnNldERpc2FibGVkKGRpc2FibGVkKTtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICBmbG9hdExhYmVsV2l0aFZhbHVlXygpIHtcbiAgICBjb25zdCBvcHRpb25IYXNWYWx1ZSA9IHRoaXMuYWRhcHRlcl8uZ2V0VmFsdWUoKS5sZW5ndGggPiAwO1xuICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbChvcHRpb25IYXNWYWx1ZSk7XG4gIH1cblxuICBoYW5kbGVGb2N1c18oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVCb3R0b21MaW5lKCk7XG4gIH1cblxuICBoYW5kbGVCbHVyXygpIHtcbiAgICB0aGlzLmZsb2F0TGFiZWxXaXRoVmFsdWVfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlQm90dG9tTGluZSgpO1xuICB9XG5cbiAgaGFuZGxlU2VsZWN0XygpIHtcbiAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgodGhpcy5hZGFwdGVyXy5nZXRTZWxlY3RlZEluZGV4KCkpO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRleHRGaWVsZCBMaW5lIFJpcHBsZS5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBsaW5lIHJpcHBsZSBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDTGluZVJpcHBsZUFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3R5bGUgcHJvcGVydHkgd2l0aCBwcm9wZXJ0eU5hbWUgdG8gdmFsdWUgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFN0eWxlKHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbGluZSByaXBwbGUgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENMaW5lUmlwcGxlQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIExJTkVfUklQUExFX0FDVElWRTogJ21kYy1saW5lLXJpcHBsZS0tYWN0aXZlJyxcbiAgTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HOiAnbWRjLWxpbmUtcmlwcGxlLS1kZWFjdGl2YXRpbmcnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENMaW5lUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDTGluZVJpcHBsZUFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0xpbmVSaXBwbGVBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDTGluZVJpcHBsZUFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRTdHlsZTogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENMaW5lUmlwcGxlQWRhcHRlcj19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSAvKiogQHR5cGUgeyFNRENMaW5lUmlwcGxlQWRhcHRlcn0gKi8gKHt9KSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTGluZVJpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJFdmVudEhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlXG4gICAqL1xuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfQUNUSVZFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjZW50ZXIgb2YgdGhlIHJpcHBsZSBhbmltYXRpb24gdG8gdGhlIGdpdmVuIFggY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHhDb29yZGluYXRlXG4gICAqL1xuICBzZXRSaXBwbGVDZW50ZXIoeENvb3JkaW5hdGUpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgYCR7eENvb3JkaW5hdGV9cHggY2VudGVyYCk7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlXG4gICAqL1xuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSB0cmFuc2l0aW9uIGVuZCBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCkge1xuICAgIC8vIFdhaXQgZm9yIHRoZSBsaW5lIHJpcHBsZSB0byBiZSBlaXRoZXIgdHJhbnNwYXJlbnQgb3Igb3BhcXVlXG4gICAgLy8gYmVmb3JlIGVtaXR0aW5nIHRoZSBhbmltYXRpb24gZW5kIGV2ZW50XG4gICAgY29uc3QgaXNEZWFjdGl2YXRpbmcgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcblxuICAgIGlmIChldnQucHJvcGVydHlOYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgIGlmIChpc0RlYWN0aXZhdGluZykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfQUNUSVZFKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBGbG9hdGluZyBMYWJlbC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBmbG9hdGluZyBsYWJlbCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBMQUJFTF9GTE9BVF9BQk9WRTogJ21kYy1mbG9hdGluZy1sYWJlbC0tZmxvYXQtYWJvdmUnLFxuICBMQUJFTF9TSEFLRTogJ21kYy1mbG9hdGluZy1sYWJlbC0tc2hha2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENGbG9hdGluZ0xhYmVsQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENGbG9hdGluZ0xhYmVsQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENGbG9hdGluZ0xhYmVsQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgZ2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZVNoYWtlQW5pbWF0aW9uRW5kXygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdhbmltYXRpb25lbmQnLCB0aGlzLnNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2FuaW1hdGlvbmVuZCcsIHRoaXMuc2hha2VBbmltYXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldFdpZHRoKCk7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBsYWJlbCB0byBwcm9kdWNlIHRoZSBsYWJlbCBzaGFrZSBmb3IgZXJyb3JzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFNoYWtlIGFkZHMgc2hha2UgY2xhc3MgaWYgdHJ1ZSxcbiAgICogb3RoZXJ3aXNlIHJlbW92ZXMgc2hha2UgY2xhc3MuXG4gICAqL1xuICBzaGFrZShzaG91bGRTaGFrZSkge1xuICAgIGNvbnN0IHtMQUJFTF9TSEFLRX0gPSBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChzaG91bGRTaGFrZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhMQUJFTF9TSEFLRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGxhYmVsIHRvIGZsb2F0IG9yIGRvY2suXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmxvYXQgYWRkcyBmbG9hdCBjbGFzcyBpZiB0cnVlLCBvdGhlcndpc2UgcmVtb3ZlXG4gICAqIGZsb2F0IGFuZCBzaGFrZSBjbGFzcyB0byBkb2NrIGxhYmVsLlxuICAgKi9cbiAgZmxvYXQoc2hvdWxkRmxvYXQpIHtcbiAgICBjb25zdCB7TEFCRUxfRkxPQVRfQUJPVkUsIExBQkVMX1NIQUtFfSA9IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHNob3VsZEZsb2F0KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKExBQkVMX0ZMT0FUX0FCT1ZFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9GTE9BVF9BQk9WRSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX1NIQUtFKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudCBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKi9cbiAgaGFuZGxlU2hha2VBbmltYXRpb25FbmRfKCkge1xuICAgIGNvbnN0IHtMQUJFTF9TSEFLRX0gPSBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmlkPVwiaWRcIlxuICAgIDpjbGFzcz1cInJvb3RDbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIGNsYXNzPVwibWRjLXNlbGVjdFwiPlxuICAgIDxzZWxlY3RcbiAgICAgIHJlZj1cIm5hdGl2ZV9jb250cm9sXCJcbiAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICBjbGFzcz1cIm1kYy1zZWxlY3RfX25hdGl2ZS1jb250cm9sXCJcbiAgICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cbiAgICAgIDxvcHRpb25cbiAgICAgICAgdi1pZj1cIiEhbGFiZWxcIlxuICAgICAgICBjbGFzcz1cIm1kYy1vcHRpb25cIlxuICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgIGRpc2FibGVkXG4gICAgICAgIHNlbGVjdGVkLz5cbiAgICAgIDxzbG90Lz5cbiAgICA8L3NlbGVjdD5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJsYWJlbFwiXG4gICAgICA6Y2xhc3M9XCJsYWJlbENsYXNzZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtZmxvYXRpbmctbGFiZWxcIj57eyBsYWJlbCB9fTwvZGl2PlxuICAgIDxkaXZcbiAgICAgIHJlZj1cImxpbmVcIlxuICAgICAgOmNsYXNzPVwibGluZUNsYXNzZXNcIlxuICAgICAgOnN0eWxlPVwibGluZVN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1saW5lLXJpcHBsZVwiLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1NlbGVjdEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdC9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lLXJpcHBsZS9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mbG9hdGluZy1sYWJlbC9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXNlbGVjdCcsXG4gIGluaGVyaXRBdHRyczogZmFsc2UsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3ZhbHVlJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgYm94OiBCb29sZWFuLFxuICAgIGlkOiB7IHR5cGU6IFN0cmluZyB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBsYWJlbENsYXNzZXM6IHt9LFxuICAgICAgbGluZUNsYXNzZXM6IHt9LFxuICAgICAgbGluZVN0eWxlczoge30sXG4gICAgICBjbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICByb290Q2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtc2VsZWN0LS1ib3gnOiB0aGlzLmJveCxcbiAgICAgICAgLi4udGhpcy5jbGFzc2VzXG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzLiRsaXN0ZW5lcnMsXG4gICAgICAgIGNoYW5nZTogZXZlbnQgPT4gdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh2YWx1ZSlcbiAgICB9LFxuICAgIHZhbHVlOiAncmVmcmVzaEluZGV4J1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uID0gbmV3IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMubGFiZWxDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgZ2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMubGFiZWwub2Zmc2V0V2lkdGgsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmxhYmVsRm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24gPSBuZXcgTURDTGluZVJpcHBsZUZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmxpbmVDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxpbmVDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGluZS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMubGluZVN0eWxlcywgbmFtZSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGluZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5saW5lLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24uaW5pdCgpXG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDU2VsZWN0Rm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBmbG9hdExhYmVsOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLmZsb2F0KHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGFjdGl2YXRlQm90dG9tTGluZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmFjdGl2YXRlKClcbiAgICAgIH0sXG4gICAgICBkZWFjdGl2YXRlQm90dG9tTGluZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmRlYWN0aXZhdGUoKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcbiAgICAgIGdldFNlbGVjdGVkSW5kZXg6ICgpID0+IHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wuc2VsZWN0ZWRJbmRleCxcbiAgICAgIHNldFNlbGVjdGVkSW5kZXg6IGluZGV4ID0+XG4gICAgICAgICh0aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLnNlbGVjdGVkSW5kZXggPSBpbmRleCksXG4gICAgICBzZXREaXNhYmxlZDogZGlzYWJsZWQgPT4gKHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wuZGlzYWJsZWQgPSBkaXNhYmxlZCksXG4gICAgICBnZXRWYWx1ZTogKCkgPT4gdGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbC52YWx1ZSxcbiAgICAgIHNldFZhbHVlOiB2YWx1ZSA9PiAodGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbC52YWx1ZSA9IHZhbHVlKVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcblxuICAgIC8vIGluaXRpYWwgc3luYyB3aXRoIERPTVxuICAgIHRoaXMucmVmcmVzaEluZGV4KClcbiAgICB0aGlzLnNsb3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHRoaXMucmVmcmVzaEluZGV4KCkpXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSlcblxuICAgIGlmICh0aGlzLmJveCkge1xuICAgICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuc2xvdE9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgIGxldCBmb3VuZGF0aW9uID0gdGhpcy5mb3VuZGF0aW9uXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICAgIGZvdW5kYXRpb24uZGVzdHJveSgpXG5cbiAgICBsZXQgbGFiZWxGb3VuZGF0aW9uID0gdGhpcy5sYWJlbEZvdW5kYXRpb25cbiAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiA9IG51bGxcbiAgICBsYWJlbEZvdW5kYXRpb24uZGVzdHJveSgpXG5cbiAgICBsZXQgbGluZVJpcHBsZUZvdW5kYXRpb24gPSB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uXG4gICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbiA9IG51bGxcbiAgICBsaW5lUmlwcGxlRm91bmRhdGlvbi5kZXN0cm95KClcblxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcmVmcmVzaEluZGV4KCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IFsuLi50aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbicpXVxuXG4gICAgICBjb25zdCBpZHggPSBvcHRpb25zLmZpbmRJbmRleCgoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB2YWx1ZVxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wuc2VsZWN0ZWRJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTZWxlY3RlZEluZGV4KGlkeClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU2VsZWN0IGZyb20gJy4vbWRjLXNlbGVjdC52dWUnXG5cbmV4cG9ydCB7IG1kY1NlbGVjdCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTZWxlY3Rcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXNsaWRlci0tYWN0aXZlJyxcbiAgRElTQUJMRUQ6ICdtZGMtc2xpZGVyLS1kaXNhYmxlZCcsXG4gIERJU0NSRVRFOiAnbWRjLXNsaWRlci0tZGlzY3JldGUnLFxuICBGT0NVUzogJ21kYy1zbGlkZXItLWZvY3VzJyxcbiAgSU5fVFJBTlNJVDogJ21kYy1zbGlkZXItLWluLXRyYW5zaXQnLFxuICBJU19ESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcbiAgSEFTX1RSQUNLX01BUktFUjogJ21kYy1zbGlkZXItLWRpc3BsYXktbWFya2VycycsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFRSQUNLX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RyYWNrJyxcbiAgVFJBQ0tfTUFSS0VSX0NPTlRBSU5FUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyJyxcbiAgTEFTVF9UUkFDS19NQVJLRVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyOmxhc3QtY2hpbGQnLFxuICBUSFVNQl9DT05UQUlORVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdGh1bWItY29udGFpbmVyJyxcbiAgUElOX1ZBTFVFX01BUktFUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX19waW4tdmFsdWUtbWFya2VyJyxcbiAgQVJJQV9WQUxVRU1JTjogJ2FyaWEtdmFsdWVtaW4nLFxuICBBUklBX1ZBTFVFTUFYOiAnYXJpYS12YWx1ZW1heCcsXG4gIEFSSUFfVkFMVUVOT1c6ICdhcmlhLXZhbHVlbm93JyxcbiAgQVJJQV9ESVNBQkxFRDogJ2FyaWEtZGlzYWJsZWQnLFxuICBTVEVQX0RBVEFfQVRUUjogJ2RhdGEtc3RlcCcsXG4gIENIQU5HRV9FVkVOVDogJ01EQ1NsaWRlcjpjaGFuZ2UnLFxuICBJTlBVVF9FVkVOVDogJ01EQ1NsaWRlcjppbnB1dCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIFBBR0VfRkFDVE9SOiA0LFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgU2xpZGVyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFNsaWRlciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDU2xpZGVyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY2xhc3NOYW1lIGV4aXN0cyBmb3IgdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgaWYgYXR0cmlidXRlIG5hbWUgZXhpc3RzIG9uIHRoZSBzbGlkZXIgRWxlbWVudCxcbiAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYXR0cmlidXRlIG5hbWUgb24gc2xpZGVyIEVsZW1lbnQgdG8gdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlIG5hbWUgZnJvbSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IGZvciB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHJldHVybiB7P0NsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlQm91bmRpbmdSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFiIGluZGV4IG9mIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUYWJJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSB0aHVtYiBjb250YWluZXIgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIGJvZHkgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgYm9keSBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgd2luZG93IHJlc2l6ZSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSB3aW5kb3cgcmVzaXplIGV2ZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6aW5wdXQgZnJvbSB0aGUgcm9vdFxuICAgKi9cbiAgbm90aWZ5SW5wdXQoKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6Y2hhbmdlIGZyb20gdGhlIHJvb3RcbiAgICovXG4gIG5vdGlmeUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdHJhY2sgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRUcmFja1N0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5uZXIgdGV4dCBvZiB0aGUgcGluIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgc2V0TWFya2VyVmFsdWUodmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIHBhc3NlZCBudW1iZXIgb2YgdHJhY2sgbWFya2VycyB0byB0aGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtTWFya2Vyc1xuICAgKi9cbiAgYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHRyYWNrIG1hcmtlcnMgZnJvbXQgaGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKi9cbiAgcmVtb3ZlVHJhY2tNYXJrZXJzKCkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBsYXN0IHRyYWNrIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBpcyBSVEwsIG90aGVyd2lzZSBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSVEwoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTbGlkZXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICp5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1NsaWRlckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcblxuaW1wb3J0IHtnZXRDb3JyZWN0RXZlbnROYW1lLCBnZXRDb3JyZWN0UHJvcGVydHlOYW1lfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4JztcbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IEtFWV9JRFMgPSB7XG4gIEFSUk9XX0xFRlQ6ICdBcnJvd0xlZnQnLFxuICBBUlJPV19SSUdIVDogJ0Fycm93UmlnaHQnLFxuICBBUlJPV19VUDogJ0Fycm93VXAnLFxuICBBUlJPV19ET1dOOiAnQXJyb3dEb3duJyxcbiAgSE9NRTogJ0hvbWUnLFxuICBFTkQ6ICdFbmQnLFxuICBQQUdFX1VQOiAnUGFnZVVwJyxcbiAgUEFHRV9ET1dOOiAnUGFnZURvd24nLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBNT1ZFX0VWRU5UX01BUCA9IHtcbiAgJ21vdXNlZG93bic6ICdtb3VzZW1vdmUnLFxuICAndG91Y2hzdGFydCc6ICd0b3VjaG1vdmUnLFxuICAncG9pbnRlcmRvd24nOiAncG9pbnRlcm1vdmUnLFxufTtcblxuY29uc3QgRE9XTl9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdwb2ludGVyZG93bicsICd0b3VjaHN0YXJ0J107XG5jb25zdCBVUF9FVkVOVFMgPSBbJ21vdXNldXAnLCAncG9pbnRlcnVwJywgJ3RvdWNoZW5kJ107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1NsaWRlckFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENTbGlkZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2xpZGVyQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2xpZGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmd8bnVsbCAqLyBudWxsLFxuICAgICAgc2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiAvKiBDbGllbnRSZWN0ICovICh7XG4gICAgICAgIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICAgIH0pLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFRyYWNrU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiAoLyogdmFsdWU6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBhcHBlbmRUcmFja01hcmtlcnM6ICgvKiBudW1NYXJrZXJzOiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlVHJhY2tNYXJrZXJzOiAoKSA9PiB7fSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaXNSVEw6ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNRENTbGlkZXJGb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7P01EQ1NsaWRlckFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NsaWRlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICAvKiogQHByaXZhdGUgez9DbGllbnRSZWN0fSAqL1xuICAgIHRoaXMucmVjdF8gPSBudWxsO1xuICAgIC8vIFdlIHNldCB0aGlzIHRvIE5hTiBzaW5jZSB3ZSB3YW50IGl0IHRvIGJlIGEgbnVtYmVyLCBidXQgd2UgY2FuJ3QgdXNlICcwJyBvciAnLTEnXG4gICAgLy8gYmVjYXVzZSB0aG9zZSBjb3VsZCBiZSB2YWxpZCB0YWJpbmRpY2VzIHNldCBieSB0aGUgY2xpZW50IGNvZGUuXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IE5hTjtcbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmluVHJhbnNpdF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gZmFsc2U7XG4gICAgdGhpcy5oYXNUcmFja01hcmtlcl8gPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5taW5fID0gMDtcbiAgICB0aGlzLm1heF8gPSAxMDA7XG4gICAgdGhpcy5zdGVwXyA9IDA7XG4gICAgdGhpcy52YWx1ZV8gPSAwO1xuICAgIHRoaXMuZGlzYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVVJRnJhbWVfID0gMDtcbiAgICB0aGlzLnRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRG93bl8oZXZ0KTtcbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlS2V5ZG93bl8oZXZ0KTtcbiAgICB0aGlzLmZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUZvY3VzXygpO1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVCbHVyXygpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLklTX0RJU0NSRVRFKTtcbiAgICB0aGlzLmhhc1RyYWNrTWFya2VyXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IQVNfVFJBQ0tfTUFSS0VSKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgICAvLyBBdCBsYXN0IHN0ZXAsIHByb3ZpZGUgYSByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWUgdG8gZGlzY3JldGUgc2xpZGVyXG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5nZXRTdGVwKCkgPT0gMCkge1xuICAgICAgdGhpcy5zdGVwXyA9IDE7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIHNldHVwVHJhY2tNYXJrZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5oYXNUcmFja01hcmtlcl8mJiB0aGlzLmdldFN0ZXAoKSAhPSAwKSB7XG4gICAgICBjb25zdCBtaW4gPSB0aGlzLmdldE1pbigpO1xuICAgICAgY29uc3QgbWF4ID0gdGhpcy5nZXRNYXgoKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldFN0ZXAoKTtcbiAgICAgIGxldCBudW1NYXJrZXJzID0gKG1heCAtIG1pbikgLyBzdGVwO1xuXG4gICAgICAvLyBJbiBjYXNlIGRpc3RhbmNlIGJldHdlZW4gbWF4ICYgbWluIGlzIGluZGl2aXNpYmxlIHRvIHN0ZXAsXG4gICAgICAvLyB3ZSBwbGFjZSB0aGUgc2Vjb25kYXJ5IHRvIGxhc3QgbWFya2VyIHByb3BvcnRpb25hbGx5IGF0IHdoZXJlIHRodW1iXG4gICAgICAvLyBjb3VsZCByZWFjaCBhbmQgcGxhY2UgdGhlIGxhc3QgbWFya2VyIGF0IG1heCB2YWx1ZVxuICAgICAgY29uc3QgaW5kaXZpc2libGUgPSBNYXRoLmNlaWwobnVtTWFya2VycykgIT09IG51bU1hcmtlcnM7XG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgbnVtTWFya2VycyA9IE1hdGguY2VpbChudW1NYXJrZXJzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVUcmFja01hcmtlcnMoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpO1xuXG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgY29uc3QgbGFzdFN0ZXBSYXRpbyA9IChtYXggLSBudW1NYXJrZXJzICogc3RlcCkgLyBzdGVwICsgMTtcbiAgICAgICAgY29uc3QgZmxleCA9IGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93LCAnZmxleCcpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5KGZsZXgsIFN0cmluZyhsYXN0U3RlcFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMucmVjdF8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLnVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCBmYWxzZSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRNYXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4XztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gbWF4ICovXG4gIHNldE1heChtYXgpIHtcbiAgICBpZiAobWF4IDwgdGhpcy5taW5fKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbWF4IHRvIGJlIGxlc3MgdGhhbiB0aGUgc2xpZGVyXFwncyBtaW5pbXVtIHZhbHVlJyk7XG4gICAgfVxuICAgIHRoaXMubWF4XyA9IG1heDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU1BWCwgU3RyaW5nKHRoaXMubWF4XykpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TWluKCkge1xuICAgIHJldHVybiB0aGlzLm1pbl87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IG1pbiAqL1xuICBzZXRNaW4obWluKSB7XG4gICAgaWYgKG1pbiA+IHRoaXMubWF4Xykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IG1pbiB0byBiZSBncmVhdGVyIHRoYW4gdGhlIHNsaWRlclxcJ3MgbWF4aW11bSB2YWx1ZScpO1xuICAgIH1cbiAgICB0aGlzLm1pbl8gPSBtaW47XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVNSU4sIFN0cmluZyh0aGlzLm1pbl8pKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgKi9cbiAgc2V0U3RlcChzdGVwKSB7XG4gICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0ZXAgY2Fubm90IGJlIHNldCB0byBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXyAmJiAodHlwZW9mKHN0ZXApICE9PSAnbnVtYmVyJyB8fCBzdGVwIDwgMSkpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgIH1cbiAgICB0aGlzLnN0ZXBfID0gc3RlcDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGRpc2FibGVkO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuRElTQUJMRUQsIHRoaXMuZGlzYWJsZWRfKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkluZGV4KCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX0RJU0FCTEVEKTtcbiAgICAgIGlmICghaXNOYU4odGhpcy5zYXZlZFRhYkluZGV4XykpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgU3RyaW5nKHRoaXMuc2F2ZWRUYWJJbmRleF8pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGludGVyYWN0aW5nIHdpdGggdGhlIHNsaWRlclxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVEb3duXyhldnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZlbnRGb2N1c1N0YXRlXyA9IHRydWU7XG4gICAgdGhpcy5zZXRJblRyYW5zaXRfKCF0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfKTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBY3RpdmVfKHRydWUpO1xuXG4gICAgY29uc3QgbW92ZUhhbmRsZXIgPSAoZXZ0KSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVfKGV2dCk7XG4gICAgfTtcblxuICAgIC8vIE5vdGU6IHVwSGFuZGxlciBpcyBbZGVdcmVnaXN0ZXJlZCBvbiBBTEwgcG90ZW50aWFsIHBvaW50ZXItcmVsYXRlZCByZWxlYXNlIGV2ZW50IHR5cGVzLCBzaW5jZSBzb21lIGJyb3dzZXJzXG4gICAgLy8gZG8gbm90IGFsd2F5cyBmaXJlIHRoZXNlIGNvbnNpc3RlbnRseSBpbiBwYWlycy5cbiAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2lzc3Vlcy8xMTkyKVxuICAgIGNvbnN0IHVwSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVXBfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgICAgVVBfRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdXBIYW5kbGVyKSk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgIFVQX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB1cEhhbmRsZXIpKTtcbiAgICB0aGlzLnNldFZhbHVlRnJvbUV2dF8oZXZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU1vdmVfKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2V0VmFsdWVGcm9tRXZ0XyhldnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2xpZGVyIGVuZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVVwXygpIHtcbiAgICB0aGlzLnNldEFjdGl2ZV8oZmFsc2UpO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFnZVggb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFnZVhfKGV2dCkge1xuICAgIGlmIChldnQudGFyZ2V0VG91Y2hlcyAmJiBldnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZXZ0LnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgfVxuICAgIHJldHVybiBldnQucGFnZVg7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2xpZGVyIHZhbHVlIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VmFsdWVGcm9tRXZ0XyhldnQpIHtcbiAgICBjb25zdCBwYWdlWCA9IHRoaXMuZ2V0UGFnZVhfKGV2dCk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNvbXB1dGVWYWx1ZUZyb21QYWdlWF8ocGFnZVgpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbmV3IHZhbHVlIGZyb20gdGhlIHBhZ2VYIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb21wdXRlVmFsdWVGcm9tUGFnZVhfKHBhZ2VYKSB7XG4gICAgY29uc3Qge21heF86IG1heCwgbWluXzogbWlufSA9IHRoaXM7XG4gICAgY29uc3QgeFBvcyA9IHBhZ2VYIC0gdGhpcy5yZWN0Xy5sZWZ0O1xuICAgIGxldCBwY3RDb21wbGV0ZSA9IHhQb3MgLyB0aGlzLnJlY3RfLndpZHRoO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzUlRMKCkpIHtcbiAgICAgIHBjdENvbXBsZXRlID0gMSAtIHBjdENvbXBsZXRlO1xuICAgIH1cbiAgICAvLyBGaXQgdGhlIHBlcmNlbnRhZ2UgY29tcGxldGUgYmV0d2VlbiB0aGUgcmFuZ2UgW21pbixtYXhdXG4gICAgLy8gYnkgcmVtYXBwaW5nIGZyb20gWzAsIDFdIHRvIFttaW4sIG1pbisobWF4LW1pbildLlxuICAgIHJldHVybiBtaW4gKyBwY3RDb21wbGV0ZSAqIChtYXggLSBtaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5ZG93biBldmVudHNcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5ZG93bl8oZXZ0KSB7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkXyhldnQpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvcktleUlkXyhrZXlJZCk7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgcGFnZSBmcm9tIHNjcm9sbGluZyBkdWUgdG8ga2V5IHByZXNzZXMgdGhhdCB3b3VsZCBub3JtYWxseSBzY3JvbGwgdGhlIHBhZ2VcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBrYmRFdnRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0S2V5SWRfKGtiZEV2dCkge1xuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkFSUk9XX0xFRlQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM3KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19MRUZUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19SSUdIVCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1JJR0hUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1VQO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19ET1dOIHx8IGtiZEV2dC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfRE9XTjtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuSE9NRSB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzYpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkhPTUU7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkVORCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzUpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkVORDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuUEFHRV9VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzMpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfVVA7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLlBBR0VfRE9XTiB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzQpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfRE9XTjtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHZhbHVlIGdpdmVuIGEga2V5Ym9hcmQga2V5IElEXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlJZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRWYWx1ZUZvcktleUlkXyhrZXlJZCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgc3RlcF86IHN0ZXB9ID0gdGhpcztcbiAgICBsZXQgZGVsdGEgPSBzdGVwIHx8IChtYXggLSBtaW4pIC8gMTAwO1xuICAgIGNvbnN0IHZhbHVlTmVlZHNUb0JlRmxpcHBlZCA9IHRoaXMuYWRhcHRlcl8uaXNSVEwoKSAmJiAoXG4gICAgICBrZXlJZCA9PT0gS0VZX0lEUy5BUlJPV19MRUZUIHx8IGtleUlkID09PSBLRVlfSURTLkFSUk9XX1JJR0hUXG4gICAgKTtcbiAgICBpZiAodmFsdWVOZWVkc1RvQmVGbGlwcGVkKSB7XG4gICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtleUlkKSB7XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0xFRlQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YTtcbiAgICBjYXNlIEtFWV9JRFMuQVJST1dfUklHSFQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGE7XG4gICAgY2FzZSBLRVlfSURTLkhPTUU6XG4gICAgICByZXR1cm4gdGhpcy5taW5fO1xuICAgIGNhc2UgS0VZX0lEUy5FTkQ6XG4gICAgICByZXR1cm4gdGhpcy5tYXhfO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGEgKiBudW1iZXJzLlBBR0VfRkFDVE9SO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YSAqIG51bWJlcnMuUEFHRV9GQUNUT1I7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXNfKCkge1xuICAgIGlmICh0aGlzLnByZXZlbnRGb2N1c1N0YXRlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgaGFuZGxlQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmlyZUlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlXG4gICAqL1xuICBzZXRWYWx1ZV8odmFsdWUsIHNob3VsZEZpcmVJbnB1dCwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy52YWx1ZV8gJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge21pbl86IG1pbiwgbWF4XzogbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgdmFsdWVTZXRUb0JvdW5kYXJ5ID0gdmFsdWUgPT09IG1pbiB8fCB2YWx1ZSA9PT0gbWF4O1xuICAgIGlmICh0aGlzLnN0ZXBfICYmICF2YWx1ZVNldFRvQm91bmRhcnkpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5xdWFudGl6ZV8odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgIHZhbHVlID0gbWluO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH1cbiAgICB0aGlzLnZhbHVlXyA9IHZhbHVlO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU5PVywgU3RyaW5nKHRoaXMudmFsdWVfKSk7XG4gICAgdGhpcy51cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8oKTtcblxuICAgIGlmIChzaG91bGRGaXJlSW5wdXQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SW5wdXQoKTtcbiAgICAgIGlmICh0aGlzLmlzRGlzY3JldGVfKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TWFya2VyVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBxdWFudGl6ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHF1YW50aXplXyh2YWx1ZSkge1xuICAgIGNvbnN0IG51bVN0ZXBzID0gTWF0aC5yb3VuZCh2YWx1ZSAvIHRoaXMuc3RlcF8pO1xuICAgIGNvbnN0IHF1YW50aXplZFZhbCA9IG51bVN0ZXBzICogdGhpcy5zdGVwXztcbiAgICByZXR1cm4gcXVhbnRpemVkVmFsO1xuICB9XG5cbiAgdXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgdmFsdWVfOiB2YWx1ZX0gPSB0aGlzO1xuICAgIGNvbnN0IHBjdENvbXBsZXRlID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIGxldCB0cmFuc2xhdGVQeCA9IHBjdENvbXBsZXRlICogdGhpcy5yZWN0Xy53aWR0aDtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1JUTCgpKSB7XG4gICAgICB0cmFuc2xhdGVQeCA9IHRoaXMucmVjdF8ud2lkdGggLSB0cmFuc2xhdGVQeDtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wID0gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3csICd0cmFuc2Zvcm0nKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uZW5kRXZ0TmFtZSA9IGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAndHJhbnNpdGlvbmVuZCcpO1xuXG4gICAgaWYgKHRoaXMuaW5UcmFuc2l0Xykge1xuICAgICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldEluVHJhbnNpdF8oZmFsc2UpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcih0cmFuc2l0aW9uZW5kRXZ0TmFtZSwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHJhbnNpdGlvbmVuZEV2dE5hbWUsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVVSUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBOT1RFKHRyYXZpc2thdWZtYW4pOiBJdCB3b3VsZCBiZSBuaWNlIHRvIHVzZSBjYWxjKCkgaGVyZSxcbiAgICAgIC8vIGJ1dCBJRSBjYW5ub3QgaGFuZGxlIGNhbGNzIGluIHRyYW5zZm9ybXMgY29ycmVjdGx5LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dvby5nbC9OQzJpdGtcbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHRoZSAtNTAlIG9mZnNldCBpcyB1c2VkIHRvIGNlbnRlciB0aGUgc2xpZGVyIHRodW1iLlxuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVQeH1weCkgdHJhbnNsYXRlWCgtNTAlKWApO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFja1N0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHNjYWxlWCgke3BjdENvbXBsZXRlfSlgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZVxuICAgKi9cbiAgc2V0QWN0aXZlXyhhY3RpdmUpIHtcbiAgICB0aGlzLmFjdGl2ZV8gPSBhY3RpdmU7XG4gICAgdGhpcy50b2dnbGVDbGFzc18oY3NzQ2xhc3Nlcy5BQ1RJVkUsIHRoaXMuYWN0aXZlXyk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgaW5UcmFuc2l0IHN0YXRlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBpblRyYW5zaXRcbiAgICovXG4gIHNldEluVHJhbnNpdF8oaW5UcmFuc2l0KSB7XG4gICAgdGhpcy5pblRyYW5zaXRfID0gaW5UcmFuc2l0O1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuSU5fVFJBTlNJVCwgdGhpcy5pblRyYW5zaXRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IGFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIGJhc2VkIG9uIHNob3VsZEJlUHJlc2VudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkQmVQcmVzZW50XG4gICAqL1xuICB0b2dnbGVDbGFzc18oY2xhc3NOYW1lLCBzaG91bGRCZVByZXNlbnQpIHtcbiAgICBpZiAoc2hvdWxkQmVQcmVzZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2xpZGVyRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXNsaWRlclwiXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICByb2xlPVwic2xpZGVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdlxuICAgICAgICA6c3R5bGU9XCJ0cmFja1N0eWxlc1wiXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2tcIi8+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNNYXJrZXJzXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICB2LWZvcj1cIm1hcmtlck51bSBpbiBudW1NYXJrZXJzXCJcbiAgICAgICAgICA6a2V5PVwibWFya2VyTnVtXCJcbiAgICAgICAgICA6c3R5bGU9XCIobWFya2VyTnVtID09IG51bU1hcmtlcnMpID8gbGFzdFRyYWNrTWFya2Vyc1N0eWxlcyA6IHt9XCJcbiAgICAgICAgICBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlclwiXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJ0aHVtYkNvbnRhaW5lclwiXG4gICAgICA6c3R5bGU9XCJ0aHVtYlN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwiaXNEaXNjcmV0ZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlclwiPnt7IG1hcmtlclZhbHVlIH19PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8c3ZnXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fdGh1bWJcIlxuICAgICAgICB3aWR0aD1cIjIxXCJcbiAgICAgICAgaGVpZ2h0PVwiMjFcIj5cbiAgICAgICAgPGNpcmNsZVxuICAgICAgICAgIGN4PVwiMTAuNVwiXG4gICAgICAgICAgY3k9XCIxMC41XCJcbiAgICAgICAgICByPVwiNy44NzVcIi8+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX19mb2N1cy1yaW5nXCIvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2xpZGVyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIGFwcGx5UGFzc2l2ZSB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbGlkZXInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgbWluOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDAgfSxcbiAgICBtYXg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMTAwIH0sXG4gICAgc3RlcDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAwIH0sXG4gICAgZGlzcGxheU1hcmtlcnM6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGF5b3V0T246IFN0cmluZyxcbiAgICBsYXlvdXRPblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1zbGlkZXItLWRpc2NyZXRlJzogISF0aGlzLnN0ZXAsXG4gICAgICAgICdtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMnOiB0aGlzLmRpc3BsYXlNYXJrZXJzXG4gICAgICB9LFxuICAgICAgdHJhY2tTdHlsZXM6IHt9LFxuICAgICAgbGFzdFRyYWNrTWFya2Vyc1N0eWxlczoge30sXG4gICAgICB0aHVtYlN0eWxlczoge30sXG4gICAgICBtYXJrZXJWYWx1ZTogJycsXG4gICAgICBudW1NYXJrZXJzOiAwXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzRGlzY3JldGUoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXBcbiAgICB9LFxuICAgIGhhc01hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXAgJiYgdGhpcy5kaXNwbGF5TWFya2VycyAmJiB0aGlzLm51bU1hcmtlcnNcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkgIT09IE51bWJlcih0aGlzLnZhbHVlKSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmFsdWUodGhpcy52YWx1ZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbigpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9LFxuICAgIG1heCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICB9LFxuICAgIHN0ZXAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0U3RlcChOdW1iZXIodGhpcy5zdGVwKSlcbiAgICB9LFxuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbGlkZXJGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgZ2V0QXR0cmlidXRlOiBuYW1lID0+IHRoaXMuJGVsLmdldEF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIHNldEF0dHJpYnV0ZTogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgcmVtb3ZlQXR0cmlidXRlOiBuYW1lID0+IHRoaXMuJGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IHRoaXMuJGVsLnRhYkluZGV4LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLnRodW1iQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIGFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgICB9LFxuICAgICAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy50aHVtYlN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRUcmFja1N0eWxlUHJvcGVydHk6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnRyYWNrU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMubWFya2VyVmFsdWUgPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIGFwcGVuZFRyYWNrTWFya2VyczogbnVtTWFya2VycyA9PiB7XG4gICAgICAgIHRoaXMubnVtTWFya2VycyA9IG51bU1hcmtlcnNcbiAgICAgIH0sXG4gICAgICByZW1vdmVUcmFja01hcmtlcnM6ICgpID0+IHtcbiAgICAgICAgdGhpcy5udW1NYXJrZXJzID0gMFxuICAgICAgfSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYXN0VHJhY2tNYXJrZXJzU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGlzUlRMOiAoKSA9PiBmYWxzZVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgaWYgKE51bWJlcih0aGlzLm1pbikgPD0gdGhpcy5mb3VuZGF0aW9uLmdldE1heCgpKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWluKE51bWJlcih0aGlzLm1pbikpXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFN0ZXAoTnVtYmVyKHRoaXMuc3RlcCkpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKE51bWJlcih0aGlzLnZhbHVlKSlcbiAgICBpZiAodGhpcy5oYXNNYXJrZXJzKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0dXBUcmFja01hcmtlcigpXG4gICAgfVxuXG4gICAgdGhpcy4kcm9vdC4kb24oJ3ZtYTpsYXlvdXQnLCB0aGlzLmxheW91dClcblxuICAgIGlmICh0aGlzLmxheW91dE9uKSB7XG4gICAgICB0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UgPSB0aGlzLmxheW91dE9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb24odGhpcy5sYXlvdXRPbiwgdGhpcy5sYXlvdXQpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJHJvb3QuJG9mZigndm1hOmxheW91dCcsIHRoaXMubGF5b3V0KVxuICAgIGlmICh0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb2ZmKHRoaXMubGF5b3V0T24sIHRoaXMubGF5b3V0KVxuICAgIH1cbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsYXlvdXQoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KClcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1NsaWRlciBmcm9tICcuL21kYy1zbGlkZXIudnVlJ1xuXG5leHBvcnQgeyBtZGNTbGlkZXIgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU2xpZGVyXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXNuYWNrYmFyJyxcbiAgVEVYVDogJ21kYy1zbmFja2Jhcl9fdGV4dCcsXG4gIEFDVElPTl9XUkFQUEVSOiAnbWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlcicsXG4gIEFDVElPTl9CVVRUT046ICdtZGMtc25hY2tiYXJfX2FjdGlvbi1idXR0b24nLFxuICBBQ1RJVkU6ICdtZGMtc25hY2tiYXItLWFjdGl2ZScsXG4gIE1VTFRJTElORTogJ21kYy1zbmFja2Jhci0tbXVsdGlsaW5lJyxcbiAgQUNUSU9OX09OX0JPVFRPTTogJ21kYy1zbmFja2Jhci0tYWN0aW9uLW9uLWJvdHRvbScsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgVEVYVF9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX3RleHQnLFxuICBBQ1RJT05fV1JBUFBFUl9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX2FjdGlvbi13cmFwcGVyJyxcbiAgQUNUSU9OX0JVVFRPTl9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX2FjdGlvbi1idXR0b24nLFxuICBTSE9XX0VWRU5UOiAnTURDU25hY2tiYXI6c2hvdycsXG4gIEhJREVfRVZFTlQ6ICdNRENTbmFja2JhcjpoaWRlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xuICBNRVNTQUdFX1RJTUVPVVQ6IDI3NTAsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDU25hY2tiYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRBcmlhSGlkZGVuOiAoKSA9PiB7fSxcbiAgICAgIHVuc2V0QXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICBzZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiB7fSxcbiAgICAgIHVuc2V0QWN0aW9uQXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICBzZXRBY3Rpb25UZXh0OiAoLyogYWN0aW9uVGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1lc3NhZ2VUZXh0OiAoLyogbWVzc2FnZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldEZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIHZpc2liaWxpdHlJc0hpZGRlbjogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5U2hvdzogKCkgPT4ge30sXG4gICAgICBub3RpZnlIaWRlOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVfO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU25hY2tiYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFjdGlvbldhc0NsaWNrZWRfID0gZmFsc2U7XG4gICAgdGhpcy5kaXNtaXNzT25BY3Rpb25fID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gdHJ1ZTtcbiAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSBmYWxzZTtcbiAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgdGhpcy5zbmFja2JhckRhdGFfID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlXyA9IFtdO1xuICAgIHRoaXMuYWN0aW9uQ2xpY2tIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aW9uV2FzQ2xpY2tlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5pbnZva2VBY3Rpb25fKCk7XG4gICAgfTtcbiAgICB0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5hZGFwdGVyXy52aXNpYmlsaXR5SXNIaWRkZW4oKSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY2xlYW51cF8uYmluZCh0aGlzKSwgdGhpcy5zbmFja2JhckRhdGFfLnRpbWVvdXQgfHwgbnVtYmVycy5NRVNTQUdFX1RJTUVPVVQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC50eXBlID09ICd0b3VjaHN0YXJ0JyB8fCBldnQudHlwZSA9PSAnbW91c2Vkb3duJykge1xuICAgICAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfKGV2dCk7XG5cbiAgICAgIGlmIChldnQudHlwZSA9PSAnZm9jdXMnKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckRvd25SZWNvZ25pemVkXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICAgIHRoaXMuc25hY2tiYXJIYXNGb2N1c18gPSBmYWxzZTtcbiAgICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5jbGVhbnVwXy5iaW5kKHRoaXMpLCB0aGlzLnNuYWNrYmFyRGF0YV8udGltZW91dCB8fCBudW1iZXJzLk1FU1NBR0VfVElNRU9VVCk7XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlcih0aGlzLmFjdGlvbkNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXJpYUhpZGRlbigpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QWN0aW9uQXJpYUhpZGRlbigpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIodGhpcy5hY3Rpb25DbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyKHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcih0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyk7XG4gICAgWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93bicsICdmb2N1cyddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNtaXNzZXNPbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNtaXNzT25BY3Rpb25fO1xuICB9XG5cbiAgc2V0RGlzbWlzc09uQWN0aW9uKGRpc21pc3NPbkFjdGlvbikge1xuICAgIHRoaXMuZGlzbWlzc09uQWN0aW9uXyA9ICEhZGlzbWlzc09uQWN0aW9uO1xuICB9XG5cbiAgc2hvdyhkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdQbGVhc2UgcHJvdmlkZSBhIGRhdGEgb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBtZXNzYWdlIHRvIGRpc3BsYXkuJyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5tZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuJyk7XG4gICAgfVxuICAgIGlmIChkYXRhLmFjdGlvbkhhbmRsZXIgJiYgIWRhdGEuYWN0aW9uVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhY3Rpb24gdGV4dCB3aXRoIHRoZSBoYW5kbGVyLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIHRoaXMucXVldWVfLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgIHRoaXMuc25hY2tiYXJEYXRhXyA9IGRhdGE7XG4gICAgdGhpcy5maXJzdEZvY3VzXyA9IHRydWU7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyKHRoaXMudmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcih0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93bicsICdmb2N1cyddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qge0FDVElWRSwgTVVMVElMSU5FLCBBQ1RJT05fT05fQk9UVE9NfSA9IGNzc0NsYXNzZXM7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lc3NhZ2VUZXh0KHRoaXMuc25hY2tiYXJEYXRhXy5tZXNzYWdlKTtcblxuICAgIGlmICh0aGlzLnNuYWNrYmFyRGF0YV8ubXVsdGlsaW5lKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1VTFRJTElORSk7XG4gICAgICBpZiAodGhpcy5zbmFja2JhckRhdGFfLmFjdGlvbk9uQm90dG9tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoQUNUSU9OX09OX0JPVFRPTSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvblRleHQodGhpcy5zbmFja2JhckRhdGFfLmFjdGlvblRleHQpO1xuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXyA9IHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25IYW5kbGVyO1xuICAgICAgdGhpcy5zZXRBY3Rpb25IaWRkZW5fKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRBY3Rpb25IaWRkZW5fKHRydWUpO1xuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXyA9IG51bGw7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvblRleHQobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmVfID0gdHJ1ZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnNldEFyaWFIaWRkZW4oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVNob3coKTtcblxuICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5jbGVhbnVwXy5iaW5kKHRoaXMpLCB0aGlzLnNuYWNrYmFyRGF0YV8udGltZW91dCB8fCBudW1iZXJzLk1FU1NBR0VfVElNRU9VVCk7XG4gIH1cblxuICBoYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfKCkge1xuICAgIGNvbnN0IGhpamFja0ZvY3VzID1cbiAgICAgIHRoaXMuZmlyc3RGb2N1c18gJiYgIXRoaXMucG9pbnRlckRvd25SZWNvZ25pemVkXztcblxuICAgIGlmIChoaWphY2tGb2N1cykge1xuICAgICAgdGhpcy5zZXRGb2N1c09uQWN0aW9uXygpO1xuICAgIH1cblxuICAgIHRoaXMuZmlyc3RGb2N1c18gPSBmYWxzZTtcbiAgfVxuXG4gIHNldEZvY3VzT25BY3Rpb25fKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0Rm9jdXMoKTtcbiAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gZmFsc2U7XG4gIH1cblxuICBpbnZva2VBY3Rpb25fKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuYWN0aW9uSGFuZGxlcl8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFjdGlvbkhhbmRsZXJfKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmRpc21pc3NPbkFjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwXygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsZWFudXBfKCkge1xuICAgIGNvbnN0IGFsbG93RGlzbWlzc2FsID0gIXRoaXMuc25hY2tiYXJIYXNGb2N1c18gfHwgdGhpcy5hY3Rpb25XYXNDbGlja2VkXztcblxuICAgIGlmIChhbGxvd0Rpc21pc3NhbCkge1xuICAgICAgY29uc3Qge0FDVElWRSwgTVVMVElMSU5FLCBBQ1RJT05fT05fQk9UVE9NfSA9IGNzc0NsYXNzZXM7XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQUNUSVZFKTtcblxuICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1VTFRJTElORSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQUNUSU9OX09OX0JPVFRPTSk7XG4gICAgICAgIHRoaXMuc2V0QWN0aW9uSGlkZGVuXyh0cnVlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBcmlhSGlkZGVuKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SGlkZSgpO1xuICAgICAgICB0aGlzLnNob3dOZXh0XygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHNob3dOZXh0XygpIHtcbiAgICBpZiAoIXRoaXMucXVldWVfLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNob3codGhpcy5xdWV1ZV8uc2hpZnQoKSk7XG4gIH1cblxuICBzZXRBY3Rpb25IaWRkZW5fKGlzSGlkZGVuKSB7XG4gICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy51bnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgICB9XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICByZWY9XCJyb290XCIgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDphcmlhLWhpZGRlbj1cImhpZGRlblwiIFxuICAgIGNsYXNzPVwibWRjLXNuYWNrYmFyXCIgXG4gICAgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgXG4gICAgYXJpYS1hdG9taWM9XCJ0cnVlXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1zbmFja2Jhcl9fdGV4dFwiPnt7IG1lc3NhZ2UgfX08L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlclwiPlxuICAgICAgPGJ1dHRvbiBcbiAgICAgICAgcmVmPVwiYnV0dG9uXCIgXG4gICAgICAgIDphcmlhLWhpZGRlbj1cImFjdGlvbkhpZGRlblwiIFxuICAgICAgICB0eXBlPVwiYnV0dG9uXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLXNuYWNrYmFyX19hY3Rpb24tYnV0dG9uXCI+e3sgYWN0aW9uVGV4dCB9fTwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU25hY2tiYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zbmFja2Jhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZ2V0Q29ycmVjdEV2ZW50TmFtZSB9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbmFja2JhcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3NuYWNrJyxcbiAgICBldmVudDogJ3F1ZXVlZCdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAnYWxpZ24tc3RhcnQnOiBCb29sZWFuLFxuICAgIHNuYWNrOiBPYmplY3QsXG4gICAgZXZlbnQ6IFN0cmluZyxcbiAgICAnZXZlbnQtc291cmNlJzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvb3RcbiAgICAgIH1cbiAgICB9LFxuICAgICdkaXNtaXNzZXMtb24tYWN0aW9uJzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1zbmFja2Jhci0tYWxpZ24tc3RhcnQnOiB0aGlzLmFsaWduU3RhcnRcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiAnJyxcbiAgICAgIGFjdGlvblRleHQ6ICcnLFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGFjdGlvbkhpZGRlbjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgc25hY2s6ICdvblNuYWNrJ1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbmFja2JhckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgc2V0QXJpYUhpZGRlbjogKCkgPT4gKHRoaXMuaGlkZGVuID0gdHJ1ZSksXG4gICAgICB1bnNldEFyaWFIaWRkZW46ICgpID0+ICh0aGlzLmhpZGRlbiA9IGZhbHNlKSxcbiAgICAgIHNldEFjdGlvbkFyaWFIaWRkZW46ICgpID0+ICh0aGlzLmFjdGlvbkhpZGRlbiA9IHRydWUpLFxuICAgICAgdW5zZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiAodGhpcy5hY3Rpb25IaWRkZW4gPSBmYWxzZSksXG4gICAgICBzZXRBY3Rpb25UZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy5hY3Rpb25UZXh0ID0gdGV4dFxuICAgICAgfSxcbiAgICAgIHNldE1lc3NhZ2VUZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGV4dFxuICAgICAgfSxcbiAgICAgIHNldEZvY3VzOiAoKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5mb2N1cygpLFxuICAgICAgdmlzaWJpbGl0eUlzSGlkZGVuOiAoKSA9PiBkb2N1bWVudC5oaWRkZW4sXG4gICAgICByZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgdHJ1ZSksXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy4kcmVmcy5yb290XG4gICAgICAgIHJvb3QgJiZcbiAgICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ3RyYW5zaXRpb25lbmQnKSxcbiAgICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgICApXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuJHJlZnMucm9vdFxuICAgICAgICByb290ICYmXG4gICAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICd0cmFuc2l0aW9uZW5kJyksXG4gICAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeVNob3c6ICgpID0+IHRoaXMuJGVtaXQoJ3Nob3cnKSxcbiAgICAgIG5vdGlmeUhpZGU6ICgpID0+IHRoaXMuJGVtaXQoJ2hpZGUnKVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuXG4gICAgLy8gaWYgZXZlbnQgc3BlY2lmaWVkIHVzZSBpdCwgZWxzZSBpZiBubyBzbmFjayBwcm9wIHRoZW4gdXNlIGRlZmF1bHQuXG4gICAgdGhpcy5ldmVudE5hbWUgPVxuICAgICAgdGhpcy5ldmVudCB8fCAodGhpcy5zbmFjayA9PT0gdm9pZCAwID8gJ3Nob3ctc25hY2tiYXInIDogbnVsbClcbiAgICBpZiAodGhpcy5ldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UuJG9uKHRoaXMuZXZlbnROYW1lLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNtaXNzT25BY3Rpb24odGhpcy5kaXNtaXNzZXNPbkFjdGlvbilcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5ldmVudFNvdXJjZSkge1xuICAgICAgdGhpcy5ldmVudFNvdXJjZS4kb2ZmKHRoaXMuZXZlbnROYW1lLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uU25hY2soc25hY2spIHtcbiAgICAgIGlmIChzbmFjayAmJiBzbmFjay5tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zaG93KHNuYWNrKVxuICAgICAgICB0aGlzLiRlbWl0KCdxdWV1ZWQnLCBzbmFjaylcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3coZGF0YSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNob3coZGF0YSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU25hY2tiYXIgZnJvbSAnLi9tZGMtc25hY2tiYXIudnVlJ1xuXG5leHBvcnQgeyBtZGNTbmFja2JhciB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTbmFja2JhclxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cIntcbiAgICAgICdtZGMtZm9ybS1maWVsZCc6IGhhc0xhYmVsLFxuICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiBoYXNMYWJlbCAmJiBhbGlnbkVuZFxuICAgIH1cIlxuICAgIGNsYXNzPVwibWRjLXN3aXRjaC13cmFwcGVyXCIgPlxuXG4gICAgPGRpdlxuICAgICAgOmNsYXNzPVwieydtZGMtc3dpdGNoLS1kaXNhYmxlZCc6IGRpc2FibGVkIH1cIlxuICAgICAgY2xhc3M9XCJtZGMtc3dpdGNoXCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgcmVmPVwiY29udHJvbFwiXG4gICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkXCJcbiAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWRcIlxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICBjbGFzcz1cIm1kYy1zd2l0Y2hfX25hdGl2ZS1jb250cm9sXCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlZFwiID5cblxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX2JhY2tncm91bmRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX2tub2JcIi8+XG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPGxhYmVsXG4gICAgICB2LWlmPVwiaGFzTGFiZWxcIlxuICAgICAgOmZvcj1cInZtYV91aWRfXCJcbiAgICAgIGNsYXNzPVwibWRjLXN3aXRjaC1sYWJlbFwiPlxuICAgICAgPHNsb3Q+e3sgbGFiZWwgfX08L3Nsb3Q+XG4gICAgPC9sYWJlbD5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc3dpdGNoJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgY2hlY2tlZDogQm9vbGVhbixcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIGFsaWduRW5kOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ29uJ1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZTogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbCB8fCB0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DaGFuZ2VkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudC50YXJnZXQuY2hlY2tlZClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU3dpdGNoIGZyb20gJy4vbWRjLXN3aXRjaC52dWUnXG5cbmV4cG9ydCB7IG1kY1N3aXRjaCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTd2l0Y2hcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXRhYi0tYWN0aXZlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBTRUxFQ1RFRF9FVkVOVDogJ01EQ1RhYjpzZWxlY3RlZCcsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGFiRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRMZWZ0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmNvbXB1dGVkV2lkdGhfID0gMDtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSAwO1xuICAgIHRoaXMuaXNBY3RpdmVfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQua2V5ICYmIGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgZ2V0Q29tcHV0ZWRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlZFdpZHRoXztcbiAgfVxuXG4gIGdldENvbXB1dGVkTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlZExlZnRfO1xuICB9XG5cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNBY3RpdmVfO1xuICB9XG5cbiAgc2V0QWN0aXZlKGlzQWN0aXZlKSB7XG4gICAgdGhpcy5pc0FjdGl2ZV8gPSBpc0FjdGl2ZTtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB9XG4gIH1cblxuICBwcmV2ZW50c0RlZmF1bHRPbkNsaWNrKCkge1xuICAgIHJldHVybiB0aGlzLnByZXZlbnREZWZhdWx0T25DbGlja187XG4gIH1cblxuICBzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2socHJldmVudERlZmF1bHRPbkNsaWNrKSB7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfID0gcHJldmVudERlZmF1bHRPbkNsaWNrO1xuICB9XG5cbiAgbWVhc3VyZVNlbGYoKSB7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldExlZnQoKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcclxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDpsaW5rPVwibGlua1wiXHJcbiAgICBjbGFzcz1cIm1kYy10YWJcIlxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG5cclxuICAgIDxpIFxuICAgICAgdi1pZj1cIiEhaGFzSWNvblwiIFxuICAgICAgcmVmPVwiaWNvblwiXHJcbiAgICAgIDpjbGFzcz1cImhhc0ljb24uY2xhc3Nlc1wiXHJcbiAgICAgIHRhYmluZGV4PVwiMFwiXHJcbiAgICAgIGNsYXNzPVwibWRjLXRhYl9faWNvblwiPlxyXG4gICAgICA8c2xvdCBuYW1lPVwiaWNvblwiPnt7IGhhc0ljb24uY29udGVudCB9fTwvc2xvdD5cclxuICAgIDwvaT5cclxuXHJcbiAgICA8c3BhbiBcbiAgICAgIHYtaWY9XCJoYXNUZXh0XCIgXG4gICAgICA6Y2xhc3M9XCJ7J21kYy10YWJfX2ljb24tdGV4dCc6ICEhaGFzSWNvbn1cIj5cclxuICAgICAgPHNsb3QvPlxyXG4gICAgPC9zcGFuPlxyXG5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXHJcbmltcG9ydCB7XHJcbiAgQ3VzdG9tTGlua01peGluLFxyXG4gIERpc3BhdGNoRXZlbnRNaXhpbixcclxuICBlbWl0Q3VzdG9tRXZlbnQsXHJcbiAgZXh0cmFjdEljb25Qcm9wXHJcbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLXRhYicsXHJcbiAgbWl4aW5zOiBbQ3VzdG9tTGlua01peGluLCBEaXNwYXRjaEV2ZW50TWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBhY3RpdmU6IEJvb2xlYW4sXHJcbiAgICBpY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XVxyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgaGFzSWNvbigpIHtcclxuICAgICAgaWYgKHRoaXMuaWNvbiB8fCB0aGlzLiRzbG90cy5pY29uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLmljb24pIDoge31cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBoYXNUZXh0KCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLiRzbG90cy5kZWZhdWx0XHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkKCkge1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RhYkZvdW5kYXRpb24oe1xyXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXHJcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcclxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxyXG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXHJcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxyXG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXHJcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLm9mZnNldFdpZHRoXHJcbiAgICAgIH0sXHJcbiAgICAgIGdldE9mZnNldExlZnQ6ICgpID0+IHRoaXMuJGVsLm9mZnNldExlZnQsXHJcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoKSA9PiB7XHJcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KFxyXG4gICAgICAgICAgdGhpcy4kZWwsXHJcbiAgICAgICAgICBNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsXHJcbiAgICAgICAgICB7IHRhYjogdGhpcyB9LFxyXG4gICAgICAgICAgdHJ1ZVxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcclxuICAgIHRoaXMuc2V0QWN0aXZlKHRoaXMuYWN0aXZlKVxyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxyXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBnZXRDb21wdXRlZFdpZHRoKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmdldENvbXB1dGVkV2lkdGgoKVxyXG4gICAgfSxcclxuICAgIGdldENvbXB1dGVkTGVmdCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5nZXRDb21wdXRlZExlZnQoKVxyXG4gICAgfSxcclxuICAgIGlzQWN0aXZlKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmlzQWN0aXZlKClcclxuICAgIH0sXHJcbiAgICBzZXRBY3RpdmUoaXNBY3RpdmUpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFjdGl2ZShpc0FjdGl2ZSlcclxuICAgIH0sXHJcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLnByZXZlbnRzRGVmYXVsdE9uQ2xpY2soKVxyXG4gICAgfSxcclxuICAgIHNldFByZXZlbnREZWZhdWx0T25DbGljayhwcmV2ZW50RGVmYXVsdE9uQ2xpY2spIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFByZXZlbnREZWZhdWx0T25DbGljayhwcmV2ZW50RGVmYXVsdE9uQ2xpY2spXHJcbiAgICB9LFxyXG4gICAgbWVhc3VyZVNlbGYoKSB7XHJcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5tZWFzdXJlU2VsZigpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgVVBHUkFERUQ6ICdtZGMtdGFiLWJhci11cGdyYWRlZCcsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgVEFCX1NFTEVDVE9SOiAnLm1kYy10YWInLFxuICBJTkRJQ0FUT1JfU0VMRUNUT1I6ICcubWRjLXRhYi1iYXJfX2luZGljYXRvcicsXG4gIENIQU5HRV9FVkVOVDogJ01EQ1RhYkJhcjpjaGFuZ2UnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtnZXRDb3JyZWN0UHJvcGVydHlOYW1lfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4JztcblxuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1RhYkJhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+IHt9LFxuICAgICAgdW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50OiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHNldFN0eWxlRm9ySW5kaWNhdG9yOiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGhGb3JJbmRpY2F0b3I6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoLyogZXZ0RGF0YToge2FjdGl2ZVRhYkluZGV4OiBudW1iZXJ9ICovKSA9PiB7fSxcbiAgICAgIGdldE51bWJlck9mVGFiczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBpc1RhYkFjdGl2ZUF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgc2V0VGFiQWN0aXZlQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIsIGlzQWN0aXZlOiB0cnVlICovKSA9PiB7fSxcbiAgICAgIGlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2tGb3JUYWJBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHNldFByZXZlbnREZWZhdWx0T25DbGlja0ZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyLCBwcmV2ZW50RGVmYXVsdE9uQ2xpY2s6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgICAgbWVhc3VyZVRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiB7fSxcbiAgICAgIGdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRDb21wdXRlZExlZnRGb3JUYWJBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogbnVtYmVyICovIDAsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RhYkJhckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIHRoaXMuaXNJbmRpY2F0b3JTaG93bl8gPSBmYWxzZTtcbiAgICB0aGlzLmNvbXB1dGVkV2lkdGhfID0gMDtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSAwO1xuICAgIHRoaXMuYWN0aXZlVGFiSW5kZXhfID0gMDtcbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMubGF5b3V0KCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5hZGFwdGVyXy5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgY29uc3QgYWN0aXZlVGFiSW5kZXggPSB0aGlzLmZpbmRBY3RpdmVUYWJJbmRleF8oKTtcbiAgICBpZiAoYWN0aXZlVGFiSW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSBhY3RpdmVUYWJJbmRleDtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVuYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cblxuICBsYXlvdXRJbnRlcm5hbF8oKSB7XG4gICAgdGhpcy5mb3JFYWNoVGFiSW5kZXhfKChpbmRleCkgPT4gdGhpcy5hZGFwdGVyXy5tZWFzdXJlVGFiQXRJbmRleChpbmRleCkpO1xuICAgIHRoaXMuY29tcHV0ZWRXaWR0aF8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgdGhpcy5sYXlvdXRJbmRpY2F0b3JfKCk7XG4gIH1cblxuICBsYXlvdXRJbmRpY2F0b3JfKCkge1xuICAgIGNvbnN0IGlzSW5kaWNhdG9yRmlyc3RSZW5kZXIgPSAhdGhpcy5pc0luZGljYXRvclNob3duXztcblxuICAgIC8vIEVuc3VyZSB0aGF0IGluZGljYXRvciBhcHBlYXJzIGluIHRoZSByaWdodCBwb3NpdGlvbiBpbW1lZGlhdGVseSBmb3IgY29ycmVjdCBmaXJzdCByZW5kZXIuXG4gICAgaWYgKGlzSW5kaWNhdG9yRmlyc3RSZW5kZXIpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JJbmRpY2F0b3IoJ3RyYW5zaXRpb24nLCAnbm9uZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zbGF0ZUFtdEZvckFjdGl2ZVRhYkxlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkTGVmdEZvclRhYkF0SW5kZXgodGhpcy5hY3RpdmVUYWJJbmRleF8pO1xuICAgIGNvbnN0IHNjYWxlQW10Rm9yQWN0aXZlVGFiV2lkdGggPVxuICAgICAgdGhpcy5hZGFwdGVyXy5nZXRDb21wdXRlZFdpZHRoRm9yVGFiQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4XykgLyB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZSA9IGB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdH1weCkgc2NhbGUoJHtzY2FsZUFtdEZvckFjdGl2ZVRhYldpZHRofSwgMSlgO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JJbmRpY2F0b3IoZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3csICd0cmFuc2Zvcm0nKSwgdHJhbnNmb3JtVmFsdWUpO1xuXG4gICAgaWYgKGlzSW5kaWNhdG9yRmlyc3RSZW5kZXIpIHtcbiAgICAgIC8vIEZvcmNlIGxheW91dCBzbyB0aGF0IHRyYW5zZm9ybSBzdHlsZXMgdG8gdGFrZSBlZmZlY3QuXG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoRm9ySW5kaWNhdG9yKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9ySW5kaWNhdG9yKCd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcigndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICB0aGlzLmlzSW5kaWNhdG9yU2hvd25fID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmaW5kQWN0aXZlVGFiSW5kZXhfKCkge1xuICAgIGxldCBhY3RpdmVUYWJJbmRleCA9IC0xO1xuICAgIHRoaXMuZm9yRWFjaFRhYkluZGV4XygoaW5kZXgpID0+IHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVGFiQWN0aXZlQXRJbmRleChpbmRleCkpIHtcbiAgICAgICAgYWN0aXZlVGFiSW5kZXggPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdGl2ZVRhYkluZGV4O1xuICB9XG5cbiAgZm9yRWFjaFRhYkluZGV4XyhpdGVyYXRvcikge1xuICAgIGNvbnN0IG51bVRhYnMgPSB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mVGFicygpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBudW1UYWJzOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBzaG91bGRCcmVhayA9IGl0ZXJhdG9yKGluZGV4KTtcbiAgICAgIGlmIChzaG91bGRCcmVhaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0RnJhbWVfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxheW91dEZyYW1lXyk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXlvdXRGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIHN3aXRjaFRvVGFiQXRJbmRleChpbmRleCwgc2hvdWxkTm90aWZ5KSB7XG4gICAgaWYgKGluZGV4ID09PSB0aGlzLmFjdGl2ZVRhYkluZGV4Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZlRhYnMoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdXQgb2YgYm91bmRzIGluZGV4IHNwZWNpZmllZCBmb3IgdGFiOiAke2luZGV4fWApO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZBY3RpdmVUYWJJbmRleCA9IHRoaXMuYWN0aXZlVGFiSW5kZXhfO1xuICAgIHRoaXMuYWN0aXZlVGFiSW5kZXhfID0gaW5kZXg7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmIChwcmV2QWN0aXZlVGFiSW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldFRhYkFjdGl2ZUF0SW5kZXgocHJldkFjdGl2ZVRhYkluZGV4LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRhYkFjdGl2ZUF0SW5kZXgodGhpcy5hY3RpdmVUYWJJbmRleF8sIHRydWUpO1xuICAgICAgdGhpcy5sYXlvdXRJbmRpY2F0b3JfKCk7XG4gICAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKHthY3RpdmVUYWJJbmRleDogdGhpcy5hY3RpdmVUYWJJbmRleF99KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldEFjdGl2ZVRhYkluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRBY3RpdmVUYWJJbmRleF8oKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8bmF2IFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICBjbGFzcz1cIm1kYy10YWItYmFyXCIgXG4gICAgdi1vbj1cIiRsaXN0ZW5lcnNcIj5cbiAgICA8c2xvdC8+XG4gICAgPHNwYW4gXG4gICAgICByZWY9XCJpbmRpY2F0b3JcIiBcbiAgICAgIDpzdHlsZT1cImluZGljYXRvclN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy10YWItYmFyX19pbmRpY2F0b3JcIi8+XG4gIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUYWJCYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90YWJzL3RhYi1iYXIvZm91bmRhdGlvbidcbmltcG9ydCBNRENUYWJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90YWJzL3RhYi9mb3VuZGF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGFiLWJhcicsXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgaW5kaWNhdG9yU3R5bGVzOiB7fSxcbiAgICAgIHRhYnM6IFtdXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUYWJCYXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsXG4gICAgICAgICAgdGhpcy5vblNlbGVjdFxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgdW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50OiAoKSA9PlxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCxcbiAgICAgICAgICB0aGlzLm9uU2VsZWN0XG4gICAgICAgICksXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHRoaXMuJGVsLm9mZnNldFdpZHRoLFxuICAgICAgc2V0U3R5bGVGb3JJbmRpY2F0b3I6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PlxuICAgICAgICB0aGlzLiRzZXQodGhpcy5pbmRpY2F0b3JTdHlsZXMsIHByb3BlcnR5TmFtZSwgdmFsdWUpLFxuICAgICAgZ2V0T2Zmc2V0V2lkdGhGb3JJbmRpY2F0b3I6ICgpID0+IHRoaXMuJHJlZnMuaW5kaWNhdG9yLm9mZnNldFdpZHRoLFxuICAgICAgbm90aWZ5Q2hhbmdlOiBldnREYXRhID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZ0RGF0YS5hY3RpdmVUYWJJbmRleClcbiAgICAgIH0sXG4gICAgICBnZXROdW1iZXJPZlRhYnM6ICgpID0+IHRoaXMudGFicy5sZW5ndGgsXG4gICAgICBpc1RhYkFjdGl2ZUF0SW5kZXg6IGluZGV4ID0+IHRoaXMudGFic1tpbmRleF0uaXNBY3RpdmUoKSxcbiAgICAgIHNldFRhYkFjdGl2ZUF0SW5kZXg6IChpbmRleCwgaXNBY3RpdmUpID0+IHtcbiAgICAgICAgLy8gcGdicjogMjAxOC0wNC0wN1xuICAgICAgICAvLyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBjaGFuZ2UgdGhlIG51bWJlciBvZiB0YWJzIHByb2dyYW1hdGljYWxseVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRldGVjdCB0aGUgZm91bmRhdGlvbiBkZWFjdGl2YXRpbmcgYSB0YWJcbiAgICAgICAgLy8gdGhhdCBubyBsb25nZXIgZXhpc3RzIGJ1dCB3YXMgcHJldmlvdXNseSBhY3RpdmUuXG4gICAgICAgIGlmICghaXNBY3RpdmUgJiYgaW5kZXggPj0gdGhpcy50YWJzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uc2V0QWN0aXZlKGlzQWN0aXZlKVxuICAgICAgfSxcbiAgICAgIGlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2tGb3JUYWJBdEluZGV4OiBpbmRleCA9PlxuICAgICAgICB0aGlzLnRhYnNbaW5kZXhdLmlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2soKSxcbiAgICAgIHNldFByZXZlbnREZWZhdWx0T25DbGlja0ZvclRhYkF0SW5kZXg6IChpbmRleCwgcHJldmVudERlZmF1bHRPbkNsaWNrKSA9PiB7XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uc2V0UHJldmVudERlZmF1bHRPbkNsaWNrKHByZXZlbnREZWZhdWx0T25DbGljaylcbiAgICAgIH0sXG4gICAgICBtZWFzdXJlVGFiQXRJbmRleDogaW5kZXggPT4gdGhpcy50YWJzW2luZGV4XS5tZWFzdXJlU2VsZigpLFxuICAgICAgZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXg6IGluZGV4ID0+XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uZ2V0Q29tcHV0ZWRXaWR0aCgpLFxuICAgICAgZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleDogaW5kZXggPT4gdGhpcy50YWJzW2luZGV4XS5nZXRDb21wdXRlZExlZnQoKVxuICAgIH0pXG5cbiAgICBjb25zdCByZXNldFRhYnMgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0YWJFbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoXG4gICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoTURDVGFiQmFyRm91bmRhdGlvbi5zdHJpbmdzLlRBQl9TRUxFQ1RPUilcbiAgICAgIClcbiAgICAgIHRoaXMudGFicyA9IHRhYkVsZW1lbnRzLm1hcChlbCA9PiBlbC5fX3Z1ZV9fKVxuXG4gICAgICBsZXQgaGFzVGV4dCwgaGFzSWNvblxuICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFic1xuICAgICAgZm9yIChsZXQgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgaWYgKHRhYi5oYXNUZXh0KSB7XG4gICAgICAgICAgaGFzVGV4dCA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB0YWIgb2YgdGFicykge1xuICAgICAgICBpZiAodGFiLmhhc0ljb24pIHtcbiAgICAgICAgICBoYXNJY29uID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1RleHQgJiYgaGFzSWNvbikge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLXRhYi1iYXItLWljb25zLXdpdGgtdGV4dCcsIHRydWUpXG4gICAgICB9IGVsc2UgaWYgKGhhc0ljb24pIHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy10YWItYmFyLS1pY29uLXRhYi1iYXInLCB0cnVlKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mb3VuZGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhYkluZGV4ID0gdGhpcy5mb3VuZGF0aW9uLmdldEFjdGl2ZVRhYkluZGV4KClcbiAgICAgICAgaWYgKGFjdGl2ZVRhYkluZGV4ID49IDApIHtcbiAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uc3dpdGNoVG9UYWJBdEluZGV4KGFjdGl2ZVRhYkluZGV4LCB0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5zd2l0Y2hUb1RhYkF0SW5kZXgoMCwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldFRhYnMoKVxuXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiByZXNldFRhYnMoKSlcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsLCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuc2xvdE9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uU2VsZWN0KHsgZGV0YWlsIH0pIHtcbiAgICAgIGNvbnN0IHsgdGFiIH0gPSBkZXRhaWxcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YWJzLmluZGV4T2YodGFiKVxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21kYy10YWItYmFyIGludGVybmFsIGVycm9yOiBpbmRleCBub3QgZm91bmQnKVxuICAgICAgfVxuICAgICAgdGhpcy5mb3VuZGF0aW9uLnN3aXRjaFRvVGFiQXRJbmRleChpbmRleCwgdHJ1ZSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVGFiIGZyb20gJy4vbWRjLXRhYi52dWUnXG5pbXBvcnQgbWRjVGFiQmFyIGZyb20gJy4vbWRjLXRhYi1iYXIudnVlJ1xuXG5leHBvcnQgeyBtZGNUYWIsIG1kY1RhYkJhciB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUYWIsXG4gIG1kY1RhYkJhclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZCBIZWxwZXIgVGV4dC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUZXh0RmllbGQgaGVscGVyIHRleHQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4gdmFsdWUgb24gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cihhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZUF0dHIoYXR0cikge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IGZvciB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICovXG4gIHNldENvbnRlbnQoY29udGVudCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX0hJRERFTjogJ2FyaWEtaGlkZGVuJyxcbiAgUk9MRTogJ3JvbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBIRUxQRVJfVEVYVF9QRVJTSVNURU5UOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXBlcnNpc3RlbnQnLFxuICBIRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRzogJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZycsXG59O1xuXG5leHBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICByZW1vdmVBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHNldENvbnRlbnQ6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIGhlbHBlciB0ZXh0IGZpZWxkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQZXJzaXN0ZW50IFNldHMgdGhlIHBlcnNpc3RlbmN5IG9mIHRoZSBoZWxwZXIgdGV4dC4gKi9cbiAgc2V0UGVyc2lzdGVudChpc1BlcnNpc3RlbnQpIHtcbiAgICBpZiAoaXNQZXJzaXN0ZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkYXRpb24gVHJ1ZSB0byBtYWtlIHRoZSBoZWxwZXIgdGV4dCBhY3QgYXMgYW5cbiAgICogICBlcnJvciB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAqL1xuICBzZXRWYWxpZGF0aW9uKGlzVmFsaWRhdGlvbikge1xuICAgIGlmIChpc1ZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIE1ha2VzIHRoZSBoZWxwZXIgdGV4dCB2aXNpYmxlIHRvIHRoZSBzY3JlZW4gcmVhZGVyLiAqL1xuICBzaG93VG9TY3JlZW5SZWFkZXIoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKHN0cmluZ3MuQVJJQV9ISURERU4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbGlkaXR5IG9mIHRoZSBoZWxwZXIgdGV4dCBiYXNlZCBvbiB0aGUgaW5wdXQgdmFsaWRpdHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5wdXRJc1ZhbGlkXG4gICAqL1xuICBzZXRWYWxpZGl0eShpbnB1dElzVmFsaWQpIHtcbiAgICBjb25zdCBoZWxwZXJUZXh0SXNQZXJzaXN0ZW50ID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIGNvbnN0IGhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2cgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0cpO1xuICAgIGNvbnN0IHZhbGlkYXRpb25Nc2dOZWVkc0Rpc3BsYXkgPSBoZWxwZXJUZXh0SXNWYWxpZGF0aW9uTXNnICYmICFpbnB1dElzVmFsaWQ7XG5cbiAgICBpZiAodmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuUk9MRSwgJ2FsZXJ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cihzdHJpbmdzLlJPTEUpO1xuICAgIH1cblxuICAgIGlmICghaGVscGVyVGV4dElzUGVyc2lzdGVudCAmJiAhdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSkge1xuICAgICAgdGhpcy5oaWRlXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgaGVscCB0ZXh0IGZyb20gc2NyZWVuIHJlYWRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoaWRlXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX0hJRERFTiwgJ3RydWUnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZCBJY29uLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIHRleHQgZmllbGQgaWNvbiBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXIge1xuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHIoYXR0cikge31cblxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVBdHRyKGF0dHIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgXCJNRENUZXh0RmllbGQ6aWNvblwiIGRlbm90aW5nIGEgdXNlciBoYXMgY2xpY2tlZCB0aGUgaWNvbi5cbiAgICovXG4gIG5vdGlmeUljb25BY3Rpb24oKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRJY29uQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIElDT05fRVZFTlQ6ICdNRENUZXh0RmllbGQ6aWNvbicsXG4gIElDT05fUk9MRTogJ2J1dHRvbicsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRJY29uQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gKi8gKHtcbiAgICAgIGdldEF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICByZW1vdmVBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5SWNvbkFjdGlvbjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZz99ICovXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IG51bGw7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUludGVyYWN0aW9uKGV2dCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSB0aGlzLmFkYXB0ZXJfLmdldEF0dHIoJ3RhYmluZGV4Jyk7XG5cbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIGhlbHBlciB0ZXh0IGZpZWxkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGlmICghdGhpcy5zYXZlZFRhYkluZGV4Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKCdyb2xlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCB0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigncm9sZScsIHN0cmluZ3MuSUNPTl9ST0xFKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICdjbGljaycgfHwgZXZ0LmtleSA9PT0gJ0VudGVyJyB8fCBldnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SWNvbkFjdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJy4vaGVscGVyLXRleHQvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnLi9pY29uL2ZvdW5kYXRpb24nO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB2YWx1ZTogc3RyaW5nLFxuICogICBkaXNhYmxlZDogYm9vbGVhbixcbiAqICAgYmFkSW5wdXQ6IGJvb2xlYW4sXG4gKiAgIHZhbGlkaXR5OiB7XG4gKiAgICAgYmFkSW5wdXQ6IGJvb2xlYW4sXG4gKiAgICAgdmFsaWQ6IGJvb2xlYW4sXG4gKiAgIH0sXG4gKiB9fVxuICovXG5sZXQgTmF0aXZlSW5wdXRUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGhlbHBlclRleHQ6ICghTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqICAgaWNvbjogKCFNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbnx1bmRlZmluZWQpLFxuICogfX1cbiAqL1xubGV0IEZvdW5kYXRpb25NYXBUeXBlO1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHQgRmllbGQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgY2hhbmdlIGxpc3RlbmVyIG9uIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFBcnJheSk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKiBAcmV0dXJuIHshTXV0YXRpb25PYnNlcnZlcn1cbiAgICovXG4gIHJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgYSB2YWxpZGF0aW9uIGF0dHJpYnV0ZSBvYnNlcnZlciBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gb2JzZXJ2ZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcihvYnNlcnZlcikge31cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuYXRpdmUgdGV4dCBpbnB1dCBlbGVtZW50LCB3aXRoIGFcbiAgICogc2ltaWxhciBBUEkgc2hhcGUuIFRoZSBvYmplY3QgcmV0dXJuZWQgc2hvdWxkIGluY2x1ZGUgdGhlIHZhbHVlLCBkaXNhYmxlZFxuICAgKiBhbmQgYmFkSW5wdXQgcHJvcGVydGllcywgYXMgd2VsbCBhcyB0aGUgY2hlY2tWYWxpZGl0eSgpIGZ1bmN0aW9uLiBXZSBuZXZlclxuICAgKiBhbHRlciB0aGUgdmFsdWUgd2l0aGluIG91ciBjb2RlLCBob3dldmVyIHdlIGRvIHVwZGF0ZSB0aGUgZGlzYWJsZWRcbiAgICogcHJvcGVydHksIHNvIGlmIHlvdSBjaG9vc2UgdG8gZHVjay10eXBlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoaXMgbWV0aG9kXG4gICAqIGluIHlvdXIgaW1wbGVtZW50YXRpb24gaXQncyBpbXBvcnRhbnQgdG8ga2VlcCB0aGlzIGluIG1pbmQuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gbnVsbCwgd2hpY2ggdGhlIGZvdW5kYXRpb24gd2lsbCBoYW5kbGUgZ3JhY2VmdWxseS5cbiAgICogQHJldHVybiB7P0VsZW1lbnR8P05hdGl2ZUlucHV0VHlwZX1cbiAgICovXG4gIGdldE5hdGl2ZUlucHV0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0ZXh0ZmllbGQgaXMgZm9jdXNlZC5cbiAgICogV2UgYWNoaWV2ZSB0aGlzIHZpYSBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5yb290X2AuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0ZvY3VzZWQoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcm9vdCBlbGVtZW50IGlzIHNldCB0byBSVEwuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1J0bCgpIHt9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgbGluZSByaXBwbGUuXG4gICAqL1xuICBhY3RpdmF0ZUxpbmVSaXBwbGUoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgbGluZSByaXBwbGUuXG4gICAqL1xuICBkZWFjdGl2YXRlTGluZVJpcHBsZSgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRyYW5zZm9ybSBvcmlnaW4gb2YgdGhlIGxpbmUgcmlwcGxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFhcbiAgICovXG4gIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW4obm9ybWFsaXplZFgpIHt9XG5cbiAgLyoqXG4gICAqIE9ubHkgaW1wbGVtZW50IGlmIGxhYmVsIGV4aXN0cy5cbiAgICogU2hha2VzIGxhYmVsIGlmIHNob3VsZFNoYWtlIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkU2hha2VcbiAgICovXG4gIHNoYWtlTGFiZWwoc2hvdWxkU2hha2UpIHt9XG5cbiAgLyoqXG4gICAqIE9ubHkgaW1wbGVtZW50IGlmIGxhYmVsIGV4aXN0cy5cbiAgICogRmxvYXRzIHRoZSBsYWJlbCBhYm92ZSB0aGUgaW5wdXQgZWxlbWVudCBpZiBzaG91bGRGbG9hdCBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEZsb2F0XG4gICAqL1xuICBmbG9hdExhYmVsKHNob3VsZEZsb2F0KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgbGFiZWwgZWxlbWVudCBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXNuJ3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNMYWJlbCgpIHt9XG5cbiAgLyoqXG4gICAqIE9ubHkgaW1wbGVtZW50IGlmIGxhYmVsIGV4aXN0cy5cbiAgICogUmV0dXJucyB3aWR0aCBvZiBsYWJlbCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExhYmVsV2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cywgZmFsc2UgaWYgaXQgZG9lc24ndC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc091dGxpbmUoKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBvdXRsaW5lIGVsZW1lbnQgZXhpc3RzLlxuICAgKiBVcGRhdGVzIFNWRyBQYXRoIGFuZCBvdXRsaW5lIGVsZW1lbnQgYmFzZWQgb24gdGhlXG4gICAqIGxhYmVsIGVsZW1lbnQgd2lkdGggYW5kIFJUTCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxXaWR0aFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1J0bFxuICAgKi9cbiAgbm90Y2hPdXRsaW5lKGxhYmVsV2lkdGgsIGlzUnRsKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBvdXRsaW5lIGVsZW1lbnQgZXhpc3RzLlxuICAgKiBDbG9zZXMgbm90Y2ggaW4gb3V0bGluZSBlbGVtZW50LlxuICAgKi9cbiAgY2xvc2VPdXRsaW5lKCkge31cbn1cblxuZXhwb3J0IHtNRENUZXh0RmllbGRBZGFwdGVyLCBOYXRpdmVJbnB1dFR5cGUsIEZvdW5kYXRpb25NYXBUeXBlfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSSUFfQ09OVFJPTFM6ICdhcmlhLWNvbnRyb2xzJyxcbiAgSU5QVVRfU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX2lucHV0JyxcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZsb2F0aW5nLWxhYmVsJyxcbiAgSUNPTl9TRUxFQ1RPUjogJy5tZGMtdGV4dC1maWVsZF9faWNvbicsXG4gIE9VVExJTkVfU0VMRUNUT1I6ICcubWRjLW5vdGNoZWQtb3V0bGluZScsXG4gIExJTkVfUklQUExFX1NFTEVDVE9SOiAnLm1kYy1saW5lLXJpcHBsZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtdGV4dC1maWVsZCcsXG4gIFVQR1JBREVEOiAnbWRjLXRleHQtZmllbGQtLXVwZ3JhZGVkJyxcbiAgRElTQUJMRUQ6ICdtZGMtdGV4dC1maWVsZC0tZGlzYWJsZWQnLFxuICBERU5TRTogJ21kYy10ZXh0LWZpZWxkLS1kZW5zZScsXG4gIEZPQ1VTRUQ6ICdtZGMtdGV4dC1maWVsZC0tZm9jdXNlZCcsXG4gIElOVkFMSUQ6ICdtZGMtdGV4dC1maWVsZC0taW52YWxpZCcsXG4gIEJPWDogJ21kYy10ZXh0LWZpZWxkLS1ib3gnLFxuICBPVVRMSU5FRDogJ21kYy10ZXh0LWZpZWxkLS1vdXRsaW5lZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIExBQkVMX1NDQUxFOiAwLjc1LFxuICBERU5TRV9MQUJFTF9TQ0FMRTogMC45MjMsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBmcm9tICcuL2hlbHBlci10ZXh0L2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGZyb20gJy4vaWNvbi9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGV4dEZpZWxkQWRhcHRlciwgTmF0aXZlSW5wdXRUeXBlLCBGb3VuZGF0aW9uTWFwVHlwZX0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8vIHdoaXRlbGlzdCBiYXNlZCBvZmYgb2YgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvSFRNTC9IVE1MNS9Db25zdHJhaW50X3ZhbGlkYXRpb25cbi8vIHVuZGVyIHNlY3Rpb246IGBWYWxpZGF0aW9uLXJlbGF0ZWQgYXR0cmlidXRlc2BcbmNvbnN0IFZBTElEQVRJT05fQVRUUl9XSElURUxJU1QgPSBbXG4gICdwYXR0ZXJuJywgJ21pbicsICdtYXgnLCAncmVxdWlyZWQnLCAnc3RlcCcsICdtaW5sZW5ndGgnLCAnbWF4bGVuZ3RoJyxcbl07XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RleHRGaWVsZEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBzaG91bGRTaGFrZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNWYWxpZCgpICYmICF0aGlzLmlzRm9jdXNlZF87XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgZ2V0IHNob3VsZEZsb2F0KCkge1xuICAgIHJldHVybiAhdGhpcy5pc0JhZElucHV0XygpICYmICghIXRoaXMuZ2V0VmFsdWUoKSB8fCB0aGlzLmlzRm9jdXNlZF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGdldE5hdGl2ZUlucHV0OiAoKSA9PiB7fSxcbiAgICAgIGlzRm9jdXNlZDogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4ge30sXG4gICAgICBhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHt9LFxuICAgICAgZGVhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHt9LFxuICAgICAgc2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbjogKCkgPT4ge30sXG4gICAgICBzaGFrZUxhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGZsb2F0TGFiZWw6ICgpID0+IHt9LFxuICAgICAgaGFzTGFiZWw6ICgpID0+IHt9LFxuICAgICAgZ2V0TGFiZWxXaWR0aDogKCkgPT4ge30sXG4gICAgICBoYXNPdXRsaW5lOiAoKSA9PiB7fSxcbiAgICAgIG5vdGNoT3V0bGluZTogKCkgPT4ge30sXG4gICAgICBjbG9zZU91dGxpbmU6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RleHRGaWVsZEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICogQHBhcmFtIHshRm91bmRhdGlvbk1hcFR5cGU9fSBmb3VuZGF0aW9uTWFwIE1hcCBmcm9tIHN1YmNvbXBvbmVudCBuYW1lcyB0byB0aGVpciBzdWJmb3VuZGF0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIGZvdW5kYXRpb25NYXAgPSAvKiogQHR5cGUgeyFGb3VuZGF0aW9uTWFwVHlwZX0gKi8gKHt9KSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGV4dEZpZWxkRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb258dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaGVscGVyVGV4dF8gPSBmb3VuZGF0aW9uTWFwLmhlbHBlclRleHQ7XG4gICAgLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb258dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaWNvbl8gPSBmb3VuZGF0aW9uTWFwLmljb247XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc0ZvY3VzZWRfID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMucmVjZWl2ZWRVc2VySW5wdXRfID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMudXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ18gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc1ZhbGlkXyA9IHRydWU7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmFjdGl2YXRlRm9jdXMoKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmlucHV0Qmx1ckhhbmRsZXJfID0gKCkgPT4gdGhpcy5kZWFjdGl2YXRlRm9jdXMoKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmlucHV0SW5wdXRIYW5kbGVyXyA9ICgpID0+IHRoaXMuYXV0b0NvbXBsZXRlRm9jdXMoKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnNldFBvaW50ZXJYT2Zmc2V0XyA9IChldnQpID0+IHRoaXMuc2V0VHJhbnNmb3JtT3JpZ2luKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy50ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbigpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUFycmF5KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXJfID0gKG11dGF0aW9ucykgPT4gdGhpcy5oYW5kbGVWYWxpZGF0aW9uQXR0cmlidXRlTXV0YXRpb24obXV0YXRpb25zKTtcbiAgICAvKiogQHByaXZhdGUgeyFNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgIHRoaXMudmFsaWRhdGlvbk9ic2VydmVyXztcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIC8vIEVuc3VyZSBsYWJlbCBkb2VzIG5vdCBjb2xsaWRlIHdpdGggYW55IHByZS1maWxsZWQgdmFsdWUuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSAmJiB0aGlzLmdldFZhbHVlKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbCh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICAgIHRoaXMubm90Y2hPdXRsaW5lKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXygpO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdpbnB1dCcsIHRoaXMuaW5wdXRJbnB1dEhhbmRsZXJfKTtcbiAgICBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuc2V0UG9pbnRlclhPZmZzZXRfKTtcbiAgICB9KTtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy52YWxpZGF0aW9uT2JzZXJ2ZXJfID0gdGhpcy5hZGFwdGVyXy5yZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKFxuICAgICAgdGhpcy52YWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2lucHV0JywgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8pO1xuICAgIFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnNldFBvaW50ZXJYT2Zmc2V0Xyk7XG4gICAgfSk7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIodGhpcy52YWxpZGF0aW9uT2JzZXJ2ZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggdGhlIFRleHQgRmllbGQuXG4gICAqL1xuICBoYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbigpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROYXRpdmVJbnB1dCgpLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVjZWl2ZWRVc2VySW5wdXRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHZhbGlkYXRpb24gYXR0cmlidXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHshQXJyYXk8TXV0YXRpb25SZWNvcmQ+fSBtdXRhdGlvbnNMaXN0XG4gICAqL1xuICBoYW5kbGVWYWxpZGF0aW9uQXR0cmlidXRlTXV0YXRpb24obXV0YXRpb25zTGlzdCkge1xuICAgIG11dGF0aW9uc0xpc3Quc29tZSgobXV0YXRpb24pID0+IHtcbiAgICAgIGlmIChWQUxJREFUSU9OX0FUVFJfV0hJVEVMSVNULmluZGV4T2YobXV0YXRpb24uYXR0cmlidXRlTmFtZSkgPiAtMSkge1xuICAgICAgICB0aGlzLnN0eWxlVmFsaWRpdHlfKHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucy9jbG9zZXMgdGhlIG5vdGNoZWQgb3V0bGluZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuTm90Y2hcbiAgICovXG4gIG5vdGNoT3V0bGluZShvcGVuTm90Y2gpIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzT3V0bGluZSgpIHx8ICF0aGlzLmFkYXB0ZXJfLmhhc0xhYmVsKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3Blbk5vdGNoKSB7XG4gICAgICBjb25zdCBpc0RlbnNlID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkRFTlNFKTtcbiAgICAgIGNvbnN0IGxhYmVsU2NhbGUgPSBpc0RlbnNlID8gbnVtYmVycy5ERU5TRV9MQUJFTF9TQ0FMRSA6IG51bWJlcnMuTEFCRUxfU0NBTEU7XG4gICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRMYWJlbFdpZHRoKCkgKiBsYWJlbFNjYWxlO1xuICAgICAgY29uc3QgaXNSdGwgPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGNoT3V0bGluZShsYWJlbFdpZHRoLCBpc1J0bCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uY2xvc2VPdXRsaW5lKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgdGV4dCBmaWVsZCBmb2N1cyBzdGF0ZS5cbiAgICovXG4gIGFjdGl2YXRlRm9jdXMoKSB7XG4gICAgdGhpcy5pc0ZvY3VzZWRfID0gdHJ1ZTtcbiAgICB0aGlzLnN0eWxlRm9jdXNlZF8odGhpcy5pc0ZvY3VzZWRfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlTGluZVJpcHBsZSgpO1xuICAgIHRoaXMubm90Y2hPdXRsaW5lKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0xhYmVsKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2hha2VMYWJlbCh0aGlzLnNob3VsZFNoYWtlKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbCh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2hvd1RvU2NyZWVuUmVhZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpbmUgcmlwcGxlJ3MgdHJhbnNmb3JtIG9yaWdpbiwgc28gdGhhdCB0aGUgbGluZSByaXBwbGUgYWN0aXZhdGVcbiAgICogYW5pbWF0aW9uIHdpbGwgYW5pbWF0ZSBvdXQgZnJvbSB0aGUgdXNlcidzIGNsaWNrIGxvY2F0aW9uLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBzZXRUcmFuc2Zvcm1PcmlnaW4oZXZ0KSB7XG4gICAgY29uc3QgdGFyZ2V0Q2xpZW50UmVjdCA9IGV2dC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZXZ0Q29vcmRzID0ge3g6IGV2dC5jbGllbnRYLCB5OiBldnQuY2xpZW50WX07XG4gICAgY29uc3Qgbm9ybWFsaXplZFggPSBldnRDb29yZHMueCAtIHRhcmdldENsaWVudFJlY3QubGVmdDtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW4obm9ybWFsaXplZFgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgVGV4dCBGaWVsZCdzIGZvY3VzIHN0YXRlIGluIGNhc2VzIHdoZW4gdGhlIGlucHV0IHZhbHVlXG4gICAqIGNoYW5nZXMgd2l0aG91dCB1c2VyIGlucHV0IChlLmcuIHByb2dyYW1hdGljYWxseSkuXG4gICAqL1xuICBhdXRvQ29tcGxldGVGb2N1cygpIHtcbiAgICBpZiAoIXRoaXMucmVjZWl2ZWRVc2VySW5wdXRfKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlRm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIFRleHQgRmllbGQncyBmb2N1cyBzdGF0ZS5cbiAgICovXG4gIGRlYWN0aXZhdGVGb2N1cygpIHtcbiAgICB0aGlzLmlzRm9jdXNlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlYWN0aXZhdGVMaW5lUmlwcGxlKCk7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmdldE5hdGl2ZUlucHV0XygpO1xuICAgIGNvbnN0IHNob3VsZFJlbW92ZUxhYmVsRmxvYXQgPSAhaW5wdXQudmFsdWUgJiYgIXRoaXMuaXNCYWRJbnB1dF8oKTtcbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICB0aGlzLnN0eWxlRm9jdXNlZF8odGhpcy5pc0ZvY3VzZWRfKTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgICB0aGlzLm5vdGNoT3V0bGluZSh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFJlbW92ZUxhYmVsRmxvYXQpIHtcbiAgICAgIHRoaXMucmVjZWl2ZWRVc2VySW5wdXRfID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBFbGVtZW50LlxuICAgKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgb24gdGhlIGlucHV0IEVsZW1lbnQuXG4gICAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgICB0aGlzLm5vdGNoT3V0bGluZSh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgYSBjdXN0b20gdmFsaWRpdHkgaXMgc2V0LCByZXR1cm5zIHRoYXQgdmFsdWUuXG4gICAqICAgICBPdGhlcndpc2UsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBuYXRpdmUgdmFsaWRpdHkgY2hlY2tzLlxuICAgKi9cbiAgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nX1xuICAgICAgPyB0aGlzLmlzVmFsaWRfIDogdGhpcy5pc05hdGl2ZUlucHV0VmFsaWRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkIFNldHMgdGhlIHZhbGlkaXR5IHN0YXRlIG9mIHRoZSBUZXh0IEZpZWxkLlxuICAgKi9cbiAgc2V0VmFsaWQoaXNWYWxpZCkge1xuICAgIHRoaXMudXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ18gPSB0cnVlO1xuICAgIHRoaXMuaXNWYWxpZF8gPSBpc1ZhbGlkO1xuICAgIC8vIFJldHJpZXZlIGZyb20gdGhlIGdldHRlciB0byBlbnN1cmUgY29ycmVjdCBsb2dpYyBpcyBhcHBsaWVkLlxuICAgIGlzVmFsaWQgPSB0aGlzLmlzVmFsaWQoKTtcbiAgICB0aGlzLnN0eWxlVmFsaWRpdHlfKGlzVmFsaWQpO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0xhYmVsKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2hha2VMYWJlbCh0aGlzLnNob3VsZFNoYWtlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgVGV4dCBGaWVsZCBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCBTZXRzIHRoZSB0ZXh0LWZpZWxkIGRpc2FibGVkIG9yIGVuYWJsZWQuXG4gICAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB0aGlzLnN0eWxlRGlzYWJsZWRfKGRpc2FibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBoZWxwZXIgdGV4dC5cbiAgICovXG4gIHNldEhlbHBlclRleHRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5oZWxwZXJUZXh0Xykge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Xy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBUZXh0IEZpZWxkIGlucHV0IGZhaWxzIGluIGNvbnZlcnRpbmcgdGhlXG4gICAqICAgICB1c2VyLXN1cHBsaWVkIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNCYWRJbnB1dF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsaWRpdHkuYmFkSW5wdXQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlc3VsdCBvZiBuYXRpdmUgdmFsaWRpdHkgY2hlY2tpbmdcbiAgICogICAgIChWYWxpZGl0eVN0YXRlLnZhbGlkKS5cbiAgICovXG4gIGlzTmF0aXZlSW5wdXRWYWxpZF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsaWRpdHkudmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIHZhbGlkaXR5IHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlVmFsaWRpdHlfKGlzVmFsaWQpIHtcbiAgICBjb25zdCB7SU5WQUxJRH0gPSBNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoSU5WQUxJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoSU5WQUxJRCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNldFZhbGlkaXR5KGlzVmFsaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgZm9jdXNlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0ZvY3VzZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlRm9jdXNlZF8oaXNGb2N1c2VkKSB7XG4gICAgY29uc3Qge0ZPQ1VTRUR9ID0gTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc0ZvY3VzZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRk9DVVNFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRk9DVVNFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0Rpc2FibGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdHlsZURpc2FibGVkXyhpc0Rpc2FibGVkKSB7XG4gICAgY29uc3Qge0RJU0FCTEVELCBJTlZBTElEfSA9IE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKElOVkFMSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWNvbl8pIHtcbiAgICAgIHRoaXMuaWNvbl8uc2V0RGlzYWJsZWQoaXNEaXNhYmxlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFFbGVtZW50fCFOYXRpdmVJbnB1dFR5cGV9IFRoZSBuYXRpdmUgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICAgKiBob3N0IGVudmlyb25tZW50LCBvciBhIGR1bW15IGlmIG5vbmUgZXhpc3RzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlSW5wdXRfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUlucHV0KCkgfHxcbiAgICAvKiogQHR5cGUgeyFOYXRpdmVJbnB1dFR5cGV9ICovICh7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWxpZGl0eToge1xuICAgICAgICBiYWRJbnB1dDogZmFsc2UsXG4gICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBOb3RjaGVkIE91dGxpbmUuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgTm90Y2hlZCBPdXRsaW5lIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXIge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge31cblxuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBcImRcIiBhdHRyaWJ1dGUgb2YgdGhlIG91dGxpbmUgZWxlbWVudCdzIFNWRyBwYXRoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldE91dGxpbmVQYXRoQXR0cih2YWx1ZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWRsZSBvdXRsaW5lIGVsZW1lbnQncyBjb21wdXRlZCBzdHlsZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY3NzIHByb3BlcnR5IGBwcm9wZXJ0eU5hbWVgLlxuICAgKiBXZSBhY2hpZXZlIHRoaXMgdmlhIGBnZXRDb21wdXRlZFN0eWxlKC4uLikuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUocHJvcGVydHlOYW1lKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBQQVRIX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmVfX3BhdGgnLFxuICBJRExFX09VVExJTkVfU0VMRUNUT1I6ICcubWRjLW5vdGNoZWQtb3V0bGluZV9faWRsZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIE9VVExJTkVfTk9UQ0hFRDogJ21kYy1ub3RjaGVkLW91dGxpbmUtLW5vdGNoZWQnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXJ9ICovICh7XG4gICAgICBnZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBnZXRIZWlnaHQ6ICgpID0+IHt9LFxuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0T3V0bGluZVBhdGhBdHRyOiAoKSA9PiB7fSxcbiAgICAgIGdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZTogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBvdXRsaW5lIG5vdGNoZWQgc2VsZWN0b3IgYW5kIHVwZGF0ZXMgdGhlIG5vdGNoIHdpZHRoXG4gICAqIGNhbGN1bGF0ZWQgYmFzZWQgb2ZmIG9mIG5vdGNoV2lkdGggYW5kIGlzUnRsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbm90Y2hXaWR0aFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1J0bFxuICAgKi9cbiAgbm90Y2gobm90Y2hXaWR0aCwgaXNSdGwgPSBmYWxzZSkge1xuICAgIGNvbnN0IHtPVVRMSU5FX05PVENIRUR9ID0gTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhPVVRMSU5FX05PVENIRUQpO1xuICAgIHRoaXMudXBkYXRlU3ZnUGF0aF8obm90Y2hXaWR0aCwgaXNSdGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbm90Y2hlZCBvdXRsaW5lIHNlbGVjdG9yIHRvIGNsb3NlIHRoZSBub3RjaCBpbiB0aGUgb3V0bGluZS5cbiAgICovXG4gIGNsb3NlTm90Y2goKSB7XG4gICAgY29uc3Qge09VVExJTkVfTk9UQ0hFRH0gPSBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE9VVExJTkVfTk9UQ0hFRCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgU1ZHIHBhdGggb2YgdGhlIGZvY3VzIG91dGxpbmUgZWxlbWVudCBiYXNlZCBvbiB0aGUgbm90Y2hXaWR0aFxuICAgKiBhbmQgdGhlIFJUTCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbm90Y2hXaWR0aFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1J0bFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlU3ZnUGF0aF8obm90Y2hXaWR0aCwgaXNSdGwpIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyBhIHNwZWNpZmljIGNvcm5lcidzIHN0eWxlIGJlY2F1c2UgRmlyZWZveCBkb2Vzbid0IHJlcG9ydCB0aGUgc3R5bGUgb24gYm9yZGVyLXJhZGl1cy5cbiAgICBjb25zdCByYWRpdXNTdHlsZVZhbHVlID0gdGhpcy5hZGFwdGVyXy5nZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUoJ2JvcmRlci1yYWRpdXMnKSB8fFxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZSgnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycpO1xuICAgIGNvbnN0IHJhZGl1cyA9IHBhcnNlRmxvYXQocmFkaXVzU3R5bGVWYWx1ZSk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5hZGFwdGVyXy5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCBjb3JuZXJXaWR0aCA9IHJhZGl1cyArIDEuMjtcbiAgICBjb25zdCBsZWFkaW5nU3Ryb2tlTGVuZ3RoID0gTWF0aC5hYnMoMTEgLSBjb3JuZXJXaWR0aCk7XG4gICAgY29uc3QgcGFkZGVkTm90Y2hXaWR0aCA9IG5vdGNoV2lkdGggKyA4O1xuXG4gICAgLy8gVGhlIHJpZ2h0LCBib3R0b20sIGFuZCBsZWZ0IHNpZGVzIG9mIHRoZSBvdXRsaW5lIGZvbGxvdyB0aGUgc2FtZSBTVkcgcGF0aC5cbiAgICBjb25zdCBwYXRoTWlkZGxlID0gJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgcmFkaXVzICsgJywnICsgcmFkaXVzXG4gICAgICArICd2JyArIChoZWlnaHQgLSAoMiAqIGNvcm5lcldpZHRoKSlcbiAgICAgICsgJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgLXJhZGl1cyArICcsJyArIHJhZGl1c1xuICAgICAgKyAnaCcgKyAoLXdpZHRoICsgKDIgKiBjb3JuZXJXaWR0aCkpXG4gICAgICArICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIC1yYWRpdXMgKyAnLCcgKyAtcmFkaXVzXG4gICAgICArICd2JyArICgtaGVpZ2h0ICsgKDIgKiBjb3JuZXJXaWR0aCkpXG4gICAgICArICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIHJhZGl1cyArICcsJyArIC1yYWRpdXM7XG5cbiAgICBsZXQgcGF0aDtcbiAgICBpZiAoIWlzUnRsKSB7XG4gICAgICBwYXRoID0gJ00nICsgKGNvcm5lcldpZHRoICsgbGVhZGluZ1N0cm9rZUxlbmd0aCArIHBhZGRlZE5vdGNoV2lkdGgpICsgJywnICsgMVxuICAgICAgICArICdoJyArICh3aWR0aCAtICgyICogY29ybmVyV2lkdGgpIC0gcGFkZGVkTm90Y2hXaWR0aCAtIGxlYWRpbmdTdHJva2VMZW5ndGgpXG4gICAgICAgICsgcGF0aE1pZGRsZVxuICAgICAgICArICdoJyArIGxlYWRpbmdTdHJva2VMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSAnTScgKyAod2lkdGggLSBjb3JuZXJXaWR0aCAtIGxlYWRpbmdTdHJva2VMZW5ndGgpICsgJywnICsgMVxuICAgICAgICArICdoJyArIGxlYWRpbmdTdHJva2VMZW5ndGhcbiAgICAgICAgKyBwYXRoTWlkZGxlXG4gICAgICAgICsgJ2gnICsgKHdpZHRoIC0gKDIgKiBjb3JuZXJXaWR0aCkgLSBwYWRkZWROb3RjaFdpZHRoIC0gbGVhZGluZ1N0cm9rZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRPdXRsaW5lUGF0aEF0dHIocGF0aCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOnN0eWxlPVwie3dpZHRoOmZ1bGx3aWR0aD8nMTAwJSc6dW5kZWZpbmVkfVwiXG4gICAgOmlkPVwiaWRcIlxuICAgIGNsYXNzPVwibWRjLXRleHRmaWVsZC13cmFwcGVyXCI+XG5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJyb290XCJcbiAgICAgIDpjbGFzcz1cInJvb3RDbGFzc2VzXCI+XG5cbiAgICAgIDxpXG4gICAgICAgIHYtaWY9XCIhIWhhc0xlYWRpbmdJY29uXCJcbiAgICAgICAgcmVmPVwiaWNvblwiXG4gICAgICAgIDpjbGFzcz1cImhhc0xlYWRpbmdJY29uLmNsYXNzZXNcIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICBjbGFzcz1cIm1kYy10ZXh0LWZpZWxkX19pY29uXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJsZWFkaW5nLWljb25cIj57eyBoYXNMZWFkaW5nSWNvbi5jb250ZW50IH19PC9zbG90PlxuICAgICAgPC9pPlxuXG4gICAgICA8IS0tIHdvcmthcnJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvcm9sbHVwLXBsdWdpbi12dWUvaXNzdWVzLzE3NCAtLT5cbiAgICAgIDwhLS0gZXNsaW50LWRpc2FibGUgdnVlL2h0bWwtc2VsZi1jbG9zaW5nIC0tPlxuICAgICAgPHRleHRhcmVhXG4gICAgICAgIHYtaWY9XCJtdWx0aWxpbmVcIlxuICAgICAgICByZWY9XCJpbnB1dFwiXG4gICAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgOmNsYXNzPVwiaW5wdXRDbGFzc2VzXCJcbiAgICAgICAgOm1pbmxlbmd0aD1cIm1pbmxlbmd0aFwiXG4gICAgICAgIDptYXhsZW5ndGg9XCJtYXhsZW5ndGhcIlxuICAgICAgICA6cGxhY2Vob2xkZXI9XCJpbnB1dFBsYWNlSG9sZGVyXCJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJpbnB1dFBsYWNlSG9sZGVyXCJcbiAgICAgICAgOmFyaWEtY29udHJvbHM9XCJpbnB1dEFyaWFDb250cm9sc1wiXG4gICAgICAgIDpyb3dzPVwicm93c1wiXG4gICAgICAgIDpjb2xzPVwiY29sc1wiXG4gICAgICAgIHYtb249XCIkbGlzdGVuZXJzXCJcbiAgICAgICAgQGlucHV0PVwidXBkYXRlVmFsdWUoJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxuICAgICAgPjwvdGV4dGFyZWE+XG5cbiAgICAgIDxpbnB1dFxuICAgICAgICB2LWVsc2VcbiAgICAgICAgcmVmPVwiaW5wdXRcIlxuICAgICAgICB2LWJpbmQ9XCIkYXR0cnNcIlxuICAgICAgICA6aWQ9XCJ2bWFfdWlkX1wiXG4gICAgICAgIDpjbGFzcz1cImlucHV0Q2xhc3Nlc1wiXG4gICAgICAgIDp0eXBlPVwidHlwZVwiXG4gICAgICAgIDptaW5sZW5ndGg9XCJtaW5sZW5ndGhcIlxuICAgICAgICA6bWF4bGVuZ3RoPVwibWF4bGVuZ3RoXCJcbiAgICAgICAgOnBsYWNlaG9sZGVyPVwiaW5wdXRQbGFjZUhvbGRlclwiXG4gICAgICAgIDphcmlhLWxhYmVsPVwiaW5wdXRQbGFjZUhvbGRlclwiXG4gICAgICAgIDphcmlhLWNvbnRyb2xzPVwiaW5wdXRBcmlhQ29udHJvbHNcIlxuICAgICAgICB2LW9uPVwiJGxpc3RlbmVyc1wiXG4gICAgICAgIEBpbnB1dD1cInVwZGF0ZVZhbHVlKCRldmVudC50YXJnZXQudmFsdWUpXCJcbiAgICAgID5cblxuICAgICAgPGxhYmVsXG4gICAgICAgIHYtaWY9XCJoYXNMYWJlbFwiXG4gICAgICAgIHJlZj1cImxhYmVsXCJcbiAgICAgICAgOmNsYXNzPVwibGFiZWxDbGFzc2VzVXBncmFkZWRcIlxuICAgICAgICA6Zm9yPVwidm1hX3VpZF9cIj5cbiAgICAgICAge3sgbGFiZWwgfX1cbiAgICAgIDwvbGFiZWw+XG5cbiAgICAgIDxpXG4gICAgICAgIHYtaWY9XCIhIWhhc1RyYWlsaW5nSWNvblwiXG4gICAgICAgIHJlZj1cImljb25cIlxuICAgICAgICA6Y2xhc3M9XCJoYXNUcmFpbGluZ0ljb24uY2xhc3Nlc1wiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX2ljb25cIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cInRyYWlsaW5nLWljb25cIj57eyBoYXNUcmFpbGluZ0ljb24uY29udGVudCB9fTwvc2xvdD5cbiAgICAgIDwvaT5cblxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwiaGFzT3V0bGluZVwiXG4gICAgICAgIHJlZj1cIm91dGxpbmVcIlxuICAgICAgICA6Y2xhc3M9XCJvdXRsaW5lQ2xhc3Nlc1wiXG4gICAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZVwiPlxuICAgICAgICA8c3ZnPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICA6ZD1cIm91dGxpbmVQYXRoQXR0clwiXG4gICAgICAgICAgICBjbGFzcz1cIm1kYy1ub3RjaGVkLW91dGxpbmVfX3BhdGhcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwiaGFzT3V0bGluZVwiXG4gICAgICAgIHJlZj1cIm91dGxpbmVJZGxlXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lX19pZGxlXCIvPlxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwiaGFzTGluZVJpcHBsZVwiXG4gICAgICAgIHJlZj1cImxpbmVSaXBwbGVcIlxuICAgICAgICA6Y2xhc3M9XCJsaW5lUmlwcGxlQ2xhc3Nlc1wiXG4gICAgICAgIDpzdHlsZT1cImxpbmVSaXBwbGVTdHlsZXNcIi8+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxwXG4gICAgICB2LWlmPVwiaGVscHRleHRcIlxuICAgICAgcmVmPVwiaGVscFwiXG4gICAgICA6aWQ9XCInaGVscC0nK3ZtYV91aWRfXCJcbiAgICAgIDpjbGFzcz1cImhlbHBDbGFzc2VzXCJcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAge3sgaGVscHRleHQgfX1cbiAgICA8L3A+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RleHRmaWVsZEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lLXJpcHBsZS9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvaGVscGVyLXRleHQvZm91bmRhdGlvbidcbmltcG9ydCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL2ljb24vZm91bmRhdGlvbidcbmltcG9ydCBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvZm91bmRhdGlvbidcbmltcG9ydCBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9mb3VuZGF0aW9uJ1xuXG5pbXBvcnQge1xuICBleHRyYWN0SWNvblByb3AsXG4gIERpc3BhdGNoRm9jdXNNaXhpbixcbiAgQ3VzdG9tRWxlbWVudE1peGluLFxuICBWTUFVbmlxdWVJZE1peGluLFxuICBhcHBseVBhc3NpdmVcbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10ZXh0ZmllbGQnLFxuICBtaXhpbnM6IFtDdXN0b21FbGVtZW50TWl4aW4sIERpc3BhdGNoRm9jdXNNaXhpbiwgVk1BVW5pcXVlSWRNaXhpbl0sXG4gIGluaGVyaXRBdHRyczogZmFsc2UsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3ZhbHVlJyxcbiAgICBldmVudDogJ21vZGVsJ1xuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3RleHQnLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICdlbWFpbCcsXG4gICAgICAgICAgICAnc2VhcmNoJyxcbiAgICAgICAgICAgICdwYXNzd29yZCcsXG4gICAgICAgICAgICAndGVsJyxcbiAgICAgICAgICAgICd1cmwnLFxuICAgICAgICAgICAgJ251bWJlcidcbiAgICAgICAgICBdLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSxcbiAgICBkZW5zZTogQm9vbGVhbixcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIGhlbHB0ZXh0OiBTdHJpbmcsXG4gICAgaGVscHRleHRQZXJzaXN0ZW50OiBCb29sZWFuLFxuICAgIGhlbHB0ZXh0VmFsaWRhdGlvbjogQm9vbGVhbixcbiAgICBib3g6IEJvb2xlYW4sXG4gICAgb3V0bGluZTogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICByZXF1aXJlZDogQm9vbGVhbixcbiAgICB2YWxpZDogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB1bmRlZmluZWQgfSxcbiAgICBmdWxsd2lkdGg6IEJvb2xlYW4sXG4gICAgbXVsdGlsaW5lOiBCb29sZWFuLFxuICAgIGxlYWRpbmdJY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICB0cmFpbGluZ0ljb246IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgIHNpemU6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMjAgfSxcbiAgICBtaW5sZW5ndGg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXG4gICAgbWF4bGVuZ3RoOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IHVuZGVmaW5lZCB9LFxuICAgIHJvd3M6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogOCB9LFxuICAgIGNvbHM6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogNDAgfSxcbiAgICBpZDogeyB0eXBlOiBTdHJpbmcgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogdGhpcy52YWx1ZSxcbiAgICAgIHJvb3RDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGV4dGZpZWxkJzogdHJ1ZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkJzogdHJ1ZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS11cGdyYWRlZCc6IHRydWUsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tZGlzYWJsZWQnOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWRlbnNlJzogdGhpcy5kZW5zZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1mdWxsd2lkdGgnOiB0aGlzLmZ1bGx3aWR0aCxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS10ZXh0YXJlYSc6IHRoaXMubXVsdGlsaW5lLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWJveCc6ICF0aGlzLmZ1bGx3aWR0aCAmJiB0aGlzLmJveCxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1vdXRsaW5lZCc6ICF0aGlzLmZ1bGx3aWR0aCAmJiB0aGlzLm91dGxpbmVcbiAgICAgIH0sXG4gICAgICBpbnB1dENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkX19pbnB1dCc6IHRydWVcbiAgICAgIH0sXG4gICAgICBsYWJlbENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1mbG9hdGluZy1sYWJlbCc6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5lUmlwcGxlQ2xhc3Nlczoge1xuICAgICAgICAnbWRjLWxpbmUtcmlwcGxlJzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmVSaXBwbGVTdHlsZXM6IHt9LFxuICAgICAgaGVscENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0JzogdHJ1ZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS1wZXJzaXN0ZW50JzogdGhpcy5oZWxwdGV4dFBlcnNpc3RlbnQsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tdmFsaWRhdGlvbi1tc2cnOiB0aGlzLmhlbHB0ZXh0VmFsaWRhdGlvblxuICAgICAgfSxcbiAgICAgIG91dGxpbmVDbGFzc2VzOiB7fSxcbiAgICAgIG91dGxpbmVQYXRoQXR0cjogdW5kZWZpbmVkXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlucHV0UGxhY2VIb2xkZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mdWxsd2lkdGggPyB0aGlzLmxhYmVsIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBpbnB1dEFyaWFDb250cm9scygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlbHAgPyAnaGVscC0nICsgdGhpcy52bWFfdWlkXyA6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgaGFzTGFiZWwoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMubGFiZWxcbiAgICB9LFxuICAgIGhhc091dGxpbmUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMub3V0bGluZVxuICAgIH0sXG4gICAgaGFzTGluZVJpcHBsZSgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXNPdXRsaW5lICYmICF0aGlzLm11bHRpbGluZVxuICAgIH0sXG4gICAgaGFzTGVhZGluZ0ljb24oKSB7XG4gICAgICBpZiAoXG4gICAgICAgICh0aGlzLmxlYWRpbmdJY29uIHx8IHRoaXMuJHNsb3RzWydsZWFkaW5nLWljb24nXSkgJiZcbiAgICAgICAgISh0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLiRzbG90c1sndHJhaWxpbmctaWNvbiddKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlYWRpbmdJY29uID8gZXh0cmFjdEljb25Qcm9wKHRoaXMubGVhZGluZ0ljb24pIDoge31cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG4gICAgaGFzVHJhaWxpbmdJY29uKCkge1xuICAgICAgaWYgKHRoaXMudHJhaWxpbmdJY29uIHx8IHRoaXMuJHNsb3RzWyd0cmFpbGluZy1pY29uJ10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhaWxpbmdJY29uID8gZXh0cmFjdEljb25Qcm9wKHRoaXMudHJhaWxpbmdJY29uKSA6IHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9LFxuICAgIGxhYmVsQ2xhc3Nlc1VwZ3JhZGVkKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5sYWJlbENsYXNzZXMsIHtcbiAgICAgICAgJ21kYy1mbG9hdGluZy1sYWJlbC0tZmxvYXQtYWJvdmUnOiB0aGlzLnZhbHVlXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBkaXNhYmxlZCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB9LFxuICAgIHJlcXVpcmVkKCkge1xuICAgICAgdGhpcy4kcmVmcy5pbnB1dCAmJiAodGhpcy4kcmVmcy5pbnB1dC5yZXF1aXJlZCA9IHRoaXMucmVxdWlyZWQpXG4gICAgfSxcbiAgICB2YWxpZCgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy52YWxpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXRWYWxpZCh0aGlzLnZhbGlkKVxuICAgICAgfVxuICAgIH0sXG4gICAgZGVuc2UoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgJ21kYy10ZXh0LWZpZWxkLS1kZW5zZScsIHRoaXMuZGVuc2UpXG4gICAgfSxcbiAgICBoZWxwdGV4dFBlcnNpc3RlbnQoKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uICYmXG4gICAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uc2V0UGVyc2lzdGVudCh0aGlzLmhlbHB0ZXh0UGVyc2lzdGVudClcbiAgICB9LFxuICAgIGhlbHB0ZXh0VmFsaWRhdGlvbigpIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiZcbiAgICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5zZXRWYWxpZGF0aW9uKHRoaXMuaGVscHRleHRWYWxpZGF0aW9uKVxuICAgIH0sXG4gICAgdmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmZvdW5kYXRpb24pIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSkge1xuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBpZiAodGhpcy4kcmVmcy5saW5lUmlwcGxlKSB7XG4gICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uKHtcbiAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMubGluZVJpcHBsZUNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMubGluZVJpcHBsZUNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5saW5lUmlwcGxlLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldFN0eWxlOiAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5saW5lUmlwcGxlU3R5bGVzLCBuYW1lLCB2YWx1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5saW5lUmlwcGxlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgICAgfSxcbiAgICAgICAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxpbmVSaXBwbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5pbml0KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kcmVmcy5oZWxwKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uKHtcbiAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMuaGVscENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuaGVscENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuaGVscC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBzZXRBdHRyOiAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmhlbHAuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBdHRyOiBuYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmhlbHAucmVtb3ZlQXR0cmlidXRlKG5hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldENvbnRlbnQ6ICgvKmNvbnRlbnQqLykgPT4ge1xuICAgICAgICAgIC8vIGhlbHAgdGV4dCBnZXQncyB1cGRhdGVkIGZyb20ge3toZWxwdGV4dH19XG4gICAgICAgICAgLy8gdGhpcy4kcmVmcy5oZWxwLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJHJlZnMuaWNvbikge1xuICAgICAgaWYgKHRoaXMuaGFzTGVhZGluZ0ljb24pIHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0td2l0aC1sZWFkaW5nLWljb24nLCB0cnVlKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc1RyYWlsaW5nSWNvbikge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgJ21kYy10ZXh0LWZpZWxkLS13aXRoLXRyYWlsaW5nLWljb24nLCB0cnVlKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmljb25Gb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uKHtcbiAgICAgICAgc2V0QXR0cjogKGF0dHIsIHZhbHVlKSA9PiB0aGlzLiRyZWZzLmljb24uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcbiAgICAgICAgZ2V0QXR0cjogYXR0ciA9PiB0aGlzLiRyZWZzLmljb24uZ2V0QXR0cmlidXRlKGF0dHIpLFxuICAgICAgICByZW1vdmVBdHRyOiBhdHRyID0+IHRoaXMuJHJlZnMuaWNvbi5yZW1vdmVBdHRyaWJ1dGUoYXR0ciksXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaWNvbi5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5pY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgICAgfSxcbiAgICAgICAgbm90aWZ5SWNvbkFjdGlvbjogKCkgPT4gdGhpcy4kZW1pdCgnaWNvbi1hY3Rpb24nKVxuICAgICAgfSlcbiAgICAgIHRoaXMuaWNvbkZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJHJlZnMubGFiZWwpIHtcbiAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uID0gbmV3IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uKHtcbiAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMubGFiZWxDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBnZXRXaWR0aDogKCkgPT4gdGhpcy4kcmVmcy5sYWJlbC5vZmZzZXRXaWR0aCxcbiAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLmxhYmVsRm91bmRhdGlvbi5pbml0KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kcmVmcy5vdXRsaW5lKSB7XG4gICAgICB0aGlzLm91dGxpbmVGb3VuZGF0aW9uID0gbmV3IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbih7XG4gICAgICAgIGdldFdpZHRoOiAoKSA9PiB0aGlzLiRyZWZzLm91dGxpbmUub2Zmc2V0V2lkdGgsXG4gICAgICAgIGdldEhlaWdodDogKCkgPT4gdGhpcy4kcmVmcy5vdXRsaW5lLm9mZnNldEhlaWdodCxcbiAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMub3V0bGluZUNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMub3V0bGluZUNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0T3V0bGluZVBhdGhBdHRyOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgdGhpcy5vdXRsaW5lUGF0aEF0dHIgPSB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWU6IHByb3BlcnR5TmFtZSA9PiB7XG4gICAgICAgICAgY29uc3QgaWRsZU91dGxpbmVFbGVtZW50ID0gdGhpcy4kcmVmcy5vdXRsaW5lSWRsZVxuICAgICAgICAgIGlmIChpZGxlT3V0bGluZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3dcbiAgICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUoaWRsZU91dGxpbmVFbGVtZW50KVxuICAgICAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5pbml0KClcbiAgICB9XG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDVGV4dGZpZWxkRm91bmRhdGlvbihcbiAgICAgIHtcbiAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMucm9vdENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMucm9vdC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgICAgfSxcbiAgICAgICAgaXNGb2N1c2VkOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJHJlZnMuaW5wdXRcbiAgICAgICAgfSxcbiAgICAgICAgaXNSdGw6ICgpID0+XG4gICAgICAgICAgd2luZG93XG4gICAgICAgICAgICAuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRyZWZzLnJvb3QpXG4gICAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnLFxuICAgICAgICBkZWFjdGl2YXRlTGluZVJpcHBsZTogKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmRlYWN0aXZhdGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24uYWN0aXZhdGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbjogbm9ybWFsaXplZFggPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLnNldFJpcHBsZUNlbnRlcihub3JtYWxpemVkWClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZXIpXG4gICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuJHJlZnMuaW5wdXRcbiAgICAgICAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUgfVxuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0Tm9kZSwgY29uZmlnKVxuICAgICAgICAgIHJldHVybiBvYnNlcnZlclxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXI6IG9ic2VydmVyID0+IHtcbiAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgfSxcbiAgICAgICAgc2hha2VMYWJlbDogc2hvdWxkU2hha2UgPT4ge1xuICAgICAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLnNoYWtlKHNob3VsZFNoYWtlKVxuICAgICAgICB9LFxuICAgICAgICBmbG9hdExhYmVsOiBzaG91bGRGbG9hdCA9PiB7XG4gICAgICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uZmxvYXQoc2hvdWxkRmxvYXQpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0xhYmVsOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVmcy5sYWJlbFxuICAgICAgICB9LFxuICAgICAgICBnZXRMYWJlbFdpZHRoOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3VuZGF0aW9uLmdldFdpZHRoKClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TmF0aXZlSW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dFxuICAgICAgICB9LFxuICAgICAgICBoYXNPdXRsaW5lOiAoKSA9PiAhIXRoaXMuaGFzT3V0bGluZSxcbiAgICAgICAgbm90Y2hPdXRsaW5lOiAobm90Y2hXaWR0aCwgaXNSdGwpID0+XG4gICAgICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5ub3RjaChub3RjaFdpZHRoLCBpc1J0bCksXG4gICAgICAgIGNsb3NlT3V0bGluZTogKCkgPT4gdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5jbG9zZU5vdGNoKClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGhlbHBlclRleHQ6IHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24sXG4gICAgICAgIGljb246IHRoaXMuaWNvbkZvdW5kYXRpb25cbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHRoaXMudmFsdWUpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgdGhpcy4kcmVmcy5pbnB1dCAmJiAodGhpcy4kcmVmcy5pbnB1dC5yZXF1aXJlZCA9IHRoaXMucmVxdWlyZWQpXG4gICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbGlkKHRoaXMudmFsaWQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGV4dGJveCkge1xuICAgICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbiAmJiB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiYgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmljb25Gb3VuZGF0aW9uICYmIHRoaXMuaWNvbkZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5sYWJlbEZvdW5kYXRpb24gJiYgdGhpcy5sYWJlbEZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiAmJiB0aGlzLm91dGxpbmVGb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ21vZGVsJywgdmFsdWUpXG4gICAgfSxcbiAgICBmb2N1cygpIHtcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpXG4gICAgfSxcbiAgICBibHVyKCkge1xuICAgICAgdGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LmJsdXIoKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUZXh0RmllbGQgZnJvbSAnLi9tZGMtdGV4dGZpZWxkLnZ1ZSdcblxuZXhwb3J0IHsgbWRjVGV4dEZpZWxkIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RleHRGaWVsZFxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IFxuICAgIDp0YWc9XCJ0YWdcIiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy10aGVtZVwiPlxuICAgIDxzbG90IC8+XG4gIDwvY3VzdG9tLWVsZW1lbnQ+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnLi4vYmFzZSdcblxuY29uc3QgVEhFTUVfQ09MT1JTID0gW1xuICAncHJpbWFyeScsXG4gICdzZWNvbmRhcnknLFxuICAnYmFja2dyb3VuZCcsXG4gICdwcmltYXJ5LWxpZ2h0JyxcbiAgJ3NlY29uZGFyeS1saWdodCcsXG4gICdzZWNvbmRhcnktZGFyaycsXG4gICdwcmltYXJ5LWRhcmsnXG5dXG5cbmNvbnN0IFRIRU1FX1NUWUxFUyA9IFtcbiAgJ3RleHQtcHJpbWFyeScsXG4gICd0ZXh0LXNlY29uZGFyeScsXG4gICd0ZXh0LWhpbnQnLFxuICAndGV4dC1pY29uJyxcbiAgJ3RleHQtZGlzYWJsZWQnXG5dXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10aGVtZScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21FbGVtZW50XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdGFnOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2RpdicgfSxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmQ6IFN0cmluZ1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBsZXQgY2xhc3NlcyA9IHt9XG5cbiAgICAgIGlmICh0aGlzLmNvbG9yICYmIFRIRU1FX0NPTE9SUy5pbmRleE9mKHRoaXMuY29sb3IpICE9PSAtMSkge1xuICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5jb2xvcn1gXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCAmJiBUSEVNRV9DT0xPUlMuaW5kZXhPZih0aGlzLmJhY2tncm91bmQpICE9PSAtMSkge1xuICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5iYWNrZ3JvdW5kfS1iZ2BdID0gdHJ1ZVxuXG4gICAgICAgIGlmICh0aGlzLmNvbG9yICYmIFRIRU1FX1NUWUxFUy5pbmRleE9mKHRoaXMuY29sb3IpICE9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXNbYG1kYy10aGVtZS0tJHt0aGlzLmNvbG9yfS1vbi0ke3RoaXMuYmFja2dyb3VuZH1gXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVGhlbWUgZnJvbSAnLi9tZGMtdGhlbWUudnVlJ1xuXG5leHBvcnQgeyBtZGNUaGVtZSB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUaGVtZVxufSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBGSVhFRDogJ21kYy10b29sYmFyLS1maXhlZCcsXG4gIEZJWEVEX0xBU1RST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtbGFzdHJvdy1vbmx5JyxcbiAgRklYRURfQVRfTEFTVF9ST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtYXQtbGFzdC1yb3cnLFxuICBUT09MQkFSX1JPV19GTEVYSUJMRTogJ21kYy10b29sYmFyLS1mbGV4aWJsZScsXG4gIEZMRVhJQkxFX0RFRkFVTFRfQkVIQVZJT1I6ICdtZGMtdG9vbGJhci0tZmxleGlibGUtZGVmYXVsdC1iZWhhdmlvcicsXG4gIEZMRVhJQkxFX01BWDogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1zcGFjZS1tYXhpbWl6ZWQnLFxuICBGTEVYSUJMRV9NSU46ICdtZGMtdG9vbGJhci0tZmxleGlibGUtc3BhY2UtbWluaW1pemVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUSVRMRV9TRUxFQ1RPUjogJy5tZGMtdG9vbGJhcl9fdGl0bGUnLFxuICBJQ09OX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX19pY29uJyxcbiAgRklSU1RfUk9XX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX19yb3c6Zmlyc3QtY2hpbGQnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENUb29sYmFyOmNoYW5nZScsXG59O1xuXG5leHBvcnQgY29uc3QgbnVtYmVycyA9IHtcbiAgTUFYX1RJVExFX1NJWkU6IDIuMTI1LFxuICBNSU5fVElUTEVfU0laRTogMS4yNSxcbiAgVE9PTEJBUl9ST1dfSEVJR0hUOiA2NCxcbiAgVE9PTEJBUl9ST1dfTU9CSUxFX0hFSUdIVDogNTYsXG4gIFRPT0xCQVJfTU9CSUxFX0JSRUFLUE9JTlQ6IDYwMCxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVG9vbGJhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRWaWV3cG9ydFdpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldFZpZXdwb3J0U2Nyb2xsWTogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRIZWlnaHQ6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIG5vdGlmeUNoYW5nZTogKC8qIGV2dERhdGE6IHtmbGV4aWJsZUV4cGFuc2lvblJhdGlvOiBudW1iZXJ9ICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZUZvclRpdGxlRWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlRm9yRml4ZWRBZGp1c3RFbGVtZW50OiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMuY2hlY2tSb3dIZWlnaHRfKCk7XG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHRoaXMudXBkYXRlVG9vbGJhclN0eWxlc18oKTtcbiAgICB0aGlzLmNoZWNrUm93SGVpZ2h0RnJhbWVfID0gMDtcbiAgICB0aGlzLnNjcm9sbEZyYW1lXyA9IDA7XG4gICAgdGhpcy5leGVjdXRlZExhc3RDaGFuZ2VfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNhbGN1bGF0aW9uc18gPSB7XG4gICAgICB0b29sYmFyUm93SGVpZ2h0OiAwLFxuICAgICAgLy8gQ2FsY3VsYXRlZCBIZWlnaHQgcmF0aW8uIFdlIHVzZSByYXRpbyB0byBjYWxjdWxhdGUgY29ycmVzcG9uZGluZyBoZWlnaHRzIGluIHJlc2l6ZSBldmVudC5cbiAgICAgIHRvb2xiYXJSYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIHRvb2xiYXIgaGVpZ2h0IHRvIHJvdyBoZWlnaHRcbiAgICAgIGZsZXhpYmxlRXhwYW5zaW9uUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiBmbGV4aWJsZSBzcGFjZSBoZWlnaHQgdG8gcm93IGhlaWdodFxuICAgICAgbWF4VHJhbnNsYXRlWVJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgbWF4IHRvb2xiYXIgbW92ZSB1cCBkaXN0YW5jZSB0byByb3cgaGVpZ2h0XG4gICAgICBzY3JvbGxUaHJlc2hvbGRSYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIG1heCBzY3JvbGxUb3AgdGhhdCB3ZSBzaG91bGQgbGlzdGVuIHRvIHRvIHJvdyBoZWlnaHRcbiAgICAgIC8vIERlcml2ZWQgSGVpZ2h0cyBiYXNlZCBvbiB0aGUgYWJvdmUga2V5IHJhdGlvcy5cbiAgICAgIHRvb2xiYXJIZWlnaHQ6IDAsXG4gICAgICBmbGV4aWJsZUV4cGFuc2lvbkhlaWdodDogMCwgLy8gRmxleGlibGUgcm93IG1pbnVzIHRvb2xiYXIgaGVpZ2h0IChkZXJpdmVkKVxuICAgICAgbWF4VHJhbnNsYXRlWURpc3RhbmNlOiAwLCAvLyBXaGVuIHRvb2xiYXIgb25seSBmaXggbGFzdCByb3cgKGRlcml2ZWQpXG4gICAgICBzY3JvbGxUaHJlc2hvbGQ6IDAsXG4gICAgfTtcbiAgICAvLyBUb29sYmFyIGZpeGVkIGJlaGF2aW9yXG4gICAgLy8gSWYgdG9vbGJhciBpcyBmaXhlZFxuICAgIHRoaXMuZml4ZWRfID0gZmFsc2U7XG4gICAgLy8gSWYgZml4ZWQgaXMgdGFyZ2V0ZWQgb25seSBhdCB0aGUgbGFzdCByb3dcbiAgICB0aGlzLmZpeGVkTGFzdHJvd18gPSBmYWxzZTtcbiAgICAvLyBUb29sYmFyIGZsZXhpYmxlIGJlaGF2aW9yXG4gICAgLy8gSWYgdGhlIGZpcnN0IHJvdyBpcyBmbGV4aWJsZVxuICAgIHRoaXMuaGFzRmxleGlibGVSb3dfID0gZmFsc2U7XG4gICAgLy8gSWYgdXNlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgdGhpcy51c2VGbGV4RGVmYXVsdEJlaGF2aW9yXyA9IGZhbHNlO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmZpeGVkXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRCk7XG4gICAgdGhpcy5maXhlZExhc3Ryb3dfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEX0xBU1RST1cpICYgdGhpcy5maXhlZF87XG4gICAgdGhpcy5oYXNGbGV4aWJsZVJvd18gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVE9PTEJBUl9ST1dfRkxFWElCTEUpO1xuICAgIGlmICh0aGlzLmhhc0ZsZXhpYmxlUm93Xykge1xuICAgICAgdGhpcy51c2VGbGV4RGVmYXVsdEJlaGF2aW9yXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9ERUZBVUxUX0JFSEFWSU9SKTtcbiAgICB9XG4gICAgdGhpcy5pbml0S2V5UmF0aW9fKCk7XG4gICAgdGhpcy5zZXRLZXlIZWlnaHRzXygpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIodGhpcy5zY3JvbGxIYW5kbGVyXyk7XG4gIH1cblxuICB1cGRhdGVBZGp1c3RFbGVtZW50U3R5bGVzKCkge1xuICAgIGlmICh0aGlzLmZpeGVkXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudCgnbWFyZ2luLXRvcCcsIGAke3RoaXMuY2FsY3VsYXRpb25zXy50b29sYmFySGVpZ2h0fXB4YCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RmxleGlibGVFeHBhbnNpb25SYXRpb18oc2Nyb2xsVG9wKSB7XG4gICAgLy8gVG8gcHJldmVudCBkaXZpc2lvbiBieSB6ZXJvIHdoZW4gdGhlcmUgaXMgbm8gZmxleGlibGVFeHBhbnNpb25IZWlnaHRcbiAgICBjb25zdCBkZWx0YSA9IDAuMDAwMTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgMSAtIHNjcm9sbFRvcCAvICh0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQgKyBkZWx0YSkpO1xuICB9XG5cbiAgY2hlY2tSb3dIZWlnaHRfKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuY2hlY2tSb3dIZWlnaHRGcmFtZV8pO1xuICAgIHRoaXMuY2hlY2tSb3dIZWlnaHRGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5zZXRLZXlIZWlnaHRzXygpKTtcbiAgfVxuXG4gIHNldEtleUhlaWdodHNfKCkge1xuICAgIGNvbnN0IG5ld1Rvb2xiYXJSb3dIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodF8oKTtcbiAgICBpZiAobmV3VG9vbGJhclJvd0hlaWdodCAhPT0gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0ID0gbmV3VG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFySGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0ID1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZRGlzdGFuY2UgPVxuICAgICAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWVJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkID1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZFJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLnVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMoKTtcbiAgICAgIHRoaXMudXBkYXRlVG9vbGJhclN0eWxlc18oKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVUb29sYmFyU3R5bGVzXygpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjcm9sbEZyYW1lXyk7XG4gICAgdGhpcy5zY3JvbGxGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5hZGFwdGVyXy5nZXRWaWV3cG9ydFNjcm9sbFkoKTtcbiAgICAgIGNvbnN0IGhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQgPSB0aGlzLnNjcm9sbGVkT3V0T2ZUaHJlc2hvbGRfKHNjcm9sbFRvcCk7XG5cbiAgICAgIGlmIChoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkICYmIHRoaXMuZXhlY3V0ZWRMYXN0Q2hhbmdlXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPSB0aGlzLmdldEZsZXhpYmxlRXhwYW5zaW9uUmF0aW9fKHNjcm9sbFRvcCk7XG5cbiAgICAgIHRoaXMudXBkYXRlVG9vbGJhckZsZXhpYmxlU3RhdGVfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pO1xuICAgICAgaWYgKHRoaXMuZml4ZWRMYXN0cm93Xykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyhzY3JvbGxUb3ApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzRmxleGlibGVSb3dfKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRmxleGlibGVSb3dFbGVtZW50U3R5bGVzXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZWRMYXN0Q2hhbmdlXyA9IGhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQ7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSh7ZmxleGlibGVFeHBhbnNpb25SYXRpbzogZmxleGlibGVFeHBhbnNpb25SYXRpb30pO1xuICAgIH0pO1xuICB9XG5cbiAgc2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8oc2Nyb2xsVG9wKSB7XG4gICAgcmV0dXJuIHNjcm9sbFRvcCA+IHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGQ7XG4gIH1cblxuICBpbml0S2V5UmF0aW9fKCkge1xuICAgIGNvbnN0IHRvb2xiYXJSb3dIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodF8oKTtcbiAgICBjb25zdCBmaXJzdFJvd01heFJhdGlvID0gdGhpcy5hZGFwdGVyXy5nZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQoKSAvIHRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0SGVpZ2h0KCkgLyB0b29sYmFyUm93SGVpZ2h0O1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvblJhdGlvID0gZmlyc3RSb3dNYXhSYXRpbyAtIDE7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlSYXRpbyA9XG4gICAgICB0aGlzLmZpeGVkTGFzdHJvd18gPyB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvIC0gZmlyc3RSb3dNYXhSYXRpbyA6IDA7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZFJhdGlvID1cbiAgICAgICh0aGlzLmZpeGVkTGFzdHJvd18gPyB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvIDogZmlyc3RSb3dNYXhSYXRpbykgLSAxO1xuICB9XG5cbiAgZ2V0Um93SGVpZ2h0XygpIHtcbiAgICBjb25zdCBicmVha3BvaW50ID0gTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX01PQklMRV9CUkVBS1BPSU5UO1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldFZpZXdwb3J0V2lkdGgoKSA8IGJyZWFrcG9pbnQgP1xuICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX1JPV19NT0JJTEVfSEVJR0hUIDogTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX1JPV19IRUlHSFQ7XG4gIH1cblxuICB1cGRhdGVUb29sYmFyRmxleGlibGVTdGF0ZV8oZmxleGlibGVFeHBhbnNpb25SYXRpbykge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NQVgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NSU4pO1xuICAgIGlmIChmbGV4aWJsZUV4cGFuc2lvblJhdGlvID09PSAxKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUFYKTtcbiAgICB9IGVsc2UgaWYgKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPT09IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NSU4pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyhzY3JvbGxUb3ApIHtcbiAgICBjb25zdCB0cmFuc2xhdGVEaXN0YW5jZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKFxuICAgICAgc2Nyb2xsVG9wIC0gdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0LFxuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlEaXN0YW5jZSkpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGUoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGVZKCR7LXRyYW5zbGF0ZURpc3RhbmNlfXB4KWApO1xuXG4gICAgaWYgKHRyYW5zbGF0ZURpc3RhbmNlID09PSB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWURpc3RhbmNlKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRURfQVRfTEFTVF9ST1cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRURfQVRfTEFTVF9ST1cpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18oZmxleGlibGVFeHBhbnNpb25SYXRpbykge1xuICAgIGlmICh0aGlzLmZpeGVkXykge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0ICogZmxleGlibGVFeHBhbnNpb25SYXRpbztcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQoJ2hlaWdodCcsXG4gICAgICAgIGAke2hlaWdodCArIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRTdHlsZXNEZWZhdWx0QmVoYXZpb3JfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRTdHlsZXNEZWZhdWx0QmVoYXZpb3JfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pIHtcbiAgICBjb25zdCBtYXhUaXRsZVNpemUgPSBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLk1BWF9USVRMRV9TSVpFO1xuICAgIGNvbnN0IG1pblRpdGxlU2l6ZSA9IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuTUlOX1RJVExFX1NJWkU7XG4gICAgY29uc3QgY3VycmVudFRpdGxlU2l6ZSA9IChtYXhUaXRsZVNpemUgLSBtaW5UaXRsZVNpemUpICogZmxleGlibGVFeHBhbnNpb25SYXRpbyArIG1pblRpdGxlU2l6ZTtcblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQoJ2ZvbnQtc2l6ZScsIGAke2N1cnJlbnRUaXRsZVNpemV9cmVtYCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGhlYWRlciBjbGFzcz1cIm1kYy10b29sYmFyLXdyYXBwZXJcIj5cbiAgICA8IS0tVG9vbGJhci0tPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJyb290XCIgXG4gICAgICA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiIFxuICAgICAgOnN0eWxlPVwicm9vdFN0eWxlc1wiPlxuICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuICAgIDwhLS0gRml4ZWQgQWRqdXN0IEVsZW1lbnQtLT5cbiAgICA8ZGl2IFxuICAgICAgdi1pZj1cImZpeGVkIHx8IHdhdGVyZmFsbCB8fCBmaXhlZExhc3Ryb3dcIiBcbiAgICAgIHJlZj1cImZpeGVkLWFkanVzdFwiIFxuICAgICAgOnN0eWxlPVwiYWRqdXN0U3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLXRvb2xiYXItZml4ZWQtYWRqdXN0XCIvPlxuICA8L2hlYWRlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVG9vbGJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3Rvb2xiYXIvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXInLFxuICBwcm9wczoge1xuICAgIGZpeGVkOiBCb29sZWFuLFxuICAgIHdhdGVyZmFsbDogQm9vbGVhbixcbiAgICAnZml4ZWQtbGFzdHJvdyc6IEJvb2xlYW4sXG4gICAgZmxleGlibGU6IEJvb2xlYW4sXG4gICAgJ2ZsZXhpYmxlLWRlZmF1bHQnOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290Q2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRvb2xiYXInOiB0cnVlLFxuICAgICAgICAnbWRjLXRvb2xiYXItLWZpeGVkJzogdGhpcy5maXhlZCB8fCB0aGlzLndhdGVyZmFsbCB8fCB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgJ21kYy10b29sYmFyLS13YXRlcmZhbGwnOiB0aGlzLndhdGVyZmFsbCxcbiAgICAgICAgJ21kYy10b29sYmFyLS1maXhlZC1sYXN0cm93LW9ubHknOiB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgJ21kYy10b29sYmFyLS1mbGV4aWJsZSc6IHRoaXMuZmxleGlibGUsXG4gICAgICAgICdtZGMtdG9vbGJhci0tZmxleGlibGUtZGVmYXVsdC1iZWhhdmlvcic6XG4gICAgICAgICAgdGhpcy5mbGV4aWJsZSAmJiB0aGlzLmZsZXhpYmxlRGVmYXVsdFxuICAgICAgfSxcbiAgICAgIHJvb3RTdHlsZXM6IHt9LFxuICAgICAgYWRqdXN0U3R5bGVzOiB7XG4gICAgICAgIC8vIHRvIGF2b2lkIHRvcCBtYXJnaW4gY29sbGFwc2Ugd2l0aCA6YWZ0ZXIgZWxcbiAgICAgICAgLy8gMC4xIHB4IHNob3VsZCBiZSByb3VuZGVkIHRvIDBweFxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHRyaWNrXG4gICAgICAgIC8vIGhlaWdodDogJzAuMXB4J1xuICAgICAgfSxcbiAgICAgIGZvdW5kYXRpb246IG51bGxcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGdldFZpZXdwb3J0V2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICB9LFxuICAgICAgZ2V0Vmlld3BvcnRTY3JvbGxZOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgIH0sXG4gICAgICBnZXRPZmZzZXRIZWlnaHQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5vZmZzZXRIZWlnaHRcbiAgICAgIH0sXG4gICAgICBnZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQ6ICgpID0+IHtcbiAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5GSVJTVF9ST1dfU0VMRUNUT1JcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZWwgPyBlbC5vZmZzZXRIZWlnaHQgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldnREYXRhKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RTdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZUZvclRpdGxlRWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBsZXQgZWwgPSB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBNRENUb29sYmFyRm91bmRhdGlvbi5zdHJpbmdzLlRJVExFX1NFTEVDVE9SXG4gICAgICAgIClcbiAgICAgICAgaWYgKGVsKSBlbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5GSVJTVF9ST1dfU0VMRUNUT1JcbiAgICAgICAgKVxuICAgICAgICBpZiAoZWwpIGVsLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5hZGp1c3RTdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLXRvb2xiYXItcm93IG1kYy10b29sYmFyX19yb3dcIj5cbiAgICA8c2xvdC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLXJvdydcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgY2xhc3M9XCJtZGMtdG9vbGJhci1zZWN0aW9uIG1kYy10b29sYmFyX19zZWN0aW9uXCI+XG4gICAgPHNsb3QvPlxuICA8L3NlY3Rpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXItc2VjdGlvbicsXG4gIHByb3BzOiB7XG4gICAgJ2FsaWduLXN0YXJ0JzogQm9vbGVhbixcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnc2hyaW5rLXRvLWZpdCc6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRvb2xiYXJfX3NlY3Rpb24tLWFsaWduLXN0YXJ0JzogdGhpcy5hbGlnblN0YXJ0LFxuICAgICAgICAnbWRjLXRvb2xiYXJfX3NlY3Rpb24tLWFsaWduLWVuZCc6IHRoaXMuYWxpZ25FbmQsXG4gICAgICAgICdtZGMtdG9vbGJhcl9fc2VjdGlvbi0tc2hyaW5rLXRvLWZpdCc6IHRoaXMuc2hyaW5rVG9GaXRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICA6Y2xhc3M9XCJ7J21hdGVyaWFsLWljb25zJzohIWljb259XCJcbiAgICBjbGFzcz1cIm1kYy10b29sYmFyLW1lbnUtaWNvbiBtZGMtdG9vbGJhcl9fbWVudS1pY29uXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLW1lbnUtaWNvbicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdtZW51JyB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICBjbGFzcz1cIm1kYy10b29sYmFyLXRpdGxlIG1kYy10b29sYmFyX190aXRsZVwiIFxuICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cbiAgICA8c2xvdC8+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci10aXRsZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICA6Y2xhc3M9XCJ7J21hdGVyaWFsLWljb25zJzohIWljb259XCIgXG4gICAgY2xhc3M9XCJtZGMtdG9vbGJhci1pY29uIG1kYy10b29sYmFyX19pY29uXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLWljb24nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZ1xuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1Rvb2xiYXIgZnJvbSAnLi9tZGMtdG9vbGJhci52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclJvdyBmcm9tICcuL21kYy10b29sYmFyLXJvdy52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclNlY3Rpb24gZnJvbSAnLi9tZGMtdG9vbGJhci1zZWN0aW9uLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFyTWVudUljb24gZnJvbSAnLi9tZGMtdG9vbGJhci1tZW51LWljb24udnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJUaXRsZSBmcm9tICcuL21kYy10b29sYmFyLXRpdGxlLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFySWNvbiBmcm9tICcuL21kYy10b29sYmFyLWljb24udnVlJ1xuXG5leHBvcnQge1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgRklYRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkJyxcbiAgRklYRURfU0NST0xMRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkLXNjcm9sbGVkJyxcbiAgU0hPUlRfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0JyxcbiAgU0hPUlRfSEFTX0FDVElPTl9JVEVNX0NMQVNTOiAnbWRjLXRvcC1hcHAtYmFyLS1zaG9ydC1oYXMtYWN0aW9uLWl0ZW0nLFxuICBTSE9SVF9DT0xMQVBTRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0LWNvbGxhcHNlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIERFQk9VTkNFX1RIUk9UVExFX1JFU0laRV9USU1FX01TOiAxMDAsXG4gIE1BWF9UT1BfQVBQX0JBUl9IRUlHSFQ6IDEyOCxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQUNUSU9OX0lURU1fU0VMRUNUT1I6ICcubWRjLXRvcC1hcHAtYmFyX19hY3Rpb24taXRlbScsXG4gIE5BVklHQVRJT05fRVZFTlQ6ICdNRENUb3BBcHBCYXI6bmF2JyxcbiAgTkFWSUdBVElPTl9JQ09OX1NFTEVDVE9SOiAnLm1kYy10b3AtYXBwLWJhcl9fbmF2aWdhdGlvbi1pY29uJyxcbiAgUk9PVF9TRUxFQ1RPUjogJy5tZGMtdG9wLWFwcC1iYXInLFxuICBUSVRMRV9TRUxFQ1RPUjogJy5tZGMtdG9wLWFwcC1iYXJfX3RpdGxlJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3NlcywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRvcCBBcHAgQmFyXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVG9wIEFwcCBCYXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RvcEFwcEJhckFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgRWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3BlY2lmaWVkIGlubGluZSBzdHlsZSBwcm9wZXJ0eSBvbiB0aGUgcm9vdCBFbGVtZW50IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGUocHJvcGVydHksIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHRvcCBhcHAgYmFyLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUb3BBcHBCYXJIZWlnaHQoKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgbmF2aWdhdGlvbiBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIG5hdmlnYXRpb24gaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG5hdmlnYXRpb24gaWNvbiBpcyBjbGlja2VkLlxuICAgKi9cbiAgbm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkKCkge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRWaWV3cG9ydFNjcm9sbFkoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFRvdGFsQWN0aW9uSXRlbXMoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUb3BBcHBCYXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7c3RyaW5ncywgY3NzQ2xhc3NlcywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1RvcEFwcEJhckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUb3BBcHBCYXJBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDVG9wQXBwQmFyQmFzZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RvcEFwcEJhckFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVG9wQXBwQmFyQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9ICovICh7XG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZTogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0VG9wQXBwQmFySGVpZ2h0OiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZDogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0VG90YWxBY3Rpb25JdGVtczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVG9wQXBwQmFyQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoLyoqIEB0eXBlIHshTURDVG9wQXBwQmFyQWRhcHRlcn0gKi8gYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVG9wQXBwQmFyQmFzZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIHRoaXMubmF2Q2xpY2tIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWRhcHRlcl8ubm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLm5hdkNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLm5hdkNsaWNrSGFuZGxlcl8pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENUb3BBcHBCYXJBZGFwdGVyIGZyb20gJy4uL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uIGZyb20gJy4uL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbjwhTURDU2hvcnRUb3BBcHBCYXJGb3VuZGF0aW9uPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUb3BBcHBCYXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoYWRhcHRlcik7XG4gICAgLy8gU3RhdGUgdmFyaWFibGUgZm9yIHRoZSBjdXJyZW50IHRvcCBhcHAgYmFyIHN0YXRlXG4gICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHRoaXMuc2hvcnRBcHBCYXJTY3JvbGxIYW5kbGVyXygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG4gICAgY29uc3QgaXNBbHdheXNDb2xsYXBzZWQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmdldFRvdGFsQWN0aW9uSXRlbXMoKSA+IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5TSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1MpO1xuICAgIH1cblxuICAgIGlmICghaXNBbHdheXNDb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICAgICAgdGhpcy5zaG9ydEFwcEJhclNjcm9sbEhhbmRsZXJfKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNjcm9sbCBoYW5kbGVyIGZvciBhcHBseWluZy9yZW1vdmluZyB0aGUgY29sbGFwc2VkIG1vZGlmaWVyIGNsYXNzXG4gICAqIG9uIHRoZSBzaG9ydCB0b3AgYXBwIGJhci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNob3J0QXBwQmFyU2Nyb2xsSGFuZGxlcl8oKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbCA9IHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRTY3JvbGxZKCk7XG5cbiAgICBpZiAoY3VycmVudFNjcm9sbCA8PSAwKSB7XG4gICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcbiAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlNIT1JUX0NPTExBUFNFRF9DTEFTUyk7XG4gICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXJcbiAgICByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiXG4gICAgOnN0eWxlPVwicm9vdFN0eWxlc1wiXG4gICAgdi1vbj1cIiRsaXN0ZW5lcnNcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX19yb3dcIj5cbiAgICAgIDxzZWN0aW9uIGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uIG1kYy10b3AtYXBwLWJhcl9fc2VjdGlvbi0tYWxpZ24tc3RhcnRcIj5cbiAgICAgICAgPGFcbiAgICAgICAgICB2LWlmPVwiaGF2ZU5hdmlnYXRpb25JY29uXCJcbiAgICAgICAgICByZWY9XCJuYXZpZ2F0aW9uSWNvblwiXG4gICAgICAgICAgOmNsYXNzPVwibmF2aWNvbkNsYXNzZXNcIlxuICAgICAgICAgIGhyZWY9XCIjXCJcbiAgICAgICAgICB2LW9uPVwibGlzdGVuZXJzXCI+e3sgaWNvbiB9fTwvYT5cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICB2LWlmPVwiISF0aXRsZVwiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtdG9wLWFwcC1iYXJfX3RpdGxlXCI+e3sgdGl0bGUgfX08L3NwYW4+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgICA8c2VjdGlvblxuICAgICAgICB2LWlmPVwiJHNsb3RzLmRlZmF1bHRcIlxuICAgICAgICBjbGFzcz1cIm1kYy10b3AtYXBwLWJhcl9fc2VjdGlvbiBtZGMtdG9wLWFwcC1iYXJfX3NlY3Rpb24tLWFsaWduLWVuZFwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgPC9kaXY+XG4gIDwvaGVhZGVyPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUb3BBcHBCYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90b3AtYXBwLWJhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdG9wLWFwcC1iYXIvc2hvcnQvZm91bmRhdGlvbidcbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b3AtYXBwLWJhcicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgc2hvcnQ6IEJvb2xlYW4sXG4gICAgc2hvcnRDb2xsYXBzZWQ6IEJvb2xlYW4sXG4gICAgcHJvbWluZW50OiBCb29sZWFuLFxuICAgIGZpeGVkOiBCb29sZWFuLFxuICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgaWNvbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ21lbnUnXG4gICAgfSxcbiAgICBpY29uQ2xhc3NlczogT2JqZWN0LFxuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3RTdHlsZXM6IHt9LFxuICAgICAgcm9vdENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhcic6IHRydWUsXG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXItLWRlbnNlJzogdGhpcy5kZW5zZSxcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhci0tc2hvcnQnOiB0aGlzLnNob3J0LFxuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyLS1zaG9ydC1jb2xsYXBzZWQnOiB0aGlzLnNob3J0Q29sbGFwc2VkLFxuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyLS1wcm9taW5lbnQnOiB0aGlzLnByb21pbmVudCxcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhci0tZml4ZWQnOiB0aGlzLmZpeGVkXG4gICAgICB9LFxuICAgICAgZm91bmRhdGlvbjogbnVsbFxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBoYXZlTmF2aWdhdGlvbkljb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmljb24gfHwgdGhpcy5pY29uQ2xhc3Nlc1xuICAgIH0sXG4gICAgbmF2aWNvbkNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyX19uYXZpZ2F0aW9uLWljb24nOiB0cnVlLFxuICAgICAgICAnbWF0ZXJpYWwtaWNvbnMnOiAhIXRoaXMuaWNvbixcbiAgICAgICAgLi4udGhpcy5pY29uQ2xhc3Nlc1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0ge1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZTogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290U3R5bGVzLCBwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgZ2V0VG9wQXBwQmFySGVpZ2h0OiAoKSA9PiB0aGlzLiRlbC5jbGllbnRIZWlnaHQsXG4gICAgICByZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5uYXZpZ2F0aW9uSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5uYXZpZ2F0aW9uSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ25hdicpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuXG4gICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgfSxcbiAgICAgIGdldFRvdGFsQWN0aW9uSXRlbXM6ICgpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgIE1EQ1RvcEFwcEJhckZvdW5kYXRpb24uc3RyaW5ncy5BQ1RJT05fSVRFTV9TRUxFQ1RPUlxuICAgICAgICApLmxlbmd0aFxuICAgIH1cblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IHRoaXMuc2hvcnRcbiAgICAgID8gbmV3IE1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbihhZGFwdGVyKVxuICAgICAgOiBuZXcgTURDVG9wQXBwQmFyRm91bmRhdGlvbihhZGFwdGVyKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxhXG4gICAgOmNsYXNzPVwiYWN0aW9uaWNvbkNsYXNzZXNcIlxuICAgIGhyZWY9XCIjXCJcbiAgICBjbGFzcz1cIm1kYy10b3AtYXBwLWJhci1hY3Rpb24gbWRjLXRvcC1hcHAtYmFyLS1hY3Rpb24gbWRjLXRvcC1hcHAtYmFyX19hY3Rpb24taXRlbVwiXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxuICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlTWl4aW4gfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b3AtYXBwLWJhci1hY3Rpb24nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW4sIFJpcHBsZU1peGluXSxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmcsXG4gICAgaWNvbkNsYXNzZXM6IE9iamVjdFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGFjdGlvbmljb25DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmljb24sXG4gICAgICAgIC4uLnRoaXMuaWNvbkNsYXNzZXNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVG9wQXBwQmFyIGZyb20gJy4vbWRjLXRvcC1hcHAtYmFyLnZ1ZSdcbmltcG9ydCBtZGNUb3BBcHBCYXJBY3Rpb24gZnJvbSAnLi9tZGMtdG9wLWFwcC1iYXItYWN0aW9uLnZ1ZSdcblxuZXhwb3J0IHsgbWRjVG9wQXBwQmFyLCBtZGNUb3BBcHBCYXJBY3Rpb24gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVG9wQXBwQmFyLFxuICBtZGNUb3BBcHBCYXJBY3Rpb25cbn0pXG4iLCJjb25zdCB0eXBvcyA9IFtcbiAgJ2hlYWRsaW5lMScsXG4gICdoZWFkbGluZTInLFxuICAnaGVhZGxpbmUzJyxcbiAgJ2hlYWRsaW5lNCcsXG4gICdoZWFkbGluZTUnLFxuICAnaGVhZGxpbmU2JyxcbiAgJ3N1YnRpdGxlMScsXG4gICdzdWJ0aXRsZTInLFxuICAnYm9keTEnLFxuICAnYm9keTInLFxuICAnY2FwdGlvbicsXG4gICdidXR0b24nLFxuICAnb3ZlcmxpbmUnXG5dXG5cbmV4cG9ydCBjb25zdCBtZGNUeXBvTWl4aW4gPSBuYW1lID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIHRoaXMudGFnLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICdtZGMtdHlwbyc6IHRydWUsXG4gICAgICAgICAgICBbbmFtZV06IHRydWUsXG4gICAgICAgICAgICBbYG1kYy10eXBvZ3JhcGh5LS0ke3RoaXMudHlwb31gXTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxuICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWRjVHlwb1Byb3BNaXhpbihkZWZhdWx0VGFnLCBkZWZhdWx0VHlwbywgdmFsaWRUeXBvcykge1xuICByZXR1cm4ge1xuICAgIHByb3BzOiB7XG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VGFnXG4gICAgICB9LFxuICAgICAgdHlwbzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRUeXBvLFxuICAgICAgICB2YWxpZGF0b3I6IHZhbHVlID0+IHZhbGlkVHlwb3MuaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZGNUZXh0U2VjdGlvbiA9IHtcbiAgbmFtZTogJ21kYy10ZXh0LXNlY3Rpb24nLFxuICBwcm9wczoge1xuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3NlY3Rpb24nXG4gICAgfVxuICB9LFxuICByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgdGhpcy50YWcsXG4gICAgICB7XG4gICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgJ21kYy10eXBvZ3JhcGh5JzogdHJ1ZSxcbiAgICAgICAgICAnbWRjLXRleHQtc2VjdGlvbic6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxuICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzXG4gICAgICB9LFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWRjVGV4dCA9IHtcbiAgbmFtZTogJ21kYy10ZXh0JyxcbiAgbWl4aW5zOiBbbWRjVHlwb01peGluKCdtZGMtdGV4dCcpLCBtZGNUeXBvUHJvcE1peGluKCdwJywgJ2JvZHkxJywgdHlwb3MpXVxufVxuXG5leHBvcnQgY29uc3QgbWRjRGlzcGxheSA9IHtcbiAgbmFtZTogJ21kYy1kaXNwbGF5JyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtZGlzcGxheScpLFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2gxJywgJ2hlYWRsaW5lNCcsIFtcbiAgICAgICdoZWFkbGluZTQnLFxuICAgICAgJ2hlYWRsaW5lMycsXG4gICAgICAnaGVhZGxpbmUyJyxcbiAgICAgICdoZWFkbGluZTEnXG4gICAgXSlcbiAgXVxufVxuXG5leHBvcnQgY29uc3QgbWRjSGVhZGxpbmUgPSB7XG4gIG5hbWU6ICdtZGMtaGVhZGxpbmUnLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1oZWFkbGluZScpLFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2gyJywgJ2hlYWRsaW5lNScsIFsnaGVhZGxpbmU1J10pXG4gIF1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1RpdGxlID0ge1xuICBuYW1lOiAnbWRjLXRpdGxlJyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtdGl0bGUnKSxcbiAgICBtZGNUeXBvUHJvcE1peGluKCdoMycsICdoZWFkbGluZTYnLCBbJ2hlYWRsaW5lNiddKVxuICBdXG59XG5cbmV4cG9ydCBjb25zdCBtZGNTdWJIZWFkaW5nID0ge1xuICBuYW1lOiAnbWRjLXN1YmhlYWRpbmcnLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1zdWJoZWFkaW5nJyksXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDQnLCAnc3VidGl0bGUyJywgWydzdWJ0aXRsZTEnLCAnc3VidGl0bGUyJ10pXG4gIF1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY0JvZHkgPSB7XG4gIG5hbWU6ICdtZGMtYm9keScsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLWJvZHknKSxcbiAgICBtZGNUeXBvUHJvcE1peGluKCdwJywgJ2JvZHkxJywgWydib2R5MScsICdib2R5MiddKVxuICBdXG59XG5cbmV4cG9ydCBjb25zdCBtZGNDYXB0aW9uID0ge1xuICBuYW1lOiAnbWRjLWNhcHRpb24nLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1jYXB0aW9uJyksXG4gICAgbWRjVHlwb1Byb3BNaXhpbignc3BhbicsICdjYXB0aW9uJywgWydjYXB0aW9uJ10pXG4gIF1cbn1cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHtcbiAgbWRjVGV4dFNlY3Rpb24sXG4gIG1kY1RleHQsXG4gIG1kY0JvZHksXG4gIG1kY0NhcHRpb24sXG4gIG1kY0Rpc3BsYXksXG4gIG1kY0hlYWRsaW5lLFxuICBtZGNTdWJIZWFkaW5nLFxuICBtZGNUaXRsZVxufSBmcm9tICcuL21kYy10eXBvZ3JhcGh5LmpzJ1xuXG5leHBvcnQge1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59KVxuIiwiLy9cbi8vIHZ1ZSBQbHVnSW5cbi8vXG5pbXBvcnQgVnVlTURDQnV0dG9uIGZyb20gJy4vYnV0dG9uJ1xuaW1wb3J0IFZ1ZU1EQ0NhcmQgZnJvbSAnLi9jYXJkJ1xuaW1wb3J0IFZ1ZU1EQ0NoZWNrYm94IGZyb20gJy4vY2hlY2tib3gnXG5pbXBvcnQgVnVlTURDQ2hpcFNldCBmcm9tICcuL2NoaXBzJ1xuaW1wb3J0IFZ1ZU1EQ0RpYWxvZyBmcm9tICcuL2RpYWxvZydcbmltcG9ydCBWdWVNRENEcmF3ZXIgZnJvbSAnLi9kcmF3ZXInXG5pbXBvcnQgVnVlTURDRWxldmF0aW9uIGZyb20gJy4vZWxldmF0aW9uJ1xuaW1wb3J0IFZ1ZU1EQ0ZhYiBmcm9tICcuL2ZhYidcbmltcG9ydCBWdWVNRENHcmlkTGlzdCBmcm9tICcuL2dyaWQtbGlzdCdcbmltcG9ydCBWdWVNRENJY29uIGZyb20gJy4vaWNvbidcbmltcG9ydCBWdWVNRENJY29uVG9nZ2xlIGZyb20gJy4vaWNvbi10b2dnbGUnXG5pbXBvcnQgVnVlTURDTGF5b3V0QXBwIGZyb20gJy4vbGF5b3V0LWFwcCdcbmltcG9ydCBWdWVNRENMYXlvdXRHcmlkIGZyb20gJy4vbGF5b3V0LWdyaWQnXG5pbXBvcnQgVnVlTURDTGluZWFyUHJvZ3Jlc3MgZnJvbSAnLi9saW5lYXItcHJvZ3Jlc3MnXG5pbXBvcnQgVnVlTURDTGlzdCBmcm9tICcuL2xpc3QnXG5pbXBvcnQgVnVlTURDTWVudSBmcm9tICcuL21lbnUnXG5pbXBvcnQgVnVlTURDUmFkaW8gZnJvbSAnLi9yYWRpbydcbmltcG9ydCBWdWVNRENSaXBwbGUgZnJvbSAnLi9yaXBwbGUnXG5pbXBvcnQgVnVlTURDU2VsZWN0IGZyb20gJy4vc2VsZWN0J1xuaW1wb3J0IFZ1ZU1EQ1NsaWRlciBmcm9tICcuL3NsaWRlcidcbmltcG9ydCBWdWVNRENTbmFja2JhciBmcm9tICcuL3NuYWNrYmFyJ1xuaW1wb3J0IFZ1ZU1EQ1N3aXRjaCBmcm9tICcuL3N3aXRjaCdcbmltcG9ydCBWdWVNRENUYWJzIGZyb20gJy4vdGFicydcbmltcG9ydCBWdWVNRENUZXh0ZmllbGQgZnJvbSAnLi90ZXh0ZmllbGQnXG5pbXBvcnQgVnVlTURDVGhlbWUgZnJvbSAnLi90aGVtZSdcbmltcG9ydCBWdWVNRENUb29sYmFyIGZyb20gJy4vdG9vbGJhcidcbmltcG9ydCBWdWVNRENUb3BBcHBCYXIgZnJvbSAnLi90b3AtYXBwLWJhcidcbmltcG9ydCBWdWVNRENUeXBvZ3JhcGh5IGZyb20gJy4vdHlwb2dyYXBoeSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uOiAnX19WRVJTSU9OX18nLFxuICBpbnN0YWxsKHZtKSB7XG4gICAgdm0udXNlKFZ1ZU1EQ0J1dHRvbilcbiAgICB2bS51c2UoVnVlTURDQ2FyZClcbiAgICB2bS51c2UoVnVlTURDQ2hlY2tib3gpXG4gICAgdm0udXNlKFZ1ZU1EQ0NoaXBTZXQpXG4gICAgdm0udXNlKFZ1ZU1EQ0RpYWxvZylcbiAgICB2bS51c2UoVnVlTURDRHJhd2VyKVxuICAgIHZtLnVzZShWdWVNRENFbGV2YXRpb24pXG4gICAgdm0udXNlKFZ1ZU1EQ0ZhYilcbiAgICB2bS51c2UoVnVlTURDR3JpZExpc3QpXG4gICAgdm0udXNlKFZ1ZU1EQ0ljb24pXG4gICAgdm0udXNlKFZ1ZU1EQ0ljb25Ub2dnbGUpXG4gICAgdm0udXNlKFZ1ZU1EQ0xheW91dEFwcClcbiAgICB2bS51c2UoVnVlTURDTGF5b3V0R3JpZClcbiAgICB2bS51c2UoVnVlTURDTGluZWFyUHJvZ3Jlc3MpXG4gICAgdm0udXNlKFZ1ZU1EQ0xpc3QpXG4gICAgdm0udXNlKFZ1ZU1EQ01lbnUpXG4gICAgdm0udXNlKFZ1ZU1EQ1JhZGlvKVxuICAgIHZtLnVzZShWdWVNRENSaXBwbGUpXG4gICAgdm0udXNlKFZ1ZU1EQ1NlbGVjdClcbiAgICB2bS51c2UoVnVlTURDU2xpZGVyKVxuICAgIHZtLnVzZShWdWVNRENTbmFja2JhcilcbiAgICB2bS51c2UoVnVlTURDU3dpdGNoKVxuICAgIHZtLnVzZShWdWVNRENUYWJzKVxuICAgIHZtLnVzZShWdWVNRENUZXh0ZmllbGQpXG4gICAgdm0udXNlKFZ1ZU1EQ1RoZW1lKVxuICAgIHZtLnVzZShWdWVNRENUb29sYmFyKVxuICAgIHZtLnVzZShWdWVNRENUb3BBcHBCYXIpXG4gICAgdm0udXNlKFZ1ZU1EQ1R5cG9ncmFwaHkpXG4gIH1cbn1cbiIsImltcG9ydCAnLi9zdHlsZXMuc2NzcydcbmltcG9ydCB7IGF1dG9Jbml0IH0gZnJvbSAnLi9iYXNlJ1xuaW1wb3J0IHBsdWdpbiBmcm9tICcuL2luZGV4LmpzJ1xuZXhwb3J0IGRlZmF1bHQgcGx1Z2luXG5cbmF1dG9Jbml0KHBsdWdpbilcbiJdLCJuYW1lcyI6WyJzdXBwb3J0c1Bhc3NpdmVfIiwiYXBwbHlQYXNzaXZlIiwiZ2xvYmFsT2JqIiwid2luZG93IiwiZm9yY2VSZWZyZXNoIiwidW5kZWZpbmVkIiwiaXNTdXBwb3J0ZWQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiZSIsImF1dG9Jbml0IiwicGx1Z2luIiwiX1Z1ZSIsIlZ1ZSIsImdsb2JhbCIsInVzZSIsIkJhc2VQbHVnaW4iLCJjb21wb25lbnRzIiwidmVyc2lvbiIsImluc3RhbGwiLCJrZXkiLCJjb21wb25lbnQiLCJ2bSIsIm5hbWUiLCJDdXN0b21FbGVtZW50IiwiZnVuY3Rpb25hbCIsInJlbmRlciIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwicHJvcHMiLCJpcyIsInRhZyIsImRhdGEiLCJjaGlsZHJlbiIsIkN1c3RvbUVsZW1lbnRNaXhpbiIsIkN1c3RvbUxpbmsiLCJ0eXBlIiwiU3RyaW5nIiwiZGVmYXVsdCIsImxpbmsiLCJPYmplY3QiLCJoIiwiZWxlbWVudCIsImJhYmVsSGVscGVycy5leHRlbmRzIiwicGFyZW50IiwiJHJvdXRlciIsIiRyb290IiwiJG9wdGlvbnMiLCJvbiIsImNsaWNrIiwibmF0aXZlT24iLCJDdXN0b21MaW5rTWl4aW4iLCJ0byIsImV4YWN0IiwiQm9vbGVhbiIsImFwcGVuZCIsInJlcGxhY2UiLCJhY3RpdmVDbGFzcyIsImV4YWN0QWN0aXZlQ2xhc3MiLCJjb21wdXRlZCIsImVtaXRDdXN0b21FdmVudCIsImVsIiwiZXZ0VHlwZSIsImV2dERhdGEiLCJzaG91bGRCdWJibGUiLCJldnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImJ1YmJsZXMiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21CdXR0b24iLCJhdHRycyIsInJvbGUiLCJocmVmIiwiQ3VzdG9tQnV0dG9uTWl4aW4iLCJkaXNhYmxlZCIsImV4dHJhY3RJY29uUHJvcCIsImljb25Qcm9wIiwiY2xhc3NlcyIsImNvbnRlbnQiLCJBcnJheSIsInJlZHVjZSIsInJlc3VsdCIsInZhbHVlIiwiY2xhc3NOYW1lIiwic3BsaXQiLCJ0ZXh0Q29udGVudCIsIkRpc3BhdGNoRXZlbnRNaXhpbiIsImV2ZW50IiwibWV0aG9kcyIsIiRlbWl0IiwidGFyZ2V0IiwiZXZlbnRUYXJnZXQiLCJhcmdzIiwiZXZlbnRBcmdzIiwibGlzdGVuZXJzIiwiJGxpc3RlbmVycyIsIkRpc3BhdGNoRm9jdXNNaXhpbiIsImhhc0ZvY3VzIiwib25Nb3VzZURvd24iLCJfYWN0aXZlIiwib25Nb3VzZVVwIiwib25Gb2N1c0V2ZW50Iiwic2V0VGltZW91dCIsImRpc3BhdGNoRm9jdXNFdmVudCIsIm9uQmx1ckV2ZW50IiwiJGVsIiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwibW91bnRlZCIsImJlZm9yZURlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidWlkXyIsIlZNQVVuaXF1ZUlkTWl4aW4iLCJiZWZvcmVDcmVhdGUiLCJ2bWFfdWlkXyIsIk1EQ0ZvdW5kYXRpb24iLCJhZGFwdGVyIiwiYWRhcHRlcl8iLCJNRENSaXBwbGVBZGFwdGVyIiwiaGFuZGxlciIsInZhck5hbWUiLCJjc3NDbGFzc2VzIiwiUk9PVCIsIlVOQk9VTkRFRCIsIkJHX0ZPQ1VTRUQiLCJGR19BQ1RJVkFUSU9OIiwiRkdfREVBQ1RJVkFUSU9OIiwic3RyaW5ncyIsIlZBUl9MRUZUIiwiVkFSX1RPUCIsIlZBUl9GR19TSVpFIiwiVkFSX0ZHX1NDQUxFIiwiVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCIsIlZBUl9GR19UUkFOU0xBVEVfRU5EIiwibnVtYmVycyIsIlBBRERJTkciLCJJTklUSUFMX09SSUdJTl9TQ0FMRSIsIkRFQUNUSVZBVElPTl9USU1FT1VUX01TIiwiRkdfREVBQ1RJVkFUSU9OX01TIiwiVEFQX0RFTEFZX01TIiwic3VwcG9ydHNDc3NWYXJpYWJsZXNfIiwiZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1ZyIsIndpbmRvd09iaiIsIm5vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImhhc1BzZXVkb1ZhckJ1ZyIsImJvcmRlclRvcFN0eWxlIiwicmVtb3ZlIiwic3VwcG9ydHNDc3NWYXJpYWJsZXMiLCJzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCIsIkNTUyIsInN1cHBvcnRzIiwiZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyIsIndlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cyIsImdldE1hdGNoZXNQcm9wZXJ0eSIsIkhUTUxFbGVtZW50UHJvdG90eXBlIiwiZmlsdGVyIiwicCIsInBvcCIsImdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyIsImV2IiwicGFnZU9mZnNldCIsImNsaWVudFJlY3QiLCJ4IiwieSIsImRvY3VtZW50WCIsImxlZnQiLCJkb2N1bWVudFkiLCJ0b3AiLCJub3JtYWxpemVkWCIsIm5vcm1hbGl6ZWRZIiwiY2hhbmdlZFRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiQUNUSVZBVElPTl9FVkVOVF9UWVBFUyIsIlBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiYWN0aXZhdGVkVGFyZ2V0cyIsIk1EQ1JpcHBsZUZvdW5kYXRpb24iLCJicm93c2VyU3VwcG9ydHNDc3NWYXJzIiwiaXNVbmJvdW5kZWQiLCJpc1N1cmZhY2VBY3RpdmUiLCJpc1N1cmZhY2VEaXNhYmxlZCIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJjb250YWluc0V2ZW50VGFyZ2V0IiwicmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyUmVzaXplSGFuZGxlciIsImRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwidXBkYXRlQ3NzVmFyaWFibGUiLCJjb21wdXRlQm91bmRpbmdSZWN0IiwiZ2V0V2luZG93UGFnZU9mZnNldCIsImRlZmF1bHRBZGFwdGVyIiwibGF5b3V0RnJhbWVfIiwiZnJhbWVfIiwid2lkdGgiLCJoZWlnaHQiLCJhY3RpdmF0aW9uU3RhdGVfIiwiZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8iLCJpbml0aWFsU2l6ZV8iLCJtYXhSYWRpdXNfIiwiYWN0aXZhdGVIYW5kbGVyXyIsImFjdGl2YXRlXyIsImRlYWN0aXZhdGVIYW5kbGVyXyIsImRlYWN0aXZhdGVfIiwiZm9jdXNIYW5kbGVyXyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJsdXJIYW5kbGVyXyIsInJlc2l6ZUhhbmRsZXJfIiwibGF5b3V0IiwidW5ib3VuZGVkQ29vcmRzXyIsImZnU2NhbGVfIiwiYWN0aXZhdGlvblRpbWVyXyIsImZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyIsImFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8iLCJhY3RpdmF0aW9uVGltZXJDYWxsYmFja18iLCJydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8iLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudF8iLCJpc0FjdGl2YXRlZCIsImhhc0RlYWN0aXZhdGlvblVYUnVuIiwid2FzQWN0aXZhdGVkQnlQb2ludGVyIiwid2FzRWxlbWVudE1hZGVBY3RpdmUiLCJhY3RpdmF0aW9uRXZlbnQiLCJpc1Byb2dyYW1tYXRpYyIsImlzU3VwcG9ydGVkXyIsInJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsImxheW91dEludGVybmFsXyIsImNsZWFyVGltZW91dCIsImRlcmVnaXN0ZXJSb290SGFuZGxlcnNfIiwiZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyIsInJlbW92ZUNzc1ZhcnNfIiwiZm9yRWFjaCIsImtleXMiLCJrIiwiaW5kZXhPZiIsImFjdGl2YXRpb25TdGF0ZSIsInByZXZpb3VzQWN0aXZhdGlvbkV2ZW50IiwiaXNTYW1lSW50ZXJhY3Rpb24iLCJoYXNBY3RpdmF0ZWRDaGlsZCIsImxlbmd0aCIsInNvbWUiLCJyZXNldEFjdGl2YXRpb25TdGF0ZV8iLCJwdXNoIiwicmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18iLCJjaGVja0VsZW1lbnRNYWRlQWN0aXZlXyIsImFuaW1hdGVBY3RpdmF0aW9uXyIsImtleUNvZGUiLCJ0cmFuc2xhdGVTdGFydCIsInRyYW5zbGF0ZUVuZCIsImdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18iLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18iLCJhY3RpdmF0aW9uSGFzRW5kZWQiLCJzdGF0ZSIsImV2dE9iamVjdCIsImFuaW1hdGVEZWFjdGl2YXRpb25fIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtYXhEaW0iLCJNYXRoIiwibWF4IiwiZ2V0Qm91bmRlZFJhZGl1cyIsImh5cG90ZW51c2UiLCJzcXJ0IiwicG93IiwidXBkYXRlTGF5b3V0Q3NzVmFyc18iLCJyb3VuZCIsInVuYm91bmRlZCIsIlJpcHBsZUJhc2UiLCJyZWYiLCJNQVRDSEVTIiwiX21hdGNoZXMiLCJIVE1MRWxlbWVudCIsInByb3RvdHlwZSIsIm9wdGlvbnMiLCIkc2V0IiwiJGRlbGV0ZSIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJSaXBwbGVNaXhpbiIsInJpcHBsZSIsImluaXQiLCJkZXN0cm95IiwibWl4aW5zIiwibWRjUmlwcGxlIiwiZXh0ZW5kcyIsIm1kY0J1dHRvbkJhc2UiLCJyYWlzZWQiLCJ1bmVsZXZhdGVkIiwib3V0bGluZWQiLCJkZW5zZSIsIndhdGNoIiwibWRjQnV0dG9uIiwic3JjIiwic3F1YXJlIiwiYmFja2dyb3VuZEltYWdlIiwidGl0bGUiLCJzdWJ0aXRsZSIsImxhcmdlIiwiZnVsbEJsZWVkIiwiaWNvbiIsIm1kY0NhcmQiLCJtZGNDYXJkUHJpbWFyeUFjdGlvbiIsIm1kY0NhcmRNZWRpYSIsIm1kY0NhcmRIZWFkZXIiLCJtZGNDYXJkVGl0bGUiLCJtZGNDYXJkU3VidGl0bGUiLCJtZGNDYXJkVGV4dCIsIm1kY0NhcmRBY3Rpb25zIiwibWRjQ2FyZEFjdGlvbkJ1dHRvbnMiLCJtZGNDYXJkQWN0aW9uQnV0dG9uIiwibWRjQ2FyZEFjdGlvbkljb25zIiwibWRjQ2FyZEFjdGlvbkljb24iLCJNRENDb21wb25lbnQiLCJyb290IiwiZm91bmRhdGlvbiIsInJvb3RfIiwiaW5pdGlhbGl6ZSIsImZvdW5kYXRpb25fIiwiZ2V0RGVmYXVsdEZvdW5kYXRpb24iLCJpbml0aWFsU3luY1dpdGhET00iLCJFcnJvciIsIk1EQ1JpcHBsZSIsInVuYm91bmRlZF8iLCJzZXRVbmJvdW5kZWQiLCJhY3RpdmF0ZSIsImRlYWN0aXZhdGUiLCJjcmVhdGVBZGFwdGVyIiwiZGF0YXNldCIsInNldFVuYm91bmRlZF8iLCJpbnN0YW5jZSIsInV0aWwiLCJjbGFzc0xpc3QiLCJhZGQiLCJzdHlsZSIsInNldFByb3BlcnR5IiwiTURDU2VsZWN0aW9uQ29udHJvbCIsIk1EQ0NoZWNrYm94QWRhcHRlciIsImF0dHIiLCJVUEdSQURFRCIsIkNIRUNLRUQiLCJJTkRFVEVSTUlOQVRFIiwiRElTQUJMRUQiLCJBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEIiwiQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSIsIkFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQiLCJBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSIsIkFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VEIiwiQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRCIsIk5BVElWRV9DT05UUk9MX1NFTEVDVE9SIiwiVFJBTlNJVElPTl9TVEFURV9JTklUIiwiVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEIiwiVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQiLCJUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEUiLCJBUklBX0NIRUNLRURfQVRUUiIsIkFSSUFfQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFX1ZBTFVFIiwiQU5JTV9FTkRfTEFUQ0hfTVMiLCJDQl9QUk9UT19QUk9QUyIsIk1EQ0NoZWNrYm94Rm91bmRhdGlvbiIsInNldE5hdGl2ZUNvbnRyb2xBdHRyIiwicmVtb3ZlTmF0aXZlQ29udHJvbEF0dHIiLCJyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIiLCJkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlciIsInJlZ2lzdGVyQ2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyIiwiZ2V0TmF0aXZlQ29udHJvbCIsImZvcmNlTGF5b3V0IiwiaXNBdHRhY2hlZFRvRE9NIiwiY3VycmVudENoZWNrU3RhdGVfIiwiY3VycmVudEFuaW1hdGlvbkNsYXNzXyIsImFuaW1FbmRMYXRjaFRpbWVyXyIsImFuaW1FbmRIYW5kbGVyXyIsImhhbmRsZUFuaW1hdGlvbkVuZCIsImNoYW5nZUhhbmRsZXJfIiwiaGFuZGxlQ2hhbmdlIiwiZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8iLCJnZXROYXRpdmVDb250cm9sXyIsInVwZGF0ZUFyaWFDaGVja2VkXyIsImluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXyIsInVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfIiwiY2hlY2tlZCIsImluZGV0ZXJtaW5hdGUiLCJ0cmFuc2l0aW9uQ2hlY2tTdGF0ZV8iLCJuYXRpdmVDYiIsImNiUHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImNvbnRyb2xTdGF0ZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ2YWxpZERlc2NyaXB0b3IiLCJuYXRpdmVDYkRlc2MiLCJnZXQiLCJzZXQiLCJjYWxsIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsImdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18iLCJpc0luZGV0ZXJtaW5hdGUiLCJpbnB1dFByb3BEZXNjIiwiTURDRm9ybUZpZWxkQWRhcHRlciIsIkxBQkVMX1NFTEVDVE9SIiwiTURDRm9ybUZpZWxkRm91bmRhdGlvbiIsImFjdGl2YXRlSW5wdXRSaXBwbGUiLCJkZWFjdGl2YXRlSW5wdXRSaXBwbGUiLCJjbGlja0hhbmRsZXJfIiwiaGFuZGxlQ2xpY2tfIiwiZXZlbnRUeXBlTWFwIiwibm9QcmVmaXgiLCJ3ZWJraXRQcmVmaXgiLCJzdHlsZVByb3BlcnR5IiwiY3NzUHJvcGVydHlNYXAiLCJoYXNQcm9wZXJTaGFwZSIsImV2ZW50Rm91bmRJbk1hcHMiLCJldmVudFR5cGUiLCJnZXRKYXZhU2NyaXB0RXZlbnROYW1lIiwibWFwIiwiZ2V0QW5pbWF0aW9uTmFtZSIsImV2ZW50TmFtZSIsInRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyIsImdldENvcnJlY3RFdmVudE5hbWUiLCJnZXRDb3JyZWN0UHJvcGVydHlOYW1lIiwibW9kZWwiLCJwcm9wIiwibGFiZWwiLCJOdW1iZXIiLCJoYXNMYWJlbCIsIiRzbG90cyIsImZvcm1GaWVsZENsYXNzZXMiLCJhbGlnbkVuZCIsInNldERpc2FibGVkIiwic2V0SW5kZXRlcm1pbmF0ZSIsIiRyZWZzIiwiY29udHJvbCIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9mZnNldFdpZHRoIiwicGFyZW50Tm9kZSIsImZvcm1GaWVsZCIsInNldENoZWNrZWQiLCJpc0FycmF5Iiwib25DaGFuZ2UiLCJpc0NoZWNrZWQiLCJpZHgiLCJjb25jYXQiLCJzbGljZSIsIm1kY0NoZWNrYm94IiwiTURDQ2hpcEFkYXB0ZXIiLCJwcm9wZXJ0eU5hbWUiLCJFTlRSWV9BTklNQVRJT05fTkFNRSIsIklOVEVSQUNUSU9OX0VWRU5UIiwiVFJBSUxJTkdfSUNPTl9JTlRFUkFDVElPTl9FVkVOVCIsIlJFTU9WQUxfRVZFTlQiLCJDSEVDS01BUktfU0VMRUNUT1IiLCJMRUFESU5HX0lDT05fU0VMRUNUT1IiLCJUUkFJTElOR19JQ09OX1NFTEVDVE9SIiwiQ0hFQ0tNQVJLIiwiQ0hJUCIsIkNISVBfRVhJVCIsIkhJRERFTl9MRUFESU5HX0lDT04iLCJMRUFESU5HX0lDT04iLCJUUkFJTElOR19JQ09OIiwiU0VMRUNURUQiLCJURVhUIiwiTURDQ2hpcEZvdW5kYXRpb24iLCJoYXNDbGFzcyIsImFkZENsYXNzVG9MZWFkaW5nSWNvbiIsInJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uIiwiZXZlbnRUYXJnZXRIYXNDbGFzcyIsInJlZ2lzdGVyRXZlbnRIYW5kbGVyIiwiZGVyZWdpc3RlckV2ZW50SGFuZGxlciIsInJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlclRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlciIsIm5vdGlmeUludGVyYWN0aW9uIiwibm90aWZ5VHJhaWxpbmdJY29uSW50ZXJhY3Rpb24iLCJub3RpZnlSZW1vdmFsIiwiZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlIiwic2V0U3R5bGVQcm9wZXJ0eSIsImludGVyYWN0aW9uSGFuZGxlcl8iLCJoYW5kbGVJbnRlcmFjdGlvbl8iLCJ0cmFuc2l0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVUcmFuc2l0aW9uRW5kXyIsInRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcl8iLCJoYW5kbGVUcmFpbGluZ0ljb25JbnRlcmFjdGlvbl8iLCJzZWxlY3RlZCIsImNoaXBXaWR0aCIsInN0b3BQcm9wYWdhdGlvbiIsImxlYWRpbmdJY29uIiwidHJhaWxpbmdJY29uIiwibGVhZGluZ0ljb25DbGFzc2VzIiwidHJhaWxpbmdJY29uQ2xhc3NlcyIsImluamVjdCIsImlzRmlsdGVyIiwibWRjQ2hpcFNldCIsImhhdmVsZWFkaW5nSWNvbiIsImhhdmV0cmFpbGluZ0ljb24iLCJsZWFkaW5nQ2xhc3NlcyIsInRyYWlsaW5nQ2xhc3NlcyIsImNoaXAiLCJlbWl0IiwiZ2V0UHJvcGVydHlWYWx1ZSIsInByb3BlcnR5IiwidG9nZ2xlU2VsZWN0ZWQiLCJpc1NlbGVjdGVkIiwiTURDQ2hpcFNldEFkYXB0ZXIiLCJ0ZXh0IiwiQ0hJUF9TRUxFQ1RPUiIsIkNIT0lDRSIsIkZJTFRFUiIsIk1EQ0NoaXBTZXRGb3VuZGF0aW9uIiwiYXBwZW5kQ2hpcCIsInJlbW92ZUNoaXAiLCJzZWxlY3RlZENoaXBzXyIsImNoaXBJbnRlcmFjdGlvbkhhbmRsZXJfIiwiaGFuZGxlQ2hpcEludGVyYWN0aW9uXyIsImNoaXBSZW1vdmFsSGFuZGxlcl8iLCJoYW5kbGVDaGlwUmVtb3ZhbF8iLCJjaGlwRWwiLCJjaGlwRm91bmRhdGlvbiIsImRlc2VsZWN0QWxsXyIsInNldFNlbGVjdGVkIiwiaW5kZXgiLCJzcGxpY2UiLCJkZXNlbGVjdCIsInNlbGVjdCIsImNob2ljZSIsImlucHV0IiwicHJvdmlkZSIsImNoaXBUZXh0RWwiLCJjcmVhdGVUZXh0Tm9kZSIsImNoaXBzIiwibWRjQ2hpcCIsIk9QRU4iLCJBTklNQVRJTkciLCJCQUNLRFJPUCIsIlNDUk9MTF9MT0NLIiwiQUNDRVBUX0JUTiIsIkNBTkNFTF9CVE4iLCJPUEVOX0RJQUxPR19TRUxFQ1RPUiIsIkRJQUxPR19TVVJGQUNFX1NFTEVDVE9SIiwiQUNDRVBUX1NFTEVDVE9SIiwiQUNDRVBUX0VWRU5UIiwiQ0FOQ0VMX0VWRU5UIiwiTURDRGlhbG9nRm91bmRhdGlvbiIsImFkZEJvZHlDbGFzcyIsInJlbW92ZUJvZHlDbGFzcyIsInJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIiLCJyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyIiwiZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyIiwibm90aWZ5QWNjZXB0Iiwibm90aWZ5Q2FuY2VsIiwidHJhcEZvY3VzT25TdXJmYWNlIiwidW50cmFwRm9jdXNPblN1cmZhY2UiLCJpc0RpYWxvZyIsImlzT3Blbl8iLCJjb21wb25lbnRDbGlja0hhbmRsZXJfIiwiY2FuY2VsIiwiZGlhbG9nQ2xpY2tIYW5kbGVyXyIsImhhbmRsZURpYWxvZ0NsaWNrXyIsImRvY3VtZW50S2V5ZG93bkhhbmRsZXJfIiwiZW5hYmxlU2Nyb2xsXyIsImRpc2FibGVTY3JvbGxfIiwic2hvdWxkTm90aWZ5IiwiY2xvc2UiLCJhY2NlcHQiLCJtb2R1bGUiLCJlbGVtZW50RG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiYmFzaWNUYWJiYWJsZXMiLCJvcmRlcmVkVGFiYmFibGVzIiwiaXNVbmF2YWlsYWJsZSIsImNyZWF0ZUlzVW5hdmFpbGFibGUiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJjYW5kaWRhdGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImpvaW4iLCJpbmNsdWRlQ29udGFpbmVyIiwibWF0Y2hlcyIsIkVsZW1lbnQiLCJtc01hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsImNhbmRpZGF0ZVNlbGVjdG9yIiwiYXBwbHkiLCJ1bnNoaWZ0IiwiY2FuZGlkYXRlIiwiY2FuZGlkYXRlSW5kZXhBdHRyIiwiY2FuZGlkYXRlSW5kZXgiLCJpIiwibCIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwiaXNOYU4iLCJ0YWJJbmRleCIsInRhZ05hbWUiLCJ0YWJiYWJsZU5vZGVzIiwic29ydCIsImEiLCJiIiwiaXNPZmZDYWNoZSIsImlzT2ZmIiwibm9kZUNvbXB1dGVkU3R5bGUiLCJkZWZhdWx0VmlldyIsImRpc3BsYXkiLCJ2aXNpYmlsaXR5IiwibGlzdGVuaW5nRm9jdXNUcmFwIiwiZm9jdXNUcmFwIiwidXNlck9wdGlvbnMiLCJmaXJzdFRhYmJhYmxlTm9kZSIsImxhc3RUYWJiYWJsZU5vZGUiLCJub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24iLCJhY3RpdmUiLCJwYXVzZWQiLCJ0YWJFdmVudCIsImNvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJjb25maWciLCJyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSIsImVzY2FwZURlYWN0aXZhdGVzIiwidHJhcCIsInBhdXNlIiwidW5wYXVzZSIsImFjdGl2YXRlT3B0aW9ucyIsImRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucyIsIm9uQWN0aXZhdGUiLCJkZWFjdGl2YXRlT3B0aW9ucyIsImRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zIiwicmV0dXJuRm9jdXMiLCJvbkRlYWN0aXZhdGUiLCJhZGRMaXN0ZW5lcnMiLCJmaXJzdEZvY3VzTm9kZSIsImNoZWNrRm9jdXMiLCJjaGVja0NsaWNrIiwiY2hlY2tQb2ludGVyRG93biIsImNoZWNrS2V5IiwicmVtb3ZlTGlzdGVuZXJzIiwiZ2V0Tm9kZUZvck9wdGlvbiIsIm9wdGlvbk5hbWUiLCJvcHRpb25WYWx1ZSIsImNsaWNrT3V0c2lkZURlYWN0aXZhdGVzIiwicHJldmVudERlZmF1bHQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJibHVyIiwiaXNFc2NhcGVFdmVudCIsImhhbmRsZVRhYiIsImhhc0F0dHJpYnV0ZSIsImN1cnJlbnRGb2N1c0luZGV4Iiwic2hpZnRLZXkiLCJ0cnlGb2N1cyIsInVwZGF0ZVRhYmJhYmxlTm9kZXMiLCJ0YWJiYWJsZSIsInJlYWRqdXN0Rm9jdXMiLCJmb2N1cyIsInRvTG93ZXJDYXNlIiwiY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UiLCJzdXJmYWNlRWwiLCJhY2NlcHRCdXR0b25FbCIsImZvY3VzVHJhcEZhY3RvcnkiLCJjcmVhdGVGb2N1c1RyYXAiLCJpbml0aWFsRm9jdXMiLCJyZXF1aXJlZCIsImFjY2VwdERpc2FibGVkIiwiYWNjZW50Iiwic2Nyb2xsYWJsZSIsIm9wZW4iLCJkYXJrIiwic3VyZmFjZUNsYXNzZXMiLCJib2R5Q2xhc3NlcyIsInN1cmZhY2UiLCJvbk9wZW5fIiwib25DYW5jZWwiLCJvbkFjY2VwdCIsIm5vdGlmeSIsInNob3ciLCJtZGNEaWFsb2ciLCJGT0NVU0FCTEVfRUxFTUVOVFMiLCJNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24iLCJoYXNOZWNlc3NhcnlEb20iLCJyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJzZXRUcmFuc2xhdGVYIiwiZ2V0Rm9jdXNhYmxlRWxlbWVudHMiLCJzYXZlRWxlbWVudFRhYlN0YXRlIiwicmVzdG9yZUVsZW1lbnRUYWJTdGF0ZSIsIm1ha2VFbGVtZW50VW50YWJiYWJsZSIsIm5vdGlmeU9wZW4iLCJub3RpZnlDbG9zZSIsImlzUnRsIiwiZ2V0RHJhd2VyV2lkdGgiLCJyb290Q3NzQ2xhc3MiLCJhbmltYXRpbmdDc3NDbGFzcyIsIm9wZW5Dc3NDbGFzcyIsInJvb3RDc3NDbGFzc18iLCJhbmltYXRpbmdDc3NDbGFzc18iLCJvcGVuQ3NzQ2xhc3NfIiwiaW5lcnRfIiwiY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfIiwiaGFuZGxlVG91Y2hTdGFydF8iLCJjb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyIsImhhbmRsZVRvdWNoTW92ZV8iLCJjb21wb25lbnRUb3VjaEVuZEhhbmRsZXJfIiwiaGFuZGxlVG91Y2hFbmRfIiwiZGV0YWJpbmF0ZV8iLCJyZXRhYmluYXRlXyIsImVsZW1lbnRzIiwicG9pbnRlclR5cGUiLCJkaXJlY3Rpb25fIiwiZHJhd2VyV2lkdGhfIiwic3RhcnRYXyIsInRvdWNoZXMiLCJjdXJyZW50WF8iLCJ1cGRhdGVSYWZfIiwidXBkYXRlRHJhd2VyXyIsImJpbmQiLCJwcmVwYXJlRm9yVG91Y2hFbmRfIiwiYWJzIiwibmV3UG9zaXRpb25fIiwiaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyIsIm5ld1BvcyIsIm1pbiIsIkRSQVdFUl9TRUxFQ1RPUiIsIk9QRU5fRVZFTlQiLCJDTE9TRV9FVkVOVCIsIk1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uIiwiaXNEcmF3ZXIiLCJUQUJfREFUQSIsIlRBQl9EQVRBX0hBTkRMRUQiLCJzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfIiwicmVtYXBFdmVudCIsImdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSIsInRyYW5zZm9ybVByb3BlcnR5TmFtZSIsInN1cHBvcnRzQ3NzQ3VzdG9tUHJvcGVydGllcyIsImRyYXdlciIsIl9yZWZyZXNoIiwiT1BBQ0lUWV9WQVJfTkFNRSIsIk1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24iLCJuZXdPcGFjaXR5IiwibWVkaWEiLCJfc21hbGwiLCJtYXRjaE1lZGlhIiwiX2xhcmdlIiwibWRjUGVybWFuZW50RHJhd2VyIiwibWRjUGVyc2lzdGVudERyYXdlciIsIm1kY1RlbXBvcmFyeURyYXdlciIsInBlcm1hbmVudCIsInBlcnNpc3RlbnQiLCJ0ZW1wb3JhcnkiLCJkcmF3ZXJUeXBlIiwidmFsaWRhdG9yIiwidmFsIiwidG9vbGJhclNwYWNlciIsInRvZ2dsZU9uIiwidG9nZ2xlT25Tb3VyY2UiLCJvcGVuT24iLCJvcGVuT25Tb3VyY2UiLCJjbG9zZU9uIiwiY2xvc2VPblNvdXJjZSIsIm1kY0RyYXdlciIsInNtYWxsIiwib3Blbl8iLCJpc1Blcm1hbmVudCIsImlzUGVyc2lzdGVudCIsImlzVGVtcG9yYXJ5IiwiaXNSZXNwb25zaXZlIiwiY3JlYXRlZCIsInRvZ2dsZU9uRXZlbnRTb3VyY2UiLCIkb24iLCJ0b2dnbGVEcmF3ZXIiLCJvcGVuT25FdmVudFNvdXJjZSIsIm9wZW5EcmF3ZXIiLCJjbG9zZU9uRXZlbnRTb3VyY2UiLCJjbG9zZURyYXdlciIsImFkZExpc3RlbmVyIiwicmVmcmVzaE1lZGlhIiwiJG5leHRUaWNrIiwicmVtb3ZlTGlzdGVuZXIiLCIkb2ZmIiwiaXNPcGVuIiwic3RhcnRJY29uIiwidGVtcG9yYXJ5Q2xvc2UiLCJhY3RpdmF0ZWQiLCJteWxpc3RlbmVycyIsIml0ZW1DbGFzc2VzIiwiaGFzU3RhcnREZXRhaWwiLCJtZGNEcmF3ZXJMYXlvdXQiLCJtZGNEcmF3ZXJIZWFkZXIiLCJtZGNEcmF3ZXJMaXN0IiwibWRjRHJhd2VySXRlbSIsIm1kY0RyYXdlckRpdmlkZXIiLCJtZGNFbGV2YXRpb24iLCJtaW5pIiwiYWJzb2x1dGUiLCJmaXhlZCIsIm1kY0ZBQiIsIlRJTEVTX1NFTEVDVE9SIiwiVElMRV9TRUxFQ1RPUiIsIk1EQ0dyaWRMaXN0Rm91bmRhdGlvbiIsImdldE9mZnNldFdpZHRoIiwiZ2V0TnVtYmVyT2ZUaWxlcyIsImdldE9mZnNldFdpZHRoRm9yVGlsZUF0SW5kZXgiLCJzZXRTdHlsZUZvclRpbGVzRWxlbWVudCIsImFsaWduQ2VudGVyIiwicmVzaXplRnJhbWVfIiwiYWxpZ25DZW50ZXJfIiwiZ3JpZFdpZHRoIiwiaXRlbVdpZHRoIiwidGlsZXNXaWR0aCIsImZsb29yIiwicmF0aW8iLCJpbnRlcmFjdGl2ZSIsIm1kY0dyaWQiLCJuYXJyb3dHdXR0ZXIiLCJoZWFkZXJDYXB0aW9uIiwiaWNvbkFsaWduU3RhcnQiLCJpY29uQWxpZ25FbmQiLCJ3aXRoU3VwcG9ydFRleHQiLCJkZWZhdWx0V2lkdGgiLCJjb3ZlciIsImNsaWNrTGlzdGVuZXIiLCJpc0ludGVyYWN0aXZlIiwiaGFzRW5kRGV0YWlsIiwiZW5kSWNvbiIsImFkZFJpcHBsZSIsInJlbW92ZVJpcHBsZSIsIm1kY0dyaWRMaXN0IiwibWRjR3JpZFRpbGUiLCJtZGNJY29uIiwiTURDSWNvblRvZ2dsZUFkYXB0ZXIiLCJEQVRBX1RPR0dMRV9PTiIsIkRBVEFfVE9HR0xFX09GRiIsIkFSSUFfUFJFU1NFRCIsIkFSSUFfRElTQUJMRUQiLCJBUklBX0xBQkVMIiwiQ0hBTkdFX0VWRU5UIiwiTURDSWNvblRvZ2dsZUZvdW5kYXRpb24iLCJzZXRUZXh0IiwiZ2V0VGFiSW5kZXgiLCJzZXRUYWJJbmRleCIsImdldEF0dHIiLCJzZXRBdHRyIiwicm1BdHRyIiwibm90aWZ5Q2hhbmdlIiwib25fIiwiZGlzYWJsZWRfIiwic2F2ZWRUYWJJbmRleF8iLCJ0b2dnbGVPbkRhdGFfIiwidG9nZ2xlT2ZmRGF0YV8iLCJ0b2dnbGVGcm9tRXZ0XyIsImlzSGFuZGxpbmdLZXlkb3duXyIsImtleWRvd25IYW5kbGVyXyIsImlzU3BhY2UiLCJrZXl1cEhhbmRsZXJfIiwicmVmcmVzaFRvZ2dsZURhdGEiLCJwYXJzZUpzb25EYXRhQXR0cl8iLCJ0b2dnbGUiLCJpc09uIiwiY2xhc3NUb1JlbW92ZSIsImNzc0NsYXNzIiwiZGF0YUF0dHIiLCJKU09OIiwicGFyc2UiLCJpc0Rpc2FibGVkIiwia2V5Ym9hcmRLZXkiLCJ0b2dnbGVPZmYiLCJpY29uQ2xhc3NlcyIsInRvZ2dsZU9uRGF0YSIsInN0cmluZ2lmeSIsInRvZ2dsZU9mZkRhdGEiLCJpc0tleWJvYXJkQWN0aXZhdGVkIiwibWRjSUNvblRvZ2dsZSIsIm1kY0xheW91dEFwcCIsImZpeGVkQ29sdW1uV2lkdGgiLCJhbGlnbkxlZnQiLCJhbGlnblJpZ2h0Iiwic3Bhbk9wdGlvbnMiLCJudW0iLCJpc0Zpbml0ZSIsInNwYW4iLCJvcmRlciIsInBob25lIiwidGFibGV0IiwiZGVza3RvcCIsImFsaWduIiwibWRjTGF5b3V0R3JpZCIsIm1kY0xheW91dENlbGwiLCJtZGNMYXlvdXRJbm5lckdyaWQiLCJDTE9TRURfQ0xBU1MiLCJJTkRFVEVSTUlOQVRFX0NMQVNTIiwiUkVWRVJTRURfQ0xBU1MiLCJQUklNQVJZX0JBUl9TRUxFQ1RPUiIsIkJVRkZFUl9TRUxFQ1RPUiIsIk1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbiIsImdldFByaW1hcnlCYXIiLCJnZXRCdWZmZXIiLCJzZXRTdHlsZSIsImRldGVybWluYXRlXyIsInJldmVyc2VfIiwicHJvZ3Jlc3NfIiwiaXNEZXRlcm1pbmF0ZSIsInNldFNjYWxlXyIsImlzUmV2ZXJzZWQiLCJzY2FsZVZhbHVlIiwidHJhbnNmb3JtU3R5bGVQcm9wZXJ0eSIsIlByb2dyZXNzUHJvcFR5cGUiLCJyZXZlcnNlIiwicHJvZ3Jlc3MiLCJidWZmZXIiLCJzZXRQcm9ncmVzcyIsInNldEJ1ZmZlciIsInNldERldGVybWluYXRlIiwic2V0UmV2ZXJzZSIsInByaW1hcnkiLCJtZGNMaW5lYXJQcm9ncmVzcyIsImF2YXRhckxpc3QiLCJ0d29MaW5lIiwiYm9yZGVyZWQiLCJtZGNMaXN0IiwiaGFzU2Vjb25kYXJ5IiwiaW5zZXQiLCJwYWRkZWQiLCJtZGNMaXN0SXRlbSIsIm1kY0xpc3REaXZpZGVyIiwibWRjTGlzdEdyb3VwIiwibWRjTGlzdEdyb3VwSGVhZGVyIiwibWRjTGlzdEdyb3VwRGl2aWRlciIsIk1EQ01lbnVBZGFwdGVyIiwiYXR0cmlidXRlTmFtZSIsIm9yaWdpbiIsInBvc2l0aW9uIiwiQU5JTUFUSU5HX09QRU4iLCJBTklNQVRJTkdfQ0xPU0VEIiwiU0VMRUNURURfTElTVF9JVEVNIiwiSVRFTVNfU0VMRUNUT1IiLCJTRUxFQ1RFRF9FVkVOVCIsIkFSSUFfRElTQUJMRURfQVRUUiIsIlNFTEVDVEVEX1RSSUdHRVJfREVMQVkiLCJUUkFOU0lUSU9OX09QRU5fRFVSQVRJT04iLCJUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OIiwiTUFSR0lOX1RPX0VER0UiLCJBTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTyIsIk9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTyIsIkNvcm5lckJpdCIsIkJPVFRPTSIsIkNFTlRFUiIsIlJJR0hUIiwiRkxJUF9SVEwiLCJDb3JuZXIiLCJUT1BfTEVGVCIsIlRPUF9SSUdIVCIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NX1JJR0hUIiwiVE9QX1NUQVJUIiwiVE9QX0VORCIsIkJPVFRPTV9TVEFSVCIsIkJPVFRPTV9FTkQiLCJNRENNZW51Rm91bmRhdGlvbiIsImdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0IiwiZ2V0SW5uZXJEaW1lbnNpb25zIiwiaGFzQW5jaG9yIiwiZ2V0QW5jaG9yRGltZW5zaW9ucyIsImdldFdpbmRvd0RpbWVuc2lvbnMiLCJnZXROdW1iZXJPZkl0ZW1zIiwicmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyIiwiZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXIiLCJnZXRJbmRleEZvckV2ZW50VGFyZ2V0Iiwibm90aWZ5U2VsZWN0ZWQiLCJzYXZlRm9jdXMiLCJyZXN0b3JlRm9jdXMiLCJpc0ZvY3VzZWQiLCJnZXRGb2N1c2VkSXRlbUluZGV4IiwiZm9jdXNJdGVtQXRJbmRleCIsInNldFRyYW5zZm9ybU9yaWdpbiIsInNldFBvc2l0aW9uIiwic2V0TWF4SGVpZ2h0Iiwic2V0QXR0ckZvck9wdGlvbkF0SW5kZXgiLCJybUF0dHJGb3JPcHRpb25BdEluZGV4IiwiYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4Iiwicm1DbGFzc0Zvck9wdGlvbkF0SW5kZXgiLCJoYW5kbGVQb3NzaWJsZVNlbGVjdGVkXyIsImhhbmRsZUtleWJvYXJkRG93bl8iLCJoYW5kbGVLZXlib2FyZFVwXyIsImRvY3VtZW50Q2xpY2tIYW5kbGVyXyIsImhhbmRsZURvY3VtZW50Q2xpY2tfIiwib3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfIiwiY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyIsInNlbGVjdGVkVHJpZ2dlclRpbWVySWRfIiwiYW5pbWF0aW9uUmVxdWVzdElkXyIsImRpbWVuc2lvbnNfIiwiaXRlbUhlaWdodF8iLCJhbmNob3JDb3JuZXJfIiwiYW5jaG9yTWFyZ2luXyIsInJpZ2h0IiwiYm90dG9tIiwibWVhc3VyZXNfIiwic2VsZWN0ZWRJbmRleF8iLCJyZW1lbWJlclNlbGVjdGlvbl8iLCJxdWlja09wZW5fIiwia2V5RG93bldpdGhpbk1lbnVfIiwiY29ybmVyIiwibWFyZ2luIiwicmVtZW1iZXJTZWxlY3Rpb24iLCJzZXRTZWxlY3RlZEluZGV4IiwicXVpY2tPcGVuIiwiZm9jdXNJbmRleCIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwiaXNUYWIiLCJpc0Fycm93VXAiLCJpc0Fycm93RG93biIsImlzRW50ZXIiLCJmb2N1c2VkSXRlbUluZGV4IiwibGFzdEl0ZW1JbmRleCIsImlzRXNjYXBlIiwidGFyZ2V0SW5kZXgiLCJhbmNob3JSZWN0Iiwidmlld3BvcnQiLCJ2aWV3cG9ydERpc3RhbmNlIiwiYW5jaG9ySGVpZ2h0IiwiYW5jaG9yV2lkdGgiLCJtZW51SGVpZ2h0IiwibWVudVdpZHRoIiwiaXNCb3R0b21BbGlnbmVkIiwiYXZhaWxhYmxlVG9wIiwiYXZhaWxhYmxlQm90dG9tIiwidG9wT3ZlcmZsb3ciLCJib3R0b21PdmVyZmxvdyIsImlzRmxpcFJ0bCIsImF2b2lkSG9yaXpvbnRhbE92ZXJsYXAiLCJpc0FsaWduZWRSaWdodCIsImF2YWlsYWJsZUxlZnQiLCJhdmFpbGFibGVSaWdodCIsImxlZnRPdmVyZmxvdyIsInJpZ2h0T3ZlcmZsb3ciLCJpc1JpZ2h0QWxpZ25lZCIsInJpZ2h0T2Zmc2V0IiwibGVmdE9mZnNldCIsImF2b2lkVmVydGljYWxPdmVybGFwIiwiY2FuT3ZlcmxhcFZlcnRpY2FsbHkiLCJtYXhIZWlnaHQiLCJnZXRBdXRvTGF5b3V0TWVhc3VyZW1lbnRzXyIsImdldE9yaWdpbkNvcm5lcl8iLCJtYXhNZW51SGVpZ2h0IiwiZ2V0TWVudU1heEhlaWdodF8iLCJ2ZXJ0aWNhbEFsaWdubWVudCIsImhvcml6b250YWxBbGlnbm1lbnQiLCJob3Jpem9udGFsT2Zmc2V0IiwiZ2V0SG9yaXpvbnRhbE9yaWdpbk9mZnNldF8iLCJ2ZXJ0aWNhbE9mZnNldCIsImdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0XyIsInZlcnRpY2FsT2Zmc2V0UGVyY2VudCIsIm9yaWdpblBlcmNlbnQiLCJhdXRvUG9zaXRpb25fIiwiZm9jdXNPbk9wZW5fIiwidGFyZ2V0SXNEaXNhYmxlZCIsInByZXZTZWxlY3RlZEluZGV4IiwiaXRlbXMiLCJudiIsInNldFF1aWNrT3BlbiIsImFuY2hvckNvcm5lciIsInNldEFuY2hvckNvcm5lciIsImFuY2hvck1hcmdpbiIsInNldEFuY2hvck1hcmdpbiIsInJlZnJlc2hJdGVtcyIsInNsb3RPYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsIl9wcmV2aW91c0ZvY3VzIiwib2Zmc2V0SGVpZ2h0IiwicGFyZW50RWxlbWVudCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIml0ZW0iLCJkaXNjb25uZWN0IiwiaGlkZSIsIm1kY01lbnUiLCJtZGNNZW51SXRlbSIsIm1kY01lbnVEaXZpZGVyIiwibWRjTWVudUFuY2hvciIsIk1EQ1JhZGlvQWRhcHRlciIsIk1EQ1JhZGlvRm91bmRhdGlvbiIsInBpY2tlZCIsInNldFZhbHVlIiwiZ2V0VmFsdWUiLCJzeW5jIiwibWRjUmFkaW8iLCJCT1giLCJMSU5FX1JJUFBMRV9TRUxFQ1RPUiIsIk1EQ1NlbGVjdEZvdW5kYXRpb24iLCJmbG9hdExhYmVsIiwiYWN0aXZhdGVCb3R0b21MaW5lIiwiZGVhY3RpdmF0ZUJvdHRvbUxpbmUiLCJnZXRTZWxlY3RlZEluZGV4IiwiaGFuZGxlRm9jdXNfIiwiaGFuZGxlQmx1cl8iLCJzZWxlY3Rpb25IYW5kbGVyXyIsImhhbmRsZVNlbGVjdF8iLCJmbG9hdExhYmVsV2l0aFZhbHVlXyIsIm9wdGlvbkhhc1ZhbHVlIiwiTURDTGluZVJpcHBsZUFkYXB0ZXIiLCJMSU5FX1JJUFBMRV9BQ1RJVkUiLCJMSU5FX1JJUFBMRV9ERUFDVElWQVRJTkciLCJNRENMaW5lUmlwcGxlRm91bmRhdGlvbiIsImhhbmRsZVRyYW5zaXRpb25FbmQiLCJ4Q29vcmRpbmF0ZSIsImlzRGVhY3RpdmF0aW5nIiwiTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIiLCJMQUJFTF9GTE9BVF9BQk9WRSIsIkxBQkVMX1NIQUtFIiwiTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24iLCJnZXRXaWR0aCIsInNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVTaGFrZUFuaW1hdGlvbkVuZF8iLCJzaG91bGRTaGFrZSIsInNob3VsZEZsb2F0IiwiaW5oZXJpdEF0dHJzIiwiYm94IiwiaWQiLCJsYWJlbENsYXNzZXMiLCJsaW5lQ2xhc3NlcyIsImxpbmVTdHlsZXMiLCJyb290Q2xhc3NlcyIsImNoYW5nZSIsImxhYmVsRm91bmRhdGlvbiIsImxpbmVSaXBwbGVGb3VuZGF0aW9uIiwibGluZSIsImZsb2F0IiwibmF0aXZlX2NvbnRyb2wiLCJzZWxlY3RlZEluZGV4IiwicmVmcmVzaEluZGV4IiwiZmluZEluZGV4IiwibWRjU2VsZWN0IiwiQUNUSVZFIiwiRElTQ1JFVEUiLCJGT0NVUyIsIklOX1RSQU5TSVQiLCJJU19ESVNDUkVURSIsIkhBU19UUkFDS19NQVJLRVIiLCJUUkFDS19TRUxFQ1RPUiIsIlRSQUNLX01BUktFUl9DT05UQUlORVJfU0VMRUNUT1IiLCJMQVNUX1RSQUNLX01BUktFUl9TRUxFQ1RPUiIsIlRIVU1CX0NPTlRBSU5FUl9TRUxFQ1RPUiIsIlBJTl9WQUxVRV9NQVJLRVJfU0VMRUNUT1IiLCJBUklBX1ZBTFVFTUlOIiwiQVJJQV9WQUxVRU1BWCIsIkFSSUFfVkFMVUVOT1ciLCJTVEVQX0RBVEFfQVRUUiIsIklOUFVUX0VWRU5UIiwiUEFHRV9GQUNUT1IiLCJNRENTbGlkZXJBZGFwdGVyIiwibnVtTWFya2VycyIsIktFWV9JRFMiLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJIT01FIiwiRU5EIiwiUEFHRV9VUCIsIlBBR0VfRE9XTiIsIk1PVkVfRVZFTlRfTUFQIiwiRE9XTl9FVkVOVFMiLCJVUF9FVkVOVFMiLCJNRENTbGlkZXJGb3VuZGF0aW9uIiwicmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyIiwibm90aWZ5SW5wdXQiLCJzZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkiLCJzZXRUcmFja1N0eWxlUHJvcGVydHkiLCJzZXRNYXJrZXJWYWx1ZSIsImFwcGVuZFRyYWNrTWFya2VycyIsInJlbW92ZVRyYWNrTWFya2VycyIsInNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5IiwiaXNSVEwiLCJyZWN0XyIsIk5hTiIsImFjdGl2ZV8iLCJpblRyYW5zaXRfIiwiaXNEaXNjcmV0ZV8iLCJoYXNUcmFja01hcmtlcl8iLCJoYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyIsIm1pbl8iLCJtYXhfIiwic3RlcF8iLCJ2YWx1ZV8iLCJwcmV2ZW50Rm9jdXNTdGF0ZV8iLCJ1cGRhdGVVSUZyYW1lXyIsInRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfIiwiaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfIiwiaGFuZGxlRG93bl8iLCJoYW5kbGVLZXlkb3duXyIsImV2dE5hbWUiLCJnZXRTdGVwIiwiZ2V0TWluIiwiZ2V0TWF4Iiwic3RlcCIsImluZGl2aXNpYmxlIiwiY2VpbCIsImxhc3RTdGVwUmF0aW8iLCJmbGV4IiwidXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfIiwic2V0VmFsdWVfIiwic2V0dXBUcmFja01hcmtlciIsInRvZ2dsZUNsYXNzXyIsInNldEluVHJhbnNpdF8iLCJzZXRBY3RpdmVfIiwibW92ZUhhbmRsZXIiLCJoYW5kbGVNb3ZlXyIsInVwSGFuZGxlciIsImhhbmRsZVVwXyIsInNldFZhbHVlRnJvbUV2dF8iLCJ0YXJnZXRUb3VjaGVzIiwiZ2V0UGFnZVhfIiwiY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyIsInhQb3MiLCJwY3RDb21wbGV0ZSIsImtleUlkIiwiZ2V0S2V5SWRfIiwiZ2V0VmFsdWVGb3JLZXlJZF8iLCJrYmRFdnQiLCJkZWx0YSIsInZhbHVlTmVlZHNUb0JlRmxpcHBlZCIsInNob3VsZEZpcmVJbnB1dCIsImZvcmNlIiwidmFsdWVTZXRUb0JvdW5kYXJ5IiwicXVhbnRpemVfIiwibnVtU3RlcHMiLCJxdWFudGl6ZWRWYWwiLCJ0cmFuc2xhdGVQeCIsInRyYW5zZm9ybVByb3AiLCJ0cmFuc2l0aW9uZW5kRXZ0TmFtZSIsIm9uVHJhbnNpdGlvbkVuZCIsImluVHJhbnNpdCIsInNob3VsZEJlUHJlc2VudCIsImRpc3BsYXlNYXJrZXJzIiwibGF5b3V0T24iLCJsYXlvdXRPblNvdXJjZSIsInRyYWNrU3R5bGVzIiwibGFzdFRyYWNrTWFya2Vyc1N0eWxlcyIsInRodW1iU3R5bGVzIiwibWFya2VyVmFsdWUiLCJpc0Rpc2NyZXRlIiwiaGFzTWFya2VycyIsInNldE1pbiIsInNldE1heCIsInNldFN0ZXAiLCJ0aHVtYkNvbnRhaW5lciIsImxheW91dE9uRXZlbnRTb3VyY2UiLCJtZGNTbGlkZXIiLCJBQ1RJT05fV1JBUFBFUiIsIkFDVElPTl9CVVRUT04iLCJNVUxUSUxJTkUiLCJBQ1RJT05fT05fQk9UVE9NIiwiVEVYVF9TRUxFQ1RPUiIsIkFDVElPTl9XUkFQUEVSX1NFTEVDVE9SIiwiQUNUSU9OX0JVVFRPTl9TRUxFQ1RPUiIsIlNIT1dfRVZFTlQiLCJISURFX0VWRU5UIiwiTUVTU0FHRV9USU1FT1VUIiwiTURDU25hY2tiYXJGb3VuZGF0aW9uIiwic2V0QXJpYUhpZGRlbiIsInVuc2V0QXJpYUhpZGRlbiIsInNldEFjdGlvbkFyaWFIaWRkZW4iLCJ1bnNldEFjdGlvbkFyaWFIaWRkZW4iLCJzZXRBY3Rpb25UZXh0Iiwic2V0TWVzc2FnZVRleHQiLCJzZXRGb2N1cyIsInZpc2liaWxpdHlJc0hpZGRlbiIsInJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlciIsImRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyIiwicmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsInJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlciIsImRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIiLCJub3RpZnlTaG93Iiwibm90aWZ5SGlkZSIsImFjdGlvbldhc0NsaWNrZWRfIiwiZGlzbWlzc09uQWN0aW9uXyIsImZpcnN0Rm9jdXNfIiwicG9pbnRlckRvd25SZWNvZ25pemVkXyIsInNuYWNrYmFySGFzRm9jdXNfIiwic25hY2tiYXJEYXRhXyIsInF1ZXVlXyIsImFjdGlvbkNsaWNrSGFuZGxlcl8iLCJpbnZva2VBY3Rpb25fIiwidmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfIiwidGltZW91dElkXyIsImNsZWFudXBfIiwidGltZW91dCIsImhhbmRsZVBvc3NpYmxlVGFiS2V5Ym9hcmRGb2N1c18iLCJkaXNtaXNzT25BY3Rpb24iLCJtZXNzYWdlIiwiYWN0aW9uSGFuZGxlciIsImFjdGlvblRleHQiLCJtdWx0aWxpbmUiLCJhY3Rpb25PbkJvdHRvbSIsImFjdGlvbkhhbmRsZXJfIiwic2V0QWN0aW9uSGlkZGVuXyIsImhpamFja0ZvY3VzIiwic2V0Rm9jdXNPbkFjdGlvbl8iLCJhbGxvd0Rpc21pc3NhbCIsInNob3dOZXh0XyIsInNoaWZ0IiwiaXNIaWRkZW4iLCJzbmFjayIsImFsaWduU3RhcnQiLCJoaWRkZW4iLCJhY3Rpb25IaWRkZW4iLCJidXR0b24iLCJldmVudFNvdXJjZSIsInNldERpc21pc3NPbkFjdGlvbiIsImRpc21pc3Nlc09uQWN0aW9uIiwib25TbmFjayIsIm1kY1NuYWNrYmFyIiwib25DaGFuZ2VkIiwibWRjU3dpdGNoIiwiTURDVGFiRm91bmRhdGlvbiIsImdldE9mZnNldExlZnQiLCJjb21wdXRlZFdpZHRoXyIsImNvbXB1dGVkTGVmdF8iLCJpc0FjdGl2ZV8iLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2tfIiwiaXNBY3RpdmUiLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2siLCJoYXNJY29uIiwiaGFzVGV4dCIsIm9mZnNldExlZnQiLCJ0YWIiLCJzZXRBY3RpdmUiLCJnZXRDb21wdXRlZFdpZHRoIiwiZ2V0Q29tcHV0ZWRMZWZ0IiwiaXNEZWZhdWx0UHJldmVudGVkT25DbGljayIsInByZXZlbnRzRGVmYXVsdE9uQ2xpY2siLCJzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2siLCJtZWFzdXJlU2VsZiIsIlRBQl9TRUxFQ1RPUiIsIklORElDQVRPUl9TRUxFQ1RPUiIsIk1EQ1RhYkJhckZvdW5kYXRpb24iLCJiaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50IiwidW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50Iiwic2V0U3R5bGVGb3JJbmRpY2F0b3IiLCJnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvciIsImdldE51bWJlck9mVGFicyIsImlzVGFiQWN0aXZlQXRJbmRleCIsInNldFRhYkFjdGl2ZUF0SW5kZXgiLCJpc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrRm9yVGFiQXRJbmRleCIsInNldFByZXZlbnREZWZhdWx0T25DbGlja0ZvclRhYkF0SW5kZXgiLCJtZWFzdXJlVGFiQXRJbmRleCIsImdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4IiwiZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleCIsImlzSW5kaWNhdG9yU2hvd25fIiwiYWN0aXZlVGFiSW5kZXhfIiwiYWN0aXZlVGFiSW5kZXgiLCJmaW5kQWN0aXZlVGFiSW5kZXhfIiwiZm9yRWFjaFRhYkluZGV4XyIsImxheW91dEluZGljYXRvcl8iLCJpc0luZGljYXRvckZpcnN0UmVuZGVyIiwidHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdCIsInNjYWxlQW10Rm9yQWN0aXZlVGFiV2lkdGgiLCJ0cmFuc2Zvcm1WYWx1ZSIsIml0ZXJhdG9yIiwibnVtVGFicyIsInNob3VsZEJyZWFrIiwicHJldkFjdGl2ZVRhYkluZGV4IiwiaW5kaWNhdG9yU3R5bGVzIiwidGFicyIsIm9uU2VsZWN0IiwiaW5kaWNhdG9yIiwicmVzZXRUYWJzIiwidGFiRWxlbWVudHMiLCJfX3Z1ZV9fIiwiZ2V0QWN0aXZlVGFiSW5kZXgiLCJzd2l0Y2hUb1RhYkF0SW5kZXgiLCJtZGNUYWIiLCJtZGNUYWJCYXIiLCJNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlciIsIkFSSUFfSElEREVOIiwiUk9MRSIsIkhFTFBFUl9URVhUX1BFUlNJU1RFTlQiLCJIRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyIsIk1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIiwicmVtb3ZlQXR0ciIsInNldENvbnRlbnQiLCJpc1ZhbGlkYXRpb24iLCJpbnB1dElzVmFsaWQiLCJoZWxwZXJUZXh0SXNQZXJzaXN0ZW50IiwiaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyIsInZhbGlkYXRpb25Nc2dOZWVkc0Rpc3BsYXkiLCJoaWRlXyIsIk1EQ1RleHRGaWVsZEljb25BZGFwdGVyIiwiSUNPTl9FVkVOVCIsIklDT05fUk9MRSIsIk1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIiwibm90aWZ5SWNvbkFjdGlvbiIsImhhbmRsZUludGVyYWN0aW9uIiwiTURDVGV4dEZpZWxkQWRhcHRlciIsIm9ic2VydmVyIiwibGFiZWxXaWR0aCIsIkFSSUFfQ09OVFJPTFMiLCJJTlBVVF9TRUxFQ1RPUiIsIklDT05fU0VMRUNUT1IiLCJPVVRMSU5FX1NFTEVDVE9SIiwiREVOU0UiLCJGT0NVU0VEIiwiSU5WQUxJRCIsIk9VVExJTkVEIiwiTEFCRUxfU0NBTEUiLCJERU5TRV9MQUJFTF9TQ0FMRSIsIlZBTElEQVRJT05fQVRUUl9XSElURUxJU1QiLCJNRENUZXh0RmllbGRGb3VuZGF0aW9uIiwiaXNWYWxpZCIsImlzRm9jdXNlZF8iLCJpc0JhZElucHV0XyIsInJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyIiwiZGVyZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyIiwiZ2V0TmF0aXZlSW5wdXQiLCJhY3RpdmF0ZUxpbmVSaXBwbGUiLCJkZWFjdGl2YXRlTGluZVJpcHBsZSIsInNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW4iLCJzaGFrZUxhYmVsIiwiZ2V0TGFiZWxXaWR0aCIsImhhc091dGxpbmUiLCJub3RjaE91dGxpbmUiLCJjbG9zZU91dGxpbmUiLCJmb3VuZGF0aW9uTWFwIiwiaGVscGVyVGV4dF8iLCJoZWxwZXJUZXh0IiwiaWNvbl8iLCJyZWNlaXZlZFVzZXJJbnB1dF8iLCJ1c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nXyIsImlzVmFsaWRfIiwiaW5wdXRGb2N1c0hhbmRsZXJfIiwiYWN0aXZhdGVGb2N1cyIsImlucHV0Qmx1ckhhbmRsZXJfIiwiZGVhY3RpdmF0ZUZvY3VzIiwiaW5wdXRJbnB1dEhhbmRsZXJfIiwiYXV0b0NvbXBsZXRlRm9jdXMiLCJzZXRQb2ludGVyWE9mZnNldF8iLCJ0ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfIiwiaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24iLCJ2YWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcl8iLCJtdXRhdGlvbnMiLCJoYW5kbGVWYWxpZGF0aW9uQXR0cmlidXRlTXV0YXRpb24iLCJ2YWxpZGF0aW9uT2JzZXJ2ZXJfIiwibXV0YXRpb25zTGlzdCIsIm11dGF0aW9uIiwic3R5bGVWYWxpZGl0eV8iLCJvcGVuTm90Y2giLCJpc0RlbnNlIiwibGFiZWxTY2FsZSIsInN0eWxlRm9jdXNlZF8iLCJzaG93VG9TY3JlZW5SZWFkZXIiLCJ0YXJnZXRDbGllbnRSZWN0IiwiZXZ0Q29vcmRzIiwiY2xpZW50WCIsImNsaWVudFkiLCJnZXROYXRpdmVJbnB1dF8iLCJzaG91bGRSZW1vdmVMYWJlbEZsb2F0IiwiaXNOYXRpdmVJbnB1dFZhbGlkXyIsInN0eWxlRGlzYWJsZWRfIiwidmFsaWRpdHkiLCJiYWRJbnB1dCIsInZhbGlkIiwic2V0VmFsaWRpdHkiLCJNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXIiLCJQQVRIX1NFTEVDVE9SIiwiSURMRV9PVVRMSU5FX1NFTEVDVE9SIiwiT1VUTElORV9OT1RDSEVEIiwiTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uIiwiZ2V0SGVpZ2h0Iiwic2V0T3V0bGluZVBhdGhBdHRyIiwiZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlIiwibm90Y2hXaWR0aCIsInVwZGF0ZVN2Z1BhdGhfIiwicmFkaXVzU3R5bGVWYWx1ZSIsInJhZGl1cyIsInBhcnNlRmxvYXQiLCJjb3JuZXJXaWR0aCIsImxlYWRpbmdTdHJva2VMZW5ndGgiLCJwYWRkZWROb3RjaFdpZHRoIiwicGF0aE1pZGRsZSIsInBhdGgiLCJoZWxwdGV4dCIsImhlbHB0ZXh0UGVyc2lzdGVudCIsImhlbHB0ZXh0VmFsaWRhdGlvbiIsIm91dGxpbmUiLCJmdWxsd2lkdGgiLCJzaXplIiwibWlubGVuZ3RoIiwibWF4bGVuZ3RoIiwicm93cyIsImNvbHMiLCJpbnB1dENsYXNzZXMiLCJsaW5lUmlwcGxlQ2xhc3NlcyIsImxpbmVSaXBwbGVTdHlsZXMiLCJoZWxwQ2xhc3NlcyIsIm91dGxpbmVDbGFzc2VzIiwib3V0bGluZVBhdGhBdHRyIiwiaW5wdXRQbGFjZUhvbGRlciIsImlucHV0QXJpYUNvbnRyb2xzIiwiaGVscCIsImhhc0xpbmVSaXBwbGUiLCJoYXNMZWFkaW5nSWNvbiIsImhhc1RyYWlsaW5nSWNvbiIsImxhYmVsQ2xhc3Nlc1VwZ3JhZGVkIiwic2V0VmFsaWQiLCJoZWxwZXJUZXh0Rm91bmRhdGlvbiIsInNldFBlcnNpc3RlbnQiLCJzZXRWYWxpZGF0aW9uIiwibGluZVJpcHBsZSIsImljb25Gb3VuZGF0aW9uIiwib3V0bGluZUZvdW5kYXRpb24iLCJpZGxlT3V0bGluZUVsZW1lbnQiLCJvdXRsaW5lSWRsZSIsIk1EQ1RleHRmaWVsZEZvdW5kYXRpb24iLCJzZXRSaXBwbGVDZW50ZXIiLCJ0YXJnZXROb2RlIiwiYXR0cmlidXRlcyIsInNoYWtlIiwibm90Y2giLCJjbG9zZU5vdGNoIiwidGV4dGJveCIsInVwZGF0ZVZhbHVlIiwibWRjVGV4dEZpZWxkIiwiVEhFTUVfQ09MT1JTIiwiVEhFTUVfU1RZTEVTIiwiY29sb3IiLCJiYWNrZ3JvdW5kIiwibWRjVGhlbWUiLCJGSVhFRCIsIkZJWEVEX0xBU1RST1ciLCJGSVhFRF9BVF9MQVNUX1JPVyIsIlRPT0xCQVJfUk9XX0ZMRVhJQkxFIiwiRkxFWElCTEVfREVGQVVMVF9CRUhBVklPUiIsIkZMRVhJQkxFX01BWCIsIkZMRVhJQkxFX01JTiIsIlRJVExFX1NFTEVDVE9SIiwiRklSU1RfUk9XX1NFTEVDVE9SIiwiTUFYX1RJVExFX1NJWkUiLCJNSU5fVElUTEVfU0laRSIsIlRPT0xCQVJfUk9XX0hFSUdIVCIsIlRPT0xCQVJfUk9XX01PQklMRV9IRUlHSFQiLCJUT09MQkFSX01PQklMRV9CUkVBS1BPSU5UIiwiTURDVG9vbGJhckZvdW5kYXRpb24iLCJyZWdpc3RlclNjcm9sbEhhbmRsZXIiLCJkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlciIsImdldFZpZXdwb3J0V2lkdGgiLCJnZXRWaWV3cG9ydFNjcm9sbFkiLCJnZXRPZmZzZXRIZWlnaHQiLCJnZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQiLCJzZXRTdHlsZUZvclRpdGxlRWxlbWVudCIsInNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50Iiwic2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQiLCJjaGVja1Jvd0hlaWdodF8iLCJzY3JvbGxIYW5kbGVyXyIsInVwZGF0ZVRvb2xiYXJTdHlsZXNfIiwiY2hlY2tSb3dIZWlnaHRGcmFtZV8iLCJzY3JvbGxGcmFtZV8iLCJleGVjdXRlZExhc3RDaGFuZ2VfIiwiY2FsY3VsYXRpb25zXyIsInRvb2xiYXJSb3dIZWlnaHQiLCJ0b29sYmFyUmF0aW8iLCJmbGV4aWJsZUV4cGFuc2lvblJhdGlvIiwibWF4VHJhbnNsYXRlWVJhdGlvIiwic2Nyb2xsVGhyZXNob2xkUmF0aW8iLCJ0b29sYmFySGVpZ2h0IiwiZmxleGlibGVFeHBhbnNpb25IZWlnaHQiLCJtYXhUcmFuc2xhdGVZRGlzdGFuY2UiLCJzY3JvbGxUaHJlc2hvbGQiLCJmaXhlZF8iLCJmaXhlZExhc3Ryb3dfIiwiaGFzRmxleGlibGVSb3dfIiwidXNlRmxleERlZmF1bHRCZWhhdmlvcl8iLCJpbml0S2V5UmF0aW9fIiwic2V0S2V5SGVpZ2h0c18iLCJzY3JvbGxUb3AiLCJuZXdUb29sYmFyUm93SGVpZ2h0IiwiZ2V0Um93SGVpZ2h0XyIsInVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMiLCJoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkIiwic2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8iLCJnZXRGbGV4aWJsZUV4cGFuc2lvblJhdGlvXyIsInVwZGF0ZVRvb2xiYXJGbGV4aWJsZVN0YXRlXyIsInVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyIsInVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18iLCJmaXJzdFJvd01heFJhdGlvIiwiYnJlYWtwb2ludCIsInRyYW5zbGF0ZURpc3RhbmNlIiwidXBkYXRlRWxlbWVudFN0eWxlc0RlZmF1bHRCZWhhdmlvcl8iLCJtYXhUaXRsZVNpemUiLCJtaW5UaXRsZVNpemUiLCJjdXJyZW50VGl0bGVTaXplIiwid2F0ZXJmYWxsIiwiZmxleGlibGUiLCJmaXhlZExhc3Ryb3ciLCJmbGV4aWJsZURlZmF1bHQiLCJyb290U3R5bGVzIiwiYWRqdXN0U3R5bGVzIiwic2hyaW5rVG9GaXQiLCJtZGNUb29sYmFyIiwibWRjVG9vbGJhclJvdyIsIm1kY1Rvb2xiYXJTZWN0aW9uIiwibWRjVG9vbGJhck1lbnVJY29uIiwibWRjVG9vbGJhclRpdGxlIiwibWRjVG9vbGJhckljb24iLCJGSVhFRF9DTEFTUyIsIkZJWEVEX1NDUk9MTEVEX0NMQVNTIiwiU0hPUlRfQ0xBU1MiLCJTSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1MiLCJTSE9SVF9DT0xMQVBTRURfQ0xBU1MiLCJERUJPVU5DRV9USFJPVFRMRV9SRVNJWkVfVElNRV9NUyIsIk1BWF9UT1BfQVBQX0JBUl9IRUlHSFQiLCJBQ1RJT05fSVRFTV9TRUxFQ1RPUiIsIk5BVklHQVRJT05fRVZFTlQiLCJOQVZJR0FUSU9OX0lDT05fU0VMRUNUT1IiLCJST09UX1NFTEVDVE9SIiwiTURDVG9wQXBwQmFyQWRhcHRlciIsIk1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uIiwiZ2V0VG9wQXBwQmFySGVpZ2h0IiwicmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlciIsIm5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZCIsImdldFRvdGFsQWN0aW9uSXRlbXMiLCJuYXZDbGlja0hhbmRsZXJfIiwiTURDU2hvcnRUb3BBcHBCYXJGb3VuZGF0aW9uIiwiaXNDb2xsYXBzZWQiLCJzaG9ydEFwcEJhclNjcm9sbEhhbmRsZXJfIiwiaXNBbHdheXNDb2xsYXBzZWQiLCJjdXJyZW50U2Nyb2xsIiwic2hvcnQiLCJzaG9ydENvbGxhcHNlZCIsInByb21pbmVudCIsImhhdmVOYXZpZ2F0aW9uSWNvbiIsIm5hdmljb25DbGFzc2VzIiwiY2xpZW50SGVpZ2h0IiwibmF2aWdhdGlvbkljb24iLCJNRENUb3BBcHBCYXJGb3VuZGF0aW9uIiwiYWN0aW9uaWNvbkNsYXNzZXMiLCJtZGNUb3BBcHBCYXIiLCJtZGNUb3BBcHBCYXJBY3Rpb24iLCJ0eXBvcyIsIm1kY1R5cG9NaXhpbiIsImNsYXNzIiwidHlwbyIsIiRhdHRycyIsIm1kY1R5cG9Qcm9wTWl4aW4iLCJkZWZhdWx0VGFnIiwiZGVmYXVsdFR5cG8iLCJ2YWxpZFR5cG9zIiwibWRjVGV4dFNlY3Rpb24iLCJtZGNUZXh0IiwibWRjRGlzcGxheSIsIm1kY0hlYWRsaW5lIiwibWRjVGl0bGUiLCJtZGNTdWJIZWFkaW5nIiwibWRjQm9keSIsIm1kY0NhcHRpb24iLCJWdWVNRENCdXR0b24iLCJWdWVNRENDYXJkIiwiVnVlTURDQ2hlY2tib3giLCJWdWVNRENDaGlwU2V0IiwiVnVlTURDRGlhbG9nIiwiVnVlTURDRHJhd2VyIiwiVnVlTURDRWxldmF0aW9uIiwiVnVlTURDRmFiIiwiVnVlTURDR3JpZExpc3QiLCJWdWVNRENJY29uIiwiVnVlTURDSWNvblRvZ2dsZSIsIlZ1ZU1EQ0xheW91dEFwcCIsIlZ1ZU1EQ0xheW91dEdyaWQiLCJWdWVNRENMaW5lYXJQcm9ncmVzcyIsIlZ1ZU1EQ0xpc3QiLCJWdWVNRENNZW51IiwiVnVlTURDUmFkaW8iLCJWdWVNRENSaXBwbGUiLCJWdWVNRENTZWxlY3QiLCJWdWVNRENTbGlkZXIiLCJWdWVNRENTbmFja2JhciIsIlZ1ZU1EQ1N3aXRjaCIsIlZ1ZU1EQ1RhYnMiLCJWdWVNRENUZXh0ZmllbGQiLCJWdWVNRENUaGVtZSIsIlZ1ZU1EQ1Rvb2xiYXIiLCJWdWVNRENUb3BBcHBCYXIiLCJWdWVNRENUeXBvZ3JhcGh5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0VBQUEsSUFBSUEseUJBQUo7O0VBRUE7Ozs7OztBQU1BLEVBQU8sU0FBU0MsWUFBVCxHQUFnRTtFQUFBLE1BQTFDQyxTQUEwQyx1RUFBOUJDLE1BQThCO0VBQUEsTUFBdEJDLFlBQXNCLHVFQUFQLEtBQU87O0VBQ3JFLE1BQUlKLHFCQUFxQkssU0FBckIsSUFBa0NELFlBQXRDLEVBQW9EO0VBQ2xELFFBQUlFLGNBQWMsS0FBbEI7RUFDQSxRQUFJO0VBQ0ZKLGdCQUFVSyxRQUFWLENBQW1CQyxnQkFBbkIsQ0FBb0MsTUFBcEMsRUFBNEMsSUFBNUMsRUFBa0Q7RUFDaEQsWUFBSUMsT0FBSixH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
