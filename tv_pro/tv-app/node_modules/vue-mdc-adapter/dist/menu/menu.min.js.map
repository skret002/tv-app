{"version":3,"file":"menu.min.js","sources":["../../components/base/custom-event.js","../../node_modules/@material/base/foundation.js","../../node_modules/@material/menu/constants.js","../../node_modules/@material/menu/adapter.js","../../node_modules/@material/menu/foundation.js","../../node_modules/@material/menu/util.js","../../components/base/base-plugin.js","../../components/menu/mdc-menu.vue","../../components/menu/mdc-menu-item.vue","../../components/menu/mdc-menu-divider.vue","../../components/menu/mdc-menu-anchor.vue","../../components/base/auto-init.js","../../components/menu/entry.js"],"sourcesContent":["/* global CustomEvent */\n\nexport function emitCustomEvent(el, evtType, evtData, shouldBubble = false) {\n  let evt\n  if (typeof CustomEvent === 'function') {\n    evt = new CustomEvent(evtType, {\n      detail: evtData,\n      bubbles: shouldBubble\n    })\n  } else {\n    evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(evtType, shouldBubble, false, evtData)\n  }\n  el.dispatchEvent(evt)\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @template A\n */\nclass MDCFoundation {\n  /** @return enum{cssClasses} */\n  static get cssClasses() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports every\n    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}\n    return {};\n  }\n\n  /** @return enum{strings} */\n  static get strings() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports all\n    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}\n    return {};\n  }\n\n  /** @return enum{numbers} */\n  static get numbers() {\n    // Classes extending MDCFoundation should implement this method to return an object which exports all\n    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}\n    return {};\n  }\n\n  /** @return {!Object} */\n  static get defaultAdapter() {\n    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient\n    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter\n    // validation.\n    return {};\n  }\n\n  /**\n   * @param {A=} adapter\n   */\n  constructor(adapter = {}) {\n    /** @protected {!A} */\n    this.adapter_ = adapter;\n  }\n\n  init() {\n    // Subclasses should override this method to perform initialization routines (registering events, etc.)\n  }\n\n  destroy() {\n    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)\n  }\n}\n\nexport default MDCFoundation;\n","/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @enum {string} */\nconst cssClasses = {\n  ROOT: 'mdc-menu',\n  OPEN: 'mdc-menu--open',\n  ANIMATING_OPEN: 'mdc-menu--animating-open',\n  ANIMATING_CLOSED: 'mdc-menu--animating-closed',\n  SELECTED_LIST_ITEM: 'mdc-list-item--selected',\n};\n\n/** @enum {string} */\nconst strings = {\n  ITEMS_SELECTOR: '.mdc-menu__items',\n  SELECTED_EVENT: 'MDCMenu:selected',\n  CANCEL_EVENT: 'MDCMenu:cancel',\n  ARIA_DISABLED_ATTR: 'aria-disabled',\n};\n\n/** @enum {number} */\nconst numbers = {\n  // Amount of time to wait before triggering a selected event on the menu. Note that this time\n  // will most likely be bumped up once interactive lists are supported to allow for the ripple to\n  // animate before closing the menu\n  SELECTED_TRIGGER_DELAY: 50,\n  // Total duration of menu open animation.\n  TRANSITION_OPEN_DURATION: 120,\n  // Total duration of menu close animation.\n  TRANSITION_CLOSE_DURATION: 75,\n  // Margin left to the edge of the viewport when menu is at maximum possible height.\n  MARGIN_TO_EDGE: 32,\n  // Ratio of anchor width to menu width for switching from corner positioning to center positioning.\n  ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,\n  // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.\n  OFFSET_TO_MENU_HEIGHT_RATIO: 0.1,\n};\n\n/**\n * Enum for bits in the {@see Corner) bitmap.\n * @enum {number}\n */\nconst CornerBit = {\n  BOTTOM: 1,\n  CENTER: 2,\n  RIGHT: 4,\n  FLIP_RTL: 8,\n};\n\n/**\n * Enum for representing an element corner for positioning the menu.\n *\n * The START constants map to LEFT if element directionality is left\n * to right and RIGHT if the directionality is right to left.\n * Likewise END maps to RIGHT or LEFT depending on the directionality.\n *\n * @enum {number}\n */\nconst Corner = {\n  TOP_LEFT: 0,\n  TOP_RIGHT: CornerBit.RIGHT,\n  BOTTOM_LEFT: CornerBit.BOTTOM,\n  BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,\n  TOP_START: CornerBit.FLIP_RTL,\n  TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,\n  BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,\n  BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL,\n};\n\n\nexport {cssClasses, strings, numbers, CornerBit, Corner};\n","/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint no-unused-vars: [2, {\"args\": \"none\"}] */\n\n/**\n * Adapter for MDC Menu. Provides an interface for managing\n * - classes\n * - dom\n * - focus\n * - position\n * - dimensions\n * - event handlers\n *\n * Additionally, provides type information for the adapter to the Closure\n * compiler.\n *\n * Implement this adapter for your framework of choice to delegate updates to\n * the component in your framework of choice. See architecture documentation\n * for more details.\n * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md\n *\n * @record\n */\nclass MDCMenuAdapter {\n  /** @param {string} className */\n  addClass(className) {}\n\n  /** @param {string} className */\n  removeClass(className) {}\n\n  /**\n   * @param {string} className\n   * @return {boolean}\n   */\n  hasClass(className) {}\n\n  /** @return {boolean} */\n  hasNecessaryDom() {}\n\n  /**\n   * @param {EventTarget} target\n   * @param {string} attributeName\n   * @return {string}\n   */\n  getAttributeForEventTarget(target, attributeName) {}\n\n  /** @return {{ width: number, height: number }} */\n  getInnerDimensions() {}\n\n  /** @return {boolean} */\n  hasAnchor() {}\n\n  /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */\n  getAnchorDimensions() {}\n\n  /** @return {{ width: number, height: number }} */\n  getWindowDimensions() {}\n\n  /** @return {number} */\n  getNumberOfItems() {}\n\n  /**\n   * @param {string} type\n   * @param {function(!Event)} handler\n   */\n  registerInteractionHandler(type, handler) {}\n\n  /**\n   * @param {string} type\n   * @param {function(!Event)} handler\n   */\n  deregisterInteractionHandler(type, handler) {}\n\n  /** @param {function(!Event)} handler */\n  registerBodyClickHandler(handler) {}\n\n  /** @param {function(!Event)} handler */\n  deregisterBodyClickHandler(handler) {}\n\n  /**\n   * @param {EventTarget} target\n   * @return {number}\n   */\n  getIndexForEventTarget(target) {}\n\n  /** @param {{index: number}} evtData */\n  notifySelected(evtData) {}\n\n  notifyCancel() {}\n\n  saveFocus() {}\n\n  restoreFocus() {}\n\n  /** @return {boolean} */\n  isFocused() {}\n\n  focus() {}\n\n  /** @return {number} */\n  getFocusedItemIndex() /* number */ {}\n\n  /** @param {number} index */\n  focusItemAtIndex(index) {}\n\n  /** @return {boolean} */\n  isRtl() {}\n\n  /** @param {string} origin */\n  setTransformOrigin(origin) {}\n\n  /** @param {{\n  *   top: (string|undefined),\n  *   right: (string|undefined),\n  *   bottom: (string|undefined),\n  *   left: (string|undefined)\n  * }} position */\n  setPosition(position) {}\n\n  /** @param {string} height */\n  setMaxHeight(height) {}\n\n  /**\n   * @param {number} index\n   * @param {string} attr\n   * @param {string} value\n   */\n  setAttrForOptionAtIndex(index, attr, value) {}\n\n  /**\n   * @param {number} index\n   * @param {string} attr\n   */\n  rmAttrForOptionAtIndex(index, attr) {}\n\n  /**\n   * @param {number} index\n   * @param {string} className\n   */\n  addClassForOptionAtIndex(index, className) {}\n\n  /**\n   * @param {number} index\n   * @param {string} className\n   */\n  rmClassForOptionAtIndex(index, className) {}\n}\n\nexport {MDCMenuAdapter};\n","/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {{\n *   top: number,\n *   right: number,\n *   bottom: number,\n *   left: number\n * }}\n */\nlet AnchorMargin;\n\n/* eslint-disable no-unused-vars */\n/**\n * @typedef {{\n *   viewport: { width: number, height: number },\n *   viewportDistance: {top: number, right: number, bottom: number, left: number},\n *   anchorHeight: number,\n *   anchorWidth: number,\n *   menuHeight: number,\n *   menuWidth: number,\n * }}\n */\nlet AutoLayoutMeasurements;\n/* eslint-enable no-unused-vars */\n\nimport MDCFoundation from '@material/base/foundation';\nimport {MDCMenuAdapter} from './adapter';\nimport {cssClasses, strings, numbers, Corner, CornerBit} from './constants';\n\n/**\n * @extends {MDCFoundation<!MDCMenuAdapter>}\n */\nclass MDCMenuFoundation extends MDCFoundation {\n  /** @return enum{cssClasses} */\n  static get cssClasses() {\n    return cssClasses;\n  }\n\n  /** @return enum{strings} */\n  static get strings() {\n    return strings;\n  }\n\n  /** @return enum{numbers} */\n  static get numbers() {\n    return numbers;\n  }\n\n  /** @return enum{number} */\n  static get Corner() {\n    return Corner;\n  }\n\n  /**\n   * {@see MDCMenuAdapter} for typing information on parameters and return\n   * types.\n   * @return {!MDCMenuAdapter}\n   */\n  static get defaultAdapter() {\n    return /** @type {!MDCMenuAdapter} */ ({\n      addClass: () => {},\n      removeClass: () => {},\n      hasClass: () => false,\n      hasNecessaryDom: () => false,\n      getAttributeForEventTarget: () => {},\n      getInnerDimensions: () => ({}),\n      hasAnchor: () => false,\n      getAnchorDimensions: () => ({}),\n      getWindowDimensions: () => ({}),\n      getNumberOfItems: () => 0,\n      registerInteractionHandler: () => {},\n      deregisterInteractionHandler: () => {},\n      registerBodyClickHandler: () => {},\n      deregisterBodyClickHandler: () => {},\n      getIndexForEventTarget: () => 0,\n      notifySelected: () => {},\n      notifyCancel: () => {},\n      saveFocus: () => {},\n      restoreFocus: () => {},\n      isFocused: () => false,\n      focus: () => {},\n      getFocusedItemIndex: () => -1,\n      focusItemAtIndex: () => {},\n      isRtl: () => false,\n      setTransformOrigin: () => {},\n      setPosition: () => {},\n      setMaxHeight: () => {},\n      setAttrForOptionAtIndex: () => {},\n      rmAttrForOptionAtIndex: () => {},\n      addClassForOptionAtIndex: () => {},\n      rmClassForOptionAtIndex: () => {},\n    });\n  }\n\n  /** @param {!MDCMenuAdapter} adapter */\n  constructor(adapter) {\n    super(Object.assign(MDCMenuFoundation.defaultAdapter, adapter));\n\n    /** @private {function(!Event)} */\n    this.clickHandler_ = (evt) => this.handlePossibleSelected_(evt);\n    /** @private {function(!Event)} */\n    this.keydownHandler_ = (evt) => this.handleKeyboardDown_(evt);\n    /** @private {function(!Event)} */\n    this.keyupHandler_ = (evt) => this.handleKeyboardUp_(evt);\n    /** @private {function(!Event)} */\n    this.documentClickHandler_ = (evt) => this.handleDocumentClick_(evt);\n    /** @private {boolean} */\n    this.isOpen_ = false;\n    /** @private {number} */\n    this.openAnimationEndTimerId_ = 0;\n    /** @private {number} */\n    this.closeAnimationEndTimerId_ = 0;\n    /** @private {number} */\n    this.selectedTriggerTimerId_ = 0;\n    /** @private {number} */\n    this.animationRequestId_ = 0;\n    /** @private {!{ width: number, height: number }} */\n    this.dimensions_;\n    /** @private {number} */\n    this.itemHeight_;\n    /** @private {Corner} */\n    this.anchorCorner_ = Corner.TOP_START;\n    /** @private {AnchorMargin} */\n    this.anchorMargin_ = {top: 0, right: 0, bottom: 0, left: 0};\n    /** @private {?AutoLayoutMeasurements} */\n    this.measures_ = null;\n    /** @private {number} */\n    this.selectedIndex_ = -1;\n    /** @private {boolean} */\n    this.rememberSelection_ = false;\n    /** @private {boolean} */\n    this.quickOpen_ = false;\n\n    // A keyup event on the menu needs to have a corresponding keydown\n    // event on the menu. If the user opens the menu with a keydown event on a\n    // button, the menu will only get the key up event causing buggy behavior with selected elements.\n    /** @private {boolean} */\n    this.keyDownWithinMenu_ = false;\n  }\n\n  init() {\n    const {ROOT, OPEN} = MDCMenuFoundation.cssClasses;\n\n    if (!this.adapter_.hasClass(ROOT)) {\n      throw new Error(`${ROOT} class required in root element.`);\n    }\n\n    if (!this.adapter_.hasNecessaryDom()) {\n      throw new Error(`Required DOM nodes missing in ${ROOT} component.`);\n    }\n\n    if (this.adapter_.hasClass(OPEN)) {\n      this.isOpen_ = true;\n    }\n\n    this.adapter_.registerInteractionHandler('click', this.clickHandler_);\n    this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);\n    this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);\n  }\n\n  destroy() {\n    clearTimeout(this.selectedTriggerTimerId_);\n    clearTimeout(this.openAnimationEndTimerId_);\n    clearTimeout(this.closeAnimationEndTimerId_);\n    // Cancel any currently running animations.\n    cancelAnimationFrame(this.animationRequestId_);\n    this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);\n    this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);\n    this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);\n    this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);\n  }\n\n  /**\n   * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.\n   */\n  setAnchorCorner(corner) {\n    this.anchorCorner_ = corner;\n  }\n\n  /**\n   * @param {!AnchorMargin} margin 4-plet of margins from anchor.\n   */\n  setAnchorMargin(margin) {\n    this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;\n    this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;\n    this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;\n    this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;\n  }\n\n  /** @param {boolean} rememberSelection */\n  setRememberSelection(rememberSelection) {\n    this.rememberSelection_ = rememberSelection;\n    this.setSelectedIndex(-1);\n  }\n\n  /** @param {boolean} quickOpen */\n  setQuickOpen(quickOpen) {\n    this.quickOpen_ = quickOpen;\n  }\n\n  /**\n   * @param {?number} focusIndex\n   * @private\n   */\n  focusOnOpen_(focusIndex) {\n    if (focusIndex === null) {\n      // If this instance of MDCMenu remembers selections, and the user has\n      // made a selection, then focus the last selected item\n      if (this.rememberSelection_ && this.selectedIndex_ >= 0) {\n        this.adapter_.focusItemAtIndex(this.selectedIndex_);\n        return;\n      }\n\n      this.adapter_.focus();\n      // If that doesn't work, focus first item instead.\n      if (!this.adapter_.isFocused()) {\n        this.adapter_.focusItemAtIndex(0);\n      }\n    } else {\n      this.adapter_.focusItemAtIndex(focusIndex);\n    }\n  }\n\n  /**\n   * Handle clicks and cancel the menu if not a child list-item\n   * @param {!Event} evt\n   * @private\n   */\n  handleDocumentClick_(evt) {\n    let el = evt.target;\n\n    while (el && el !== document.documentElement) {\n      if (this.adapter_.getIndexForEventTarget(el) !== -1) {\n        return;\n      }\n      el = el.parentNode;\n    }\n\n    this.adapter_.notifyCancel();\n    this.close(evt);\n  };\n\n  /**\n   * Handle keys that we want to repeat on hold (tab and arrows).\n   * @param {!Event} evt\n   * @return {boolean}\n   * @private\n   */\n  handleKeyboardDown_(evt) {\n    // Do nothing if Alt, Ctrl or Meta are pressed.\n    if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n      return true;\n    }\n\n    const {keyCode, key, shiftKey} = evt;\n    const isTab = key === 'Tab' || keyCode === 9;\n    const isArrowUp = key === 'ArrowUp' || keyCode === 38;\n    const isArrowDown = key === 'ArrowDown' || keyCode === 40;\n    const isSpace = key === 'Space' || keyCode === 32;\n    const isEnter = key === 'Enter' || keyCode === 13;\n    // The menu needs to know if the keydown event was triggered on the menu\n    this.keyDownWithinMenu_ = isEnter || isSpace;\n\n    const focusedItemIndex = this.adapter_.getFocusedItemIndex();\n    const lastItemIndex = this.adapter_.getNumberOfItems() - 1;\n\n    if (shiftKey && isTab && focusedItemIndex === 0) {\n      this.adapter_.focusItemAtIndex(lastItemIndex);\n      evt.preventDefault();\n      return false;\n    }\n\n    if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {\n      this.adapter_.focusItemAtIndex(0);\n      evt.preventDefault();\n      return false;\n    }\n\n    // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling\n    if (isArrowUp || isArrowDown || isSpace) {\n      evt.preventDefault();\n    }\n\n    if (isArrowUp) {\n      if (focusedItemIndex === 0 || this.adapter_.isFocused()) {\n        this.adapter_.focusItemAtIndex(lastItemIndex);\n      } else {\n        this.adapter_.focusItemAtIndex(focusedItemIndex - 1);\n      }\n    } else if (isArrowDown) {\n      if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {\n        this.adapter_.focusItemAtIndex(0);\n      } else {\n        this.adapter_.focusItemAtIndex(focusedItemIndex + 1);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).\n   * @param {!Event} evt\n   * @return {boolean}\n   * @private\n   */\n  handleKeyboardUp_(evt) {\n    // Do nothing if Alt, Ctrl or Meta are pressed.\n    if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n      return true;\n    }\n\n    const {keyCode, key} = evt;\n    const isEnter = key === 'Enter' || keyCode === 13;\n    const isSpace = key === 'Space' || keyCode === 32;\n    const isEscape = key === 'Escape' || keyCode === 27;\n\n    if (isEnter || isSpace) {\n      // If the keydown event didn't occur on the menu, then it should\n      // disregard the possible selected event.\n      if (this.keyDownWithinMenu_) {\n        this.handlePossibleSelected_(evt);\n      }\n      this.keyDownWithinMenu_ = false;\n    }\n\n    if (isEscape) {\n      this.adapter_.notifyCancel();\n      this.close();\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {!Event} evt\n   * @private\n   */\n  handlePossibleSelected_(evt) {\n    if (this.adapter_.getAttributeForEventTarget(evt.target, strings.ARIA_DISABLED_ATTR) === 'true') {\n      return;\n    }\n    const targetIndex = this.adapter_.getIndexForEventTarget(evt.target);\n    if (targetIndex < 0) {\n      return;\n    }\n    // Debounce multiple selections\n    if (this.selectedTriggerTimerId_) {\n      return;\n    }\n    this.selectedTriggerTimerId_ = setTimeout(() => {\n      this.selectedTriggerTimerId_ = 0;\n      this.close();\n      if (this.rememberSelection_) {\n        this.setSelectedIndex(targetIndex);\n      }\n      this.adapter_.notifySelected({index: targetIndex});\n    }, numbers.SELECTED_TRIGGER_DELAY);\n  }\n\n  /**\n   * @return {AutoLayoutMeasurements} Measurements used to position menu popup.\n   */\n  getAutoLayoutMeasurements_() {\n    const anchorRect = this.adapter_.getAnchorDimensions();\n    const viewport = this.adapter_.getWindowDimensions();\n\n    return {\n      viewport: viewport,\n      viewportDistance: {\n        top: anchorRect.top,\n        right: viewport.width - anchorRect.right,\n        left: anchorRect.left,\n        bottom: viewport.height - anchorRect.bottom,\n      },\n      anchorHeight: anchorRect.height,\n      anchorWidth: anchorRect.width,\n      menuHeight: this.dimensions_.height,\n      menuWidth: this.dimensions_.width,\n    };\n  }\n\n  /**\n   * Computes the corner of the anchor from which to animate and position the menu.\n   * @return {Corner}\n   * @private\n   */\n  getOriginCorner_() {\n    // Defaults: open from the top left.\n    let corner = Corner.TOP_LEFT;\n\n    const {viewportDistance, anchorHeight, anchorWidth, menuHeight, menuWidth} = this.measures_;\n    const isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);\n    const availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom\n      : viewportDistance.top + this.anchorMargin_.top;\n    const availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom\n      : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;\n\n    const topOverflow = menuHeight - availableTop;\n    const bottomOverflow = menuHeight - availableBottom;\n    if (bottomOverflow > 0 && topOverflow < bottomOverflow) {\n      corner |= CornerBit.BOTTOM;\n    }\n\n    const isRtl = this.adapter_.isRtl();\n    const isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);\n    const avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);\n    const isAlignedRight = (avoidHorizontalOverlap && !isRtl) ||\n      (!avoidHorizontalOverlap && isFlipRtl && isRtl);\n    const availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right :\n      viewportDistance.left + this.anchorMargin_.left;\n    const availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right :\n      viewportDistance.right + anchorWidth - this.anchorMargin_.left;\n\n    const leftOverflow = menuWidth - availableLeft;\n    const rightOverflow = menuWidth - availableRight;\n\n    if ((leftOverflow < 0 && isAlignedRight && isRtl) ||\n        (avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0) ||\n        (rightOverflow > 0 && leftOverflow < rightOverflow)) {\n      corner |= CornerBit.RIGHT;\n    }\n\n    return corner;\n  }\n\n  /**\n   * @param {Corner} corner Origin corner of the menu.\n   * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.\n   * @private\n   */\n  getHorizontalOriginOffset_(corner) {\n    const {anchorWidth} = this.measures_;\n    const isRightAligned = Boolean(corner & CornerBit.RIGHT);\n    const avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);\n    let x = 0;\n    if (isRightAligned) {\n      const rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;\n      x = rightOffset;\n    } else {\n      const leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;\n      x = leftOffset;\n    }\n    return x;\n  }\n\n  /**\n   * @param {Corner} corner Origin corner of the menu.\n   * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.\n   * @private\n   */\n  getVerticalOriginOffset_(corner) {\n    const {viewport, viewportDistance, anchorHeight, menuHeight} = this.measures_;\n    const isBottomAligned = Boolean(corner & CornerBit.BOTTOM);\n    const {MARGIN_TO_EDGE} = MDCMenuFoundation.numbers;\n    const avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);\n    const canOverlapVertically = !avoidVerticalOverlap;\n    let y = 0;\n\n    if (isBottomAligned) {\n      y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;\n      // adjust for when menu can overlap anchor, but too tall to be aligned to bottom\n      // anchor corner. Bottom margin is ignored in such cases.\n      if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {\n        y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));\n      }\n    } else {\n      y = avoidVerticalOverlap ? (anchorHeight + this.anchorMargin_.bottom) : this.anchorMargin_.top;\n      // adjust for when menu can overlap anchor, but too tall to be aligned to top\n      // anchor corners. Top margin is ignored in that case.\n      if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {\n        y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));\n      }\n    }\n    return y;\n  }\n\n  /**\n   * @param {Corner} corner Origin corner of the menu.\n   * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.\n   * @private\n   */\n  getMenuMaxHeight_(corner) {\n    let maxHeight = 0;\n    const {viewportDistance} = this.measures_;\n    const isBottomAligned = Boolean(corner & CornerBit.BOTTOM);\n\n    // When maximum height is not specified, it is handled from css.\n    if (this.anchorCorner_ & CornerBit.BOTTOM) {\n      if (isBottomAligned) {\n        maxHeight = viewportDistance.top + this.anchorMargin_.top;\n      } else {\n        maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;\n      }\n    }\n\n    return maxHeight;\n  }\n\n  /** @private */\n  autoPosition_() {\n    if (!this.adapter_.hasAnchor()) {\n      return;\n    }\n\n    // Compute measurements for autoposition methods reuse.\n    this.measures_ = this.getAutoLayoutMeasurements_();\n\n    const corner = this.getOriginCorner_();\n    const maxMenuHeight = this.getMenuMaxHeight_(corner);\n    let verticalAlignment = (corner & CornerBit.BOTTOM) ? 'bottom' : 'top';\n    let horizontalAlignment = (corner & CornerBit.RIGHT) ? 'right' : 'left';\n    const horizontalOffset = this.getHorizontalOriginOffset_(corner);\n    const verticalOffset = this.getVerticalOriginOffset_(corner);\n    const position = {\n      [horizontalAlignment]: horizontalOffset ? horizontalOffset + 'px' : '0',\n      [verticalAlignment]: verticalOffset ? verticalOffset + 'px' : '0',\n    };\n    const {anchorWidth, menuHeight, menuWidth} = this.measures_;\n    // Center align when anchor width is comparable or greater than menu, otherwise keep corner.\n    if (anchorWidth / menuWidth > numbers.ANCHOR_TO_MENU_WIDTH_RATIO) {\n      horizontalAlignment = 'center';\n    }\n\n    // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that\n    // scale animation is \"anchored\" on the anchor.\n    if (!(this.anchorCorner_ & CornerBit.BOTTOM) &&\n        Math.abs(verticalOffset / menuHeight) > numbers.OFFSET_TO_MENU_HEIGHT_RATIO) {\n      const verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;\n      const originPercent = (corner & CornerBit.BOTTOM) ? 100 - verticalOffsetPercent : verticalOffsetPercent;\n      verticalAlignment = Math.round(originPercent * 100) / 100 + '%';\n    }\n\n    this.adapter_.setTransformOrigin(`${horizontalAlignment} ${verticalAlignment}`);\n    this.adapter_.setPosition(position);\n    this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : '');\n\n    // Clear measures after positioning is complete.\n    this.measures_ = null;\n  }\n\n  /**\n   * Open the menu.\n   * @param {{focusIndex: ?number}=} options\n   */\n  open({focusIndex = null} = {}) {\n    this.adapter_.saveFocus();\n\n    if (!this.quickOpen_) {\n      this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);\n    }\n\n    this.animationRequestId_ = requestAnimationFrame(() => {\n      this.dimensions_ = this.adapter_.getInnerDimensions();\n      this.autoPosition_();\n      this.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);\n      this.focusOnOpen_(focusIndex);\n      this.adapter_.registerBodyClickHandler(this.documentClickHandler_);\n      if (!this.quickOpen_) {\n        this.openAnimationEndTimerId_ = setTimeout(() => {\n          this.openAnimationEndTimerId_ = 0;\n          this.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);\n        }, numbers.TRANSITION_OPEN_DURATION);\n      }\n    });\n    this.isOpen_ = true;\n  }\n\n  /**\n   * Closes the menu.\n   * @param {Event=} evt\n   */\n  close(evt = null) {\n    const targetIsDisabled = evt ?\n      this.adapter_.getAttributeForEventTarget(evt.target, strings.ARIA_DISABLED_ATTR) === 'true' :\n      false;\n\n    if (targetIsDisabled) {\n      return;\n    }\n\n    this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);\n\n    if (!this.quickOpen_) {\n      this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);\n    }\n\n    requestAnimationFrame(() => {\n      this.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);\n      if (!this.quickOpen_) {\n        this.closeAnimationEndTimerId_ = setTimeout(() => {\n          this.closeAnimationEndTimerId_ = 0;\n          this.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);\n        }, numbers.TRANSITION_CLOSE_DURATION);\n      }\n    });\n    this.isOpen_ = false;\n    this.adapter_.restoreFocus();\n  }\n\n  /** @return {boolean} */\n  isOpen() {\n    return this.isOpen_;\n  }\n\n  /** @return {number} */\n  getSelectedIndex() {\n    return this.selectedIndex_;\n  }\n\n  /**\n   * @param {number} index Index of the item to set as selected.\n   */\n  setSelectedIndex(index) {\n    if (index === this.selectedIndex_) {\n      return;\n    }\n\n    const prevSelectedIndex = this.selectedIndex_;\n    if (prevSelectedIndex >= 0) {\n      this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');\n      this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses.SELECTED_LIST_ITEM);\n    }\n\n    this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;\n    if (this.selectedIndex_ >= 0) {\n      this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');\n      this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses.SELECTED_LIST_ITEM);\n    }\n  }\n}\n\nexport {MDCMenuFoundation, AnchorMargin};\n","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @type {string|undefined} */\nlet storedTransformPropertyName_;\n\n/**\n * Returns the name of the correct transform property to use on the current browser.\n * @param {!Window} globalObj\n * @param {boolean=} forceRefresh\n * @return {string}\n */\nfunction getTransformPropertyName(globalObj, forceRefresh = false) {\n  if (storedTransformPropertyName_ === undefined || forceRefresh) {\n    const el = globalObj.document.createElement('div');\n    const transformPropertyName = ('transform' in el.style ? 'transform' : 'webkitTransform');\n    storedTransformPropertyName_ = transformPropertyName;\n  }\n\n  return storedTransformPropertyName_;\n}\n\n/**\n * Clamps a value between the minimum and the maximum, returning the clamped value.\n * @param {number} value\n * @param {number} min\n * @param {number} max\n * @return {number}\n */\nfunction clamp(value, min = 0, max = 1) {\n  return Math.min(max, Math.max(min, value));\n}\n\n\n/**\n * Returns the easing value to apply at time t, for a given cubic bezier curve.\n * Control points P0 and P3 are assumed to be (0,0) and (1,1), respectively.\n * Parameters are as follows:\n * - time: The current time in the animation, scaled between 0 and 1.\n * - x1: The x value of control point P1.\n * - y1: The y value of control point P1.\n * - x2: The x value of control point P2.\n * - y2: The y value of control point P2.\n * @param {number} time\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @return {number}\n */\nfunction bezierProgress(time, x1, y1, x2, y2) {\n  return getBezierCoordinate_(solvePositionFromXValue_(time, x1, x2), y1, y2);\n}\n\n/**\n * Compute a single coordinate at a position point between 0 and 1.\n * c1 and c2 are the matching coordinate on control points P1 and P2, respectively.\n * Control points P0 and P3 are assumed to be (0,0) and (1,1), respectively.\n * Adapted from https://github.com/google/closure-library/blob/master/closure/goog/math/bezier.js.\n * @param {number} t\n * @param {number} c1\n * @param {number} c2\n * @return {number}\n */\nfunction getBezierCoordinate_(t, c1, c2) {\n  // Special case start and end.\n  if (t === 0 || t === 1) {\n    return t;\n  }\n\n  // Step one - from 4 points to 3\n  let ic0 = t * c1;\n  let ic1 = c1 + t * (c2 - c1);\n  const ic2 = c2 + t * (1 - c2);\n\n  // Step two - from 3 points to 2\n  ic0 += t * (ic1 - ic0);\n  ic1 += t * (ic2 - ic1);\n\n  // Final step - last point\n  return ic0 + t * (ic1 - ic0);\n}\n\n/**\n * Project a point onto the Bezier curve, from a given X. Calculates the position t along the curve.\n * Adapted from https://github.com/google/closure-library/blob/master/closure/goog/math/bezier.js.\n * @param {number} xVal\n * @param {number} x1\n * @param {number} x2\n * @return {number}\n */\nfunction solvePositionFromXValue_(xVal, x1, x2) {\n  const EPSILON = 1e-6;\n  const MAX_ITERATIONS = 8;\n\n  if (xVal <= 0) {\n    return 0;\n  } else if (xVal >= 1) {\n    return 1;\n  }\n\n  // Initial estimate of t using linear interpolation.\n  let t = xVal;\n\n  // Try gradient descent to solve for t. If it works, it is very fast.\n  let tMin = 0;\n  let tMax = 1;\n  let value = 0;\n  for (let i = 0; i < MAX_ITERATIONS; i++) {\n    value = getBezierCoordinate_(t, x1, x2);\n    const derivative = (getBezierCoordinate_(t + EPSILON, x1, x2) - value) / EPSILON;\n    if (Math.abs(value - xVal) < EPSILON) {\n      return t;\n    } else if (Math.abs(derivative) < EPSILON) {\n      break;\n    } else {\n      if (value < xVal) {\n        tMin = t;\n      } else {\n        tMax = t;\n      }\n      t -= (value - xVal) / derivative;\n    }\n  }\n\n  // If the gradient descent got stuck in a local minimum, e.g. because\n  // the derivative was close to 0, use a Dichotomy refinement instead.\n  // We limit the number of interations to 8.\n  for (let i = 0; Math.abs(value - xVal) > EPSILON && i < MAX_ITERATIONS; i++) {\n    if (value < xVal) {\n      tMin = t;\n      t = (t + tMax) / 2;\n    } else {\n      tMax = t;\n      t = (t + tMin) / 2;\n    }\n    value = getBezierCoordinate_(t, x1, x2);\n  }\n  return t;\n}\n\nexport {getTransformPropertyName, clamp, bezierProgress};\n","export function BasePlugin(components) {\n  return {\n    version: '__VERSION__',\n    install: vm => {\n      for (let key in components) {\n        let component = components[key]\n        vm.component(component.name, component)\n      }\n    },\n    components\n  }\n}\n","<template>\n  <div \n    ref=\"root\" \n    :class=\"classes\" \n    :style=\"styles\" \n    class=\"mdc-menu mdc-simple-menu\" \n    tabindex=\"-1\">\n    <ul \n      ref=\"items\" \n      class=\"mdc-simple-menu__items mdc-list\" \n      role=\"menu\" \n      aria-hidden=\"true\">\n      <slot/>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport { MDCMenuFoundation } from '@material/menu/foundation'\nimport { getTransformPropertyName } from '@material/menu/util'\nimport { emitCustomEvent } from '../base'\n\nexport default {\n  name: 'mdc-menu',\n  model: {\n    prop: 'open',\n    event: 'change'\n  },\n  props: {\n    open: [Boolean, Object],\n    'quick-open': Boolean,\n    'anchor-corner': [String, Number],\n    'anchor-margin': Object\n  },\n  data() {\n    return {\n      classes: {},\n      styles: {},\n      items: []\n    }\n  },\n  watch: {\n    open: 'onOpen_',\n    quickOpen(nv) {\n      this.foundation.setQuickOpen(nv)\n    },\n    anchorCorner(nv) {\n      this.foundation.setAnchorCorner(Number(nv))\n    },\n    anchorMargin(nv) {\n      this.foundation.setAnchorMargin(nv)\n    }\n  },\n  mounted() {\n    const refreshItems = () => {\n      this.items = [].slice.call(\n        this.$refs.items.querySelectorAll('.mdc-list-item[role]')\n      )\n      this.$emit('update')\n    }\n    this.slotObserver = new MutationObserver(() => refreshItems())\n    this.slotObserver.observe(this.$el, {\n      childList: true,\n      subtree: true\n    })\n\n    this._previousFocus = undefined\n\n    this.foundation = new MDCMenuFoundation({\n      addClass: className => this.$set(this.classes, className, true),\n      removeClass: className => this.$delete(this.classes, className),\n      hasClass: className => this.$refs.root.classList.contains(className),\n      hasNecessaryDom: () => Boolean(this.$refs.items),\n      getAttributeForEventTarget: (target, attributeName) =>\n        target.getAttribute(attributeName),\n      getInnerDimensions: () => ({\n        width: this.$refs.items.offsetWidth,\n        height: this.$refs.items.offsetHeight\n      }),\n      hasAnchor: () =>\n        this.$refs.root.parentElement &&\n        this.$refs.root.parentElement.classList.contains('mdc-menu-anchor'),\n      getAnchorDimensions: () =>\n        this.$refs.root.parentElement.getBoundingClientRect(),\n      getWindowDimensions: () => ({\n        width: window.innerWidth,\n        height: window.innerHeight\n      }),\n      getNumberOfItems: () => this.items.length,\n      registerInteractionHandler: (type, handler) =>\n        this.$refs.root.addEventListener(type, handler),\n      deregisterInteractionHandler: (type, handler) =>\n        this.$refs.root.removeEventListener(type, handler),\n      registerBodyClickHandler: handler =>\n        document.body.addEventListener('click', handler),\n      deregisterBodyClickHandler: handler =>\n        document.body.removeEventListener('click', handler),\n      getIndexForEventTarget: target => this.items.indexOf(target),\n      notifySelected: evtData => {\n        const evt = {\n          index: evtData.index,\n          item: this.items[evtData.index]\n        }\n        this.$emit('change', false)\n        this.$emit('select', evt)\n        emitCustomEvent(this.$el, MDCMenuFoundation.strings.SELECTED_EVENT, evt)\n      },\n      notifyCancel: () => {\n        this.$emit('change', false)\n        this.$emit('cancel')\n        emitCustomEvent(this.$el, MDCMenuFoundation.strings.CANCEL_EVENT, {})\n      },\n      saveFocus: () => {\n        this._previousFocus = document.activeElement\n      },\n      restoreFocus: () => {\n        if (this._previousFocus) {\n          this._previousFocus.focus()\n        }\n      },\n      isFocused: () => document.activeElement === this.$refs.root,\n      focus: () => this.$refs.root.focus(),\n      getFocusedItemIndex: () => this.items.indexOf(document.activeElement),\n      focusItemAtIndex: index => this.items[index].focus(),\n      isRtl: () =>\n        getComputedStyle(this.$refs.root).getPropertyValue('direction') ===\n        'rtl',\n      setTransformOrigin: origin => {\n        this.$set(\n          this.styles,\n          `${getTransformPropertyName(window)}-origin`,\n          origin\n        )\n      },\n      setPosition: position => {\n        this.$set(this.styles, 'left', position.left)\n        this.$set(this.styles, 'right', position.right)\n        this.$set(this.styles, 'top', position.top)\n        this.$set(this.styles, 'bottom', position.bottom)\n      },\n      setMaxHeight: height => {\n        this.$set(this.styles, 'max-height', height)\n      },\n      setAttrForOptionAtIndex: (index, attr, value) => {\n        this.items[index].setAttribute(attr, value)\n      },\n      rmAttrForOptionAtIndex: (index, attr) => {\n        this.items[index].removeAttribute(attr)\n      },\n      addClassForOptionAtIndex: (index, className) => {\n        this.items[index].classList.add(className)\n      },\n      rmClassForOptionAtIndex: (index, className) => {\n        this.items[index].classList.remove(className)\n      }\n    })\n\n    refreshItems()\n    this.foundation.init()\n    if (this.anchorCorner !== void 0) {\n      this.foundation.setAnchorCorner(Number(this.anchorCorner))\n    }\n    if (this.anchorMargin !== void 0) {\n      this.foundation.setAnchorMargin(this.anchorMargin)\n    }\n  },\n  beforeDestroy() {\n    this._previousFocus = null\n    this.slotObserver.disconnect()\n    this.foundation.destroy()\n  },\n\n  methods: {\n    onOpen_(value) {\n      if (value) {\n        this.foundation.open(typeof value === 'object' ? value : void 0)\n      } else {\n        this.foundation.close()\n      }\n    },\n    show(options) {\n      this.foundation.open(options)\n    },\n    hide() {\n      this.foundation.close()\n    },\n    isOpen() {\n      return this.foundation ? this.foundation.isOpen() : false\n    }\n  }\n}\n</script>\n","<template>\n  <li \n    :tabindex=\"disabled?'-1':'0'\" \n    :aria-disabled=\"disabled\" \n    class=\"mdc-menu-item mdc-list-item\"\n    role=\"menuitem\"\n  >\n    <slot/>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: 'mdc-menu-item',\n  props: {\n    disabled: Boolean\n  }\n}\n</script>\n","<template>\n  <li \n    role=\"separator\" \n    class=\"mdc-menu-divider mdc-list-divider\"/>\n</template>\n\n<script>\nexport default {\n  name: 'mdc-menu-divider'\n}\n</script>\n","<template>\n  <div class=\"mdc-menu-anchor\">\n    <slot/>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'mdc-menu-anchor'\n}\n</script>\n","export function autoInit(plugin) {\n  // Auto-install\n  let _Vue = null\n  if (typeof window !== 'undefined') {\n    _Vue = window.Vue\n  } else if (typeof global !== 'undefined') {\n    /*global global*/\n    _Vue = global.Vue\n  }\n  if (_Vue) {\n    _Vue.use(plugin)\n  }\n}\n","import './styles.scss'\nimport { autoInit } from '../base'\nimport plugin from './index.js'\nexport default plugin\n\nautoInit(plugin)\n"],"names":["emitCustomEvent","el","evtType","evtData","shouldBubble","evt","CustomEvent","document","createEvent","initCustomEvent","dispatchEvent","MDCFoundation","adapter","adapter_","cssClasses","className","target","attributeName","type","handler","index","origin","position","height","attr","value","strings","numbers","CornerBit","Corner","MDCMenuFoundation","babelHelpers.extends","defaultAdapter","clickHandler_","_this","handlePossibleSelected_","keydownHandler_","handleKeyboardDown_","keyupHandler_","handleKeyboardUp_","documentClickHandler_","handleDocumentClick_","isOpen_","openAnimationEndTimerId_","closeAnimationEndTimerId_","selectedTriggerTimerId_","animationRequestId_","dimensions_","itemHeight_","anchorCorner_","TOP_START","anchorMargin_","top","right","bottom","left","measures_","selectedIndex_","rememberSelection_","quickOpen_","keyDownWithinMenu_","ROOT","OPEN","this","hasClass","Error","hasNecessaryDom","registerInteractionHandler","deregisterInteractionHandler","deregisterBodyClickHandler","corner","margin","rememberSelection","setSelectedIndex","quickOpen","focusIndex","focusItemAtIndex","focus","isFocused","documentElement","getIndexForEventTarget","parentNode","notifyCancel","close","altKey","ctrlKey","metaKey","keyCode","key","shiftKey","isTab","isArrowUp","isArrowDown","isSpace","isEnter","focusedItemIndex","getFocusedItemIndex","lastItemIndex","getNumberOfItems","preventDefault","isEscape","getAttributeForEventTarget","ARIA_DISABLED_ATTR","targetIndex","setTimeout","_this2","notifySelected","SELECTED_TRIGGER_DELAY","anchorRect","getAnchorDimensions","viewport","getWindowDimensions","width","TOP_LEFT","viewportDistance","anchorHeight","anchorWidth","menuHeight","menuWidth","isBottomAligned","Boolean","availableTop","bottomOverflow","isRtl","isFlipRtl","avoidHorizontalOverlap","isAlignedRight","leftOverflow","rightOverflow","isRightAligned","x","MARGIN_TO_EDGE","avoidVerticalOverlap","canOverlapVertically","y","Math","min","maxHeight","hasAnchor","getAutoLayoutMeasurements_","getOriginCorner_","maxMenuHeight","getMenuMaxHeight_","verticalAlignment","horizontalAlignment","horizontalOffset","getHorizontalOriginOffset_","verticalOffset","getVerticalOriginOffset_","ANCHOR_TO_MENU_WIDTH_RATIO","abs","OFFSET_TO_MENU_HEIGHT_RATIO","verticalOffsetPercent","originPercent","round","setTransformOrigin","setPosition","setMaxHeight","saveFocus","addClass","ANIMATING_OPEN","requestAnimationFrame","_this3","getInnerDimensions","autoPosition_","focusOnOpen_","registerBodyClickHandler","removeClass","TRANSITION_OPEN_DURATION","ANIMATING_CLOSED","_this4","TRANSITION_CLOSE_DURATION","restoreFocus","prevSelectedIndex","rmAttrForOptionAtIndex","rmClassForOptionAtIndex","SELECTED_LIST_ITEM","setAttrForOptionAtIndex","addClassForOptionAtIndex","storedTransformPropertyName_","components","render","Object","String","Number","nv","foundation","setQuickOpen","setAnchorCorner","setAnchorMargin","refreshItems","items","slice","call","$refs","querySelectorAll","$emit","slotObserver","MutationObserver","observe","$el","_previousFocus","undefined","$set","classes","$delete","root","classList","contains","getAttribute","offsetWidth","offsetHeight","parentElement","getBoundingClientRect","window","innerWidth","innerHeight","length","addEventListener","removeEventListener","body","indexOf","SELECTED_EVENT","CANCEL_EVENT","activeElement","getComputedStyle","getPropertyValue","styles","globalObj","forceRefresh","transformPropertyName","createElement","style","getTransformPropertyName","setAttribute","removeAttribute","add","remove","init","anchorCorner","anchorMargin","disconnect","destroy","open","options","isOpen","component","name","plugin","_Vue","Vue","global","use"],"mappings":"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"}