/**
* @module vue-mdc-adaptertextfield 0.15.4
* @exports VueMDCTextfield
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.35.2"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.VueMDCTextfield = factory());
}(this, (function () { 'use strict';

    var supportsPassive_ = void 0;

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */
    function applyPassive() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_ === undefined || forceRefresh) {
        var isSupported = false;
        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = { passive: true };
            }
          });
        } catch (e) {
          //empty
        }

        supportsPassive_ = isSupported;
      }

      return supportsPassive_;
    }

    function autoInit(plugin) {
      // Auto-install
      var _Vue = null;
      if (typeof window !== 'undefined') {
        _Vue = window.Vue;
      } else if (typeof global !== 'undefined') {
        /*global global*/
        _Vue = global.Vue;
      }
      if (_Vue) {
        _Vue.use(plugin);
      }
    }

    function BasePlugin(components) {
      return {
        version: '0.15.4',
        install: function install(vm) {
          for (var key in components) {
            var component = components[key];
            vm.component(component.name, component);
          }
        },
        components: components
      };
    }

    var CustomElement = {
      functional: true,
      render: function render(createElement, context) {
        return createElement(context.props.is || context.props.tag || 'div', context.data, context.children);
      }
    };

    var CustomElementMixin = {
      components: {
        CustomElement: CustomElement
      }
    };

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var defineProperty = function (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    };

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    var inherits = function (subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };

    var possibleConstructorReturn = function (self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };

    /* global CustomEvent */

    function extractIconProp(iconProp) {
      if (typeof iconProp === 'string') {
        return {
          classes: { 'material-icons': true },
          content: iconProp
        };
      } else if (iconProp instanceof Array) {
        return {
          classes: iconProp.reduce(function (result, value) {
            return _extends(result, defineProperty({}, value, true));
          }, {})
        };
      } else if ((typeof iconProp === 'undefined' ? 'undefined' : _typeof(iconProp)) === 'object') {
        return {
          classes: iconProp.className.split(' ').reduce(function (result, value) {
            return _extends(result, defineProperty({}, value, true));
          }, {}),
          content: iconProp.textContent
        };
      }
    }

    var DispatchFocusMixin = {
      data: function data() {
        return { hasFocus: false };
      },

      methods: {
        onMouseDown: function onMouseDown() {
          this._active = true;
        },
        onMouseUp: function onMouseUp() {
          this._active = false;
        },
        onFocusEvent: function onFocusEvent() {
          var _this = this;

          // dispatch async to let time to other focus event to propagate
          setTimeout(function () {
            return _this.dispatchFocusEvent();
          }, 0);
        },
        onBlurEvent: function onBlurEvent() {
          var _this2 = this;

          // dispatch async to let time to other focus event to propagate
          // also filtur blur if mousedown
          this._active || setTimeout(function () {
            return _this2.dispatchFocusEvent();
          }, 0);
        },
        dispatchFocusEvent: function dispatchFocusEvent() {
          var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);
          if (hasFocus != this.hasFocus) {
            this.$emit(hasFocus ? 'focus' : 'blur');
            this.hasFocus = hasFocus;
          }
        }
      },
      mounted: function mounted() {
        this.$el.addEventListener('focusin', this.onFocusEvent);
        this.$el.addEventListener('focusout', this.onBlurEvent);
        this.$el.addEventListener('mousedown', this.onMouseDown);
        this.$el.addEventListener('mouseup', this.onMouseUp);
      },
      beforeDestroy: function beforeDestroy() {
        this.$el.removeEventListener('focusin', this.onFocusEvent);
        this.$el.removeEventListener('focusout', this.onBlurEvent);
        this.$el.removeEventListener('mousedown', this.onMouseDown);
        this.$el.removeEventListener('mouseup', this.onMouseUp);
      }
    };

    var uid_ = 0;

    var VMAUniqueIdMixin = {
      beforeCreate: function beforeCreate() {
        this.vma_uid_ = "_vma_" + uid_++;
      }
    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation = function () {
      createClass(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get$$1() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }

        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get$$1() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }

        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get$$1() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }

        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get$$1() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }

        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        classCallCheck(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      createClass(MDCFoundation, [{
        key: "init",
        value: function init() {
          // Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);
      return MDCFoundation;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Text Field Helper Text.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the TextField helper text into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTextFieldHelperTextAdapter = function () {
      function MDCTextFieldHelperTextAdapter() {
        classCallCheck(this, MDCTextFieldHelperTextAdapter);
      }

      createClass(MDCTextFieldHelperTextAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the helper text element.
         * @param {string} className
         */
        value: function addClass(className) {}

        /**
         * Removes a class from the helper text element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}

        /**
         * Returns whether or not the helper text element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}

        /**
         * Sets an attribute with a given value on the helper text element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}

        /**
         * Removes an attribute from the helper text element.
         * @param {string} attr
         */

      }, {
        key: "removeAttr",
        value: function removeAttr(attr) {}

        /**
         * Sets the text content for the helper text element.
         * @param {string} content
         */

      }, {
        key: "setContent",
        value: function setContent(content) {}
      }]);
      return MDCTextFieldHelperTextAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings = {
      ARIA_HIDDEN: 'aria-hidden',
      ROLE: 'role'
    };

    /** @enum {string} */
    var cssClasses = {
      HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
      HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
    };

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
     * @final
     */

    var MDCTextFieldHelperTextFoundation = function (_MDCFoundation) {
      inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);
      createClass(MDCTextFieldHelperTextFoundation, null, [{
        key: 'cssClasses',

        /** @return enum {string} */
        get: function get$$1() {
          return cssClasses;
        }

        /** @return enum {string} */

      }, {
        key: 'strings',
        get: function get$$1() {
          return strings;
        }

        /**
         * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldHelperTextAdapter}
         */

      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return (/** @type {!MDCTextFieldHelperTextAdapter} */{
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setAttr: function setAttr() {},
              removeAttr: function removeAttr() {},
              setContent: function setContent() {}
            }
          );
        }

        /**
         * @param {!MDCTextFieldHelperTextAdapter} adapter
         */

      }]);

      function MDCTextFieldHelperTextFoundation(adapter) {
        classCallCheck(this, MDCTextFieldHelperTextFoundation);
        return possibleConstructorReturn(this, (MDCTextFieldHelperTextFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperTextFoundation)).call(this, _extends(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
      }

      /**
       * Sets the content of the helper text field.
       * @param {string} content
       */


      createClass(MDCTextFieldHelperTextFoundation, [{
        key: 'setContent',
        value: function setContent(content) {
          this.adapter_.setContent(content);
        }

        /** @param {boolean} isPersistent Sets the persistency of the helper text. */

      }, {
        key: 'setPersistent',
        value: function setPersistent(isPersistent) {
          if (isPersistent) {
            this.adapter_.addClass(cssClasses.HELPER_TEXT_PERSISTENT);
          } else {
            this.adapter_.removeClass(cssClasses.HELPER_TEXT_PERSISTENT);
          }
        }

        /**
         * @param {boolean} isValidation True to make the helper text act as an
         *   error validation message.
         */

      }, {
        key: 'setValidation',
        value: function setValidation(isValidation) {
          if (isValidation) {
            this.adapter_.addClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
          } else {
            this.adapter_.removeClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
          }
        }

        /** Makes the helper text visible to the screen reader. */

      }, {
        key: 'showToScreenReader',
        value: function showToScreenReader() {
          this.adapter_.removeAttr(strings.ARIA_HIDDEN);
        }

        /**
         * Sets the validity of the helper text based on the input validity.
         * @param {boolean} inputIsValid
         */

      }, {
        key: 'setValidity',
        value: function setValidity(inputIsValid) {
          var helperTextIsPersistent = this.adapter_.hasClass(cssClasses.HELPER_TEXT_PERSISTENT);
          var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses.HELPER_TEXT_VALIDATION_MSG);
          var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

          if (validationMsgNeedsDisplay) {
            this.adapter_.setAttr(strings.ROLE, 'alert');
          } else {
            this.adapter_.removeAttr(strings.ROLE);
          }

          if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
            this.hide_();
          }
        }

        /**
         * Hides the help text from screen readers.
         * @private
         */

      }, {
        key: 'hide_',
        value: function hide_() {
          this.adapter_.setAttr(strings.ARIA_HIDDEN, 'true');
        }
      }]);
      return MDCTextFieldHelperTextFoundation;
    }(MDCFoundation);

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Text Field Icon.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the text field icon into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTextFieldIconAdapter = function () {
      function MDCTextFieldIconAdapter() {
        classCallCheck(this, MDCTextFieldIconAdapter);
      }

      createClass(MDCTextFieldIconAdapter, [{
        key: "getAttr",

        /**
         * Gets the value of an attribute on the icon element.
         * @param {string} attr
         * @return {string}
         */
        value: function getAttr(attr) {}

        /**
         * Sets an attribute on the icon element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}

        /**
         * Removes an attribute from the icon element.
         * @param {string} attr
         */

      }, {
        key: "removeAttr",
        value: function removeAttr(attr) {}

        /**
         * Registers an event listener on the icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}

        /**
         * Deregisters an event listener on the icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}

        /**
         * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
         */

      }, {
        key: "notifyIconAction",
        value: function notifyIconAction() {}
      }]);
      return MDCTextFieldIconAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$1 = {
      ICON_EVENT: 'MDCTextField:icon',
      ICON_ROLE: 'button'
    };

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
     * @final
     */

    var MDCTextFieldIconFoundation = function (_MDCFoundation) {
      inherits(MDCTextFieldIconFoundation, _MDCFoundation);
      createClass(MDCTextFieldIconFoundation, null, [{
        key: 'strings',

        /** @return enum {string} */
        get: function get$$1() {
          return strings$1;
        }

        /**
         * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldIconAdapter}
         */

      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return (/** @type {!MDCTextFieldIconAdapter} */{
              getAttr: function getAttr() {},
              setAttr: function setAttr() {},
              removeAttr: function removeAttr() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {},
              notifyIconAction: function notifyIconAction() {}
            }
          );
        }

        /**
         * @param {!MDCTextFieldIconAdapter} adapter
         */

      }]);

      function MDCTextFieldIconFoundation(adapter) {
        classCallCheck(this, MDCTextFieldIconFoundation);

        /** @private {string?} */
        var _this = possibleConstructorReturn(this, (MDCTextFieldIconFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldIconFoundation)).call(this, _extends(MDCTextFieldIconFoundation.defaultAdapter, adapter)));

        _this.savedTabIndex_ = null;

        /** @private {function(!Event): undefined} */
        _this.interactionHandler_ = function (evt) {
          return _this.handleInteraction(evt);
        };
        return _this;
      }

      createClass(MDCTextFieldIconFoundation, [{
        key: 'init',
        value: function init() {
          var _this2 = this;

          this.savedTabIndex_ = this.adapter_.getAttr('tabindex');

          ['click', 'keydown'].forEach(function (evtType) {
            _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
          });
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          var _this3 = this;

          ['click', 'keydown'].forEach(function (evtType) {
            _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
          });
        }

        /**
         * Sets the content of the helper text field.
         * @param {boolean} disabled
         */

      }, {
        key: 'setDisabled',
        value: function setDisabled(disabled) {
          if (!this.savedTabIndex_) {
            return;
          }

          if (disabled) {
            this.adapter_.setAttr('tabindex', '-1');
            this.adapter_.removeAttr('role');
          } else {
            this.adapter_.setAttr('tabindex', this.savedTabIndex_);
            this.adapter_.setAttr('role', strings$1.ICON_ROLE);
          }
        }

        /**
         * Handles an interaction event
         * @param {!Event} evt
         */

      }, {
        key: 'handleInteraction',
        value: function handleInteraction(evt) {
          if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
            this.adapter_.notifyIconAction();
          }
        }
      }]);
      return MDCTextFieldIconFoundation;
    }(MDCFoundation);

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Adapter for MDC Text Field.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Text Field into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCTextFieldAdapter = function () {
      function MDCTextFieldAdapter() {
        classCallCheck(this, MDCTextFieldAdapter);
      }

      createClass(MDCTextFieldAdapter, [{
        key: 'addClass',

        /**
         * Adds a class to the root Element.
         * @param {string} className
         */
        value: function addClass(className) {}

        /**
         * Removes a class from the root Element.
         * @param {string} className
         */

      }, {
        key: 'removeClass',
        value: function removeClass(className) {}

        /**
         * Returns true if the root element contains the given class name.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: 'hasClass',
        value: function hasClass(className) {}

        /**
         * Registers an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: 'registerTextFieldInteractionHandler',
        value: function registerTextFieldInteractionHandler(type, handler) {}

        /**
         * Deregisters an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: 'deregisterTextFieldInteractionHandler',
        value: function deregisterTextFieldInteractionHandler(type, handler) {}

        /**
         * Registers an event listener on the native input element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: 'registerInputInteractionHandler',
        value: function registerInputInteractionHandler(evtType, handler) {}

        /**
         * Deregisters an event listener on the native input element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: 'deregisterInputInteractionHandler',
        value: function deregisterInputInteractionHandler(evtType, handler) {}

        /**
         * Registers a validation attribute change listener on the input element.
         * @param {function(!Array): undefined} handler
         * @return {!MutationObserver}
         */

      }, {
        key: 'registerValidationAttributeChangeHandler',
        value: function registerValidationAttributeChangeHandler(handler) {}

        /**
         * Disconnects a validation attribute observer on the input element.
         * @param {!MutationObserver} observer
         */

      }, {
        key: 'deregisterValidationAttributeChangeHandler',
        value: function deregisterValidationAttributeChangeHandler(observer) {}

        /**
         * Returns an object representing the native text input element, with a
         * similar API shape. The object returned should include the value, disabled
         * and badInput properties, as well as the checkValidity() function. We never
         * alter the value within our code, however we do update the disabled
         * property, so if you choose to duck-type the return value for this method
         * in your implementation it's important to keep this in mind. Also note that
         * this method can return null, which the foundation will handle gracefully.
         * @return {?Element|?NativeInputType}
         */

      }, {
        key: 'getNativeInput',
        value: function getNativeInput() {}

        /**
         * Returns true if the textfield is focused.
         * We achieve this via `document.activeElement === this.root_`.
         * @return {boolean}
         */

      }, {
        key: 'isFocused',
        value: function isFocused() {}

        /**
         * Returns true if the direction of the root element is set to RTL.
         * @return {boolean}
         */

      }, {
        key: 'isRtl',
        value: function isRtl() {}

        /**
         * Activates the line ripple.
         */

      }, {
        key: 'activateLineRipple',
        value: function activateLineRipple() {}

        /**
         * Deactivates the line ripple.
         */

      }, {
        key: 'deactivateLineRipple',
        value: function deactivateLineRipple() {}

        /**
         * Sets the transform origin of the line ripple.
         * @param {number} normalizedX
         */

      }, {
        key: 'setLineRippleTransformOrigin',
        value: function setLineRippleTransformOrigin(normalizedX) {}

        /**
         * Only implement if label exists.
         * Shakes label if shouldShake is true.
         * @param {boolean} shouldShake
         */

      }, {
        key: 'shakeLabel',
        value: function shakeLabel(shouldShake) {}

        /**
         * Only implement if label exists.
         * Floats the label above the input element if shouldFloat is true.
         * @param {boolean} shouldFloat
         */

      }, {
        key: 'floatLabel',
        value: function floatLabel(shouldFloat) {}

        /**
         * Returns true if label element exists, false if it doesn't.
         * @return {boolean}
         */

      }, {
        key: 'hasLabel',
        value: function hasLabel() {}

        /**
         * Only implement if label exists.
         * Returns width of label in pixels.
         * @return {number}
         */

      }, {
        key: 'getLabelWidth',
        value: function getLabelWidth() {}

        /**
         * Returns true if outline element exists, false if it doesn't.
         * @return {boolean}
         */

      }, {
        key: 'hasOutline',
        value: function hasOutline() {}

        /**
         * Only implement if outline element exists.
         * Updates SVG Path and outline element based on the
         * label element width and RTL context.
         * @param {number} labelWidth
         * @param {boolean=} isRtl
         */

      }, {
        key: 'notchOutline',
        value: function notchOutline(labelWidth, isRtl) {}

        /**
         * Only implement if outline element exists.
         * Closes notch in outline element.
         */

      }, {
        key: 'closeOutline',
        value: function closeOutline() {}
      }]);
      return MDCTextFieldAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$2 = {
      ARIA_CONTROLS: 'aria-controls',
      INPUT_SELECTOR: '.mdc-text-field__input',
      LABEL_SELECTOR: '.mdc-floating-label',
      ICON_SELECTOR: '.mdc-text-field__icon',
      OUTLINE_SELECTOR: '.mdc-notched-outline',
      LINE_RIPPLE_SELECTOR: '.mdc-line-ripple'
    };

    /** @enum {string} */
    var cssClasses$1 = {
      ROOT: 'mdc-text-field',
      UPGRADED: 'mdc-text-field--upgraded',
      DISABLED: 'mdc-text-field--disabled',
      DENSE: 'mdc-text-field--dense',
      FOCUSED: 'mdc-text-field--focused',
      INVALID: 'mdc-text-field--invalid',
      BOX: 'mdc-text-field--box',
      OUTLINED: 'mdc-text-field--outlined'
    };

    /** @enum {number} */
    var numbers = {
      LABEL_SCALE: 0.75,
      DENSE_LABEL_SCALE: 0.923
    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
    // under section: `Validation-related attributes`
    var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];

    /**
     * @extends {MDCFoundation<!MDCTextFieldAdapter>}
     * @final
     */

    var MDCTextFieldFoundation = function (_MDCFoundation) {
      inherits(MDCTextFieldFoundation, _MDCFoundation);
      createClass(MDCTextFieldFoundation, [{
        key: 'shouldShake',


        /** @return {boolean} */
        get: function get$$1() {
          return !this.isValid() && !this.isFocused_;
        }

        /** @return {boolean} */

      }, {
        key: 'shouldFloat',
        get: function get$$1() {
          return !this.isBadInput_() && (!!this.getValue() || this.isFocused_);
        }

        /**
         * {@see MDCTextFieldAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldAdapter}
         */

      }], [{
        key: 'cssClasses',

        /** @return enum {string} */
        get: function get$$1() {
          return cssClasses$1;
        }

        /** @return enum {string} */

      }, {
        key: 'strings',
        get: function get$$1() {
          return strings$2;
        }

        /** @return enum {string} */

      }, {
        key: 'numbers',
        get: function get$$1() {
          return numbers;
        }
      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return (/** @type {!MDCTextFieldAdapter} */{
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
              deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
              registerInputInteractionHandler: function registerInputInteractionHandler() {},
              deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
              registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {},
              deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {},
              getNativeInput: function getNativeInput() {},
              isFocused: function isFocused() {},
              isRtl: function isRtl() {},
              activateLineRipple: function activateLineRipple() {},
              deactivateLineRipple: function deactivateLineRipple() {},
              setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {},
              shakeLabel: function shakeLabel() {},
              floatLabel: function floatLabel() {},
              hasLabel: function hasLabel() {},
              getLabelWidth: function getLabelWidth() {},
              hasOutline: function hasOutline() {},
              notchOutline: function notchOutline() {},
              closeOutline: function closeOutline() {}
            }
          );
        }

        /**
         * @param {!MDCTextFieldAdapter} adapter
         * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
         */

      }]);

      function MDCTextFieldFoundation(adapter) {
        var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /** @type {!FoundationMapType} */{};
        classCallCheck(this, MDCTextFieldFoundation);

        /** @type {!MDCTextFieldHelperTextFoundation|undefined} */
        var _this = possibleConstructorReturn(this, (MDCTextFieldFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldFoundation)).call(this, _extends(MDCTextFieldFoundation.defaultAdapter, adapter)));

        _this.helperText_ = foundationMap.helperText;
        /** @type {!MDCTextFieldIconFoundation|undefined} */
        _this.icon_ = foundationMap.icon;

        /** @private {boolean} */
        _this.isFocused_ = false;
        /** @private {boolean} */
        _this.receivedUserInput_ = false;
        /** @private {boolean} */
        _this.useCustomValidityChecking_ = false;
        /** @private {boolean} */
        _this.isValid_ = true;
        /** @private {function(): undefined} */
        _this.inputFocusHandler_ = function () {
          return _this.activateFocus();
        };
        /** @private {function(): undefined} */
        _this.inputBlurHandler_ = function () {
          return _this.deactivateFocus();
        };
        /** @private {function(): undefined} */
        _this.inputInputHandler_ = function () {
          return _this.autoCompleteFocus();
        };
        /** @private {function(!Event): undefined} */
        _this.setPointerXOffset_ = function (evt) {
          return _this.setTransformOrigin(evt);
        };
        /** @private {function(!Event): undefined} */
        _this.textFieldInteractionHandler_ = function () {
          return _this.handleTextFieldInteraction();
        };
        /** @private {function(!Array): undefined} */
        _this.validationAttributeChangeHandler_ = function (mutations) {
          return _this.handleValidationAttributeMutation(mutations);
        };
        /** @private {!MutationObserver} */
        _this.validationObserver_;
        return _this;
      }

      createClass(MDCTextFieldFoundation, [{
        key: 'init',
        value: function init() {
          var _this2 = this;

          this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
          // Ensure label does not collide with any pre-filled value.
          if (this.adapter_.hasLabel() && this.getValue()) {
            this.adapter_.floatLabel(this.shouldFloat);
            this.notchOutline(this.shouldFloat);
          }

          if (this.adapter_.isFocused()) {
            this.inputFocusHandler_();
          }

          this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
          this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
          this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
          ['mousedown', 'touchstart'].forEach(function (evtType) {
            _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
          });
          ['click', 'keydown'].forEach(function (evtType) {
            _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
          });
          this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          var _this3 = this;

          this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
          this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
          this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
          this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
          ['mousedown', 'touchstart'].forEach(function (evtType) {
            _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
          });
          ['click', 'keydown'].forEach(function (evtType) {
            _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
          });
          this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
        }

        /**
         * Handles user interactions with the Text Field.
         */

      }, {
        key: 'handleTextFieldInteraction',
        value: function handleTextFieldInteraction() {
          if (this.adapter_.getNativeInput().disabled) {
            return;
          }
          this.receivedUserInput_ = true;
        }

        /**
         * Handles validation attribute changes
         * @param {!Array<MutationRecord>} mutationsList
         */

      }, {
        key: 'handleValidationAttributeMutation',
        value: function handleValidationAttributeMutation(mutationsList) {
          var _this4 = this;

          mutationsList.some(function (mutation) {
            if (VALIDATION_ATTR_WHITELIST.indexOf(mutation.attributeName) > -1) {
              _this4.styleValidity_(true);
              return true;
            }
          });
        }

        /**
         * Opens/closes the notched outline.
         * @param {boolean} openNotch
         */

      }, {
        key: 'notchOutline',
        value: function notchOutline(openNotch) {
          if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
            return;
          }

          if (openNotch) {
            var isDense = this.adapter_.hasClass(cssClasses$1.DENSE);
            var labelScale = isDense ? numbers.DENSE_LABEL_SCALE : numbers.LABEL_SCALE;
            var labelWidth = this.adapter_.getLabelWidth() * labelScale;
            var isRtl = this.adapter_.isRtl();
            this.adapter_.notchOutline(labelWidth, isRtl);
          } else {
            this.adapter_.closeOutline();
          }
        }

        /**
         * Activates the text field focus state.
         */

      }, {
        key: 'activateFocus',
        value: function activateFocus() {
          this.isFocused_ = true;
          this.styleFocused_(this.isFocused_);
          this.adapter_.activateLineRipple();
          this.notchOutline(this.shouldFloat);
          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(this.shouldShake);
            this.adapter_.floatLabel(this.shouldFloat);
          }
          if (this.helperText_) {
            this.helperText_.showToScreenReader();
          }
        }

        /**
         * Sets the line ripple's transform origin, so that the line ripple activate
         * animation will animate out from the user's click location.
         * @param {!Event} evt
         */

      }, {
        key: 'setTransformOrigin',
        value: function setTransformOrigin(evt) {
          var targetClientRect = evt.target.getBoundingClientRect();
          var evtCoords = { x: evt.clientX, y: evt.clientY };
          var normalizedX = evtCoords.x - targetClientRect.left;
          this.adapter_.setLineRippleTransformOrigin(normalizedX);
        }

        /**
         * Activates the Text Field's focus state in cases when the input value
         * changes without user input (e.g. programatically).
         */

      }, {
        key: 'autoCompleteFocus',
        value: function autoCompleteFocus() {
          if (!this.receivedUserInput_) {
            this.activateFocus();
          }
        }

        /**
         * Deactivates the Text Field's focus state.
         */

      }, {
        key: 'deactivateFocus',
        value: function deactivateFocus() {
          this.isFocused_ = false;
          this.adapter_.deactivateLineRipple();
          var input = this.getNativeInput_();
          var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
          var isValid = this.isValid();
          this.styleValidity_(isValid);
          this.styleFocused_(this.isFocused_);
          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(this.shouldShake);
            this.adapter_.floatLabel(this.shouldFloat);
            this.notchOutline(this.shouldFloat);
          }
          if (shouldRemoveLabelFloat) {
            this.receivedUserInput_ = false;
          }
        }

        /**
         * @return {string} The value of the input Element.
         */

      }, {
        key: 'getValue',
        value: function getValue() {
          return this.getNativeInput_().value;
        }

        /**
         * @param {string} value The value to set on the input Element.
         */

      }, {
        key: 'setValue',
        value: function setValue(value) {
          this.getNativeInput_().value = value;
          var isValid = this.isValid();
          this.styleValidity_(isValid);
          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(this.shouldShake);
            this.adapter_.floatLabel(this.shouldFloat);
            this.notchOutline(this.shouldFloat);
          }
        }

        /**
         * @return {boolean} If a custom validity is set, returns that value.
         *     Otherwise, returns the result of native validity checks.
         */

      }, {
        key: 'isValid',
        value: function isValid() {
          return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();
        }

        /**
         * @param {boolean} isValid Sets the validity state of the Text Field.
         */

      }, {
        key: 'setValid',
        value: function setValid(isValid) {
          this.useCustomValidityChecking_ = true;
          this.isValid_ = isValid;
          // Retrieve from the getter to ensure correct logic is applied.
          isValid = this.isValid();
          this.styleValidity_(isValid);
          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(this.shouldShake);
          }
        }

        /**
         * @return {boolean} True if the Text Field is disabled.
         */

      }, {
        key: 'isDisabled',
        value: function isDisabled() {
          return this.getNativeInput_().disabled;
        }

        /**
         * @param {boolean} disabled Sets the text-field disabled or enabled.
         */

      }, {
        key: 'setDisabled',
        value: function setDisabled(disabled) {
          this.getNativeInput_().disabled = disabled;
          this.styleDisabled_(disabled);
        }

        /**
         * @param {string} content Sets the content of the helper text.
         */

      }, {
        key: 'setHelperTextContent',
        value: function setHelperTextContent(content) {
          if (this.helperText_) {
            this.helperText_.setContent(content);
          }
        }

        /**
         * @return {boolean} True if the Text Field input fails in converting the
         *     user-supplied value.
         * @private
         */

      }, {
        key: 'isBadInput_',
        value: function isBadInput_() {
          return this.getNativeInput_().validity.badInput;
        }

        /**
         * @return {boolean} The result of native validity checking
         *     (ValidityState.valid).
         */

      }, {
        key: 'isNativeInputValid_',
        value: function isNativeInputValid_() {
          return this.getNativeInput_().validity.valid;
        }

        /**
         * Styles the component based on the validity state.
         * @param {boolean} isValid
         * @private
         */

      }, {
        key: 'styleValidity_',
        value: function styleValidity_(isValid) {
          var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

          if (isValid) {
            this.adapter_.removeClass(INVALID);
          } else {
            this.adapter_.addClass(INVALID);
          }
          if (this.helperText_) {
            this.helperText_.setValidity(isValid);
          }
        }

        /**
         * Styles the component based on the focused state.
         * @param {boolean} isFocused
         * @private
         */

      }, {
        key: 'styleFocused_',
        value: function styleFocused_(isFocused) {
          var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

          if (isFocused) {
            this.adapter_.addClass(FOCUSED);
          } else {
            this.adapter_.removeClass(FOCUSED);
          }
        }

        /**
         * Styles the component based on the disabled state.
         * @param {boolean} isDisabled
         * @private
         */

      }, {
        key: 'styleDisabled_',
        value: function styleDisabled_(isDisabled) {
          var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
              DISABLED = _MDCTextFieldFoundati.DISABLED,
              INVALID = _MDCTextFieldFoundati.INVALID;

          if (isDisabled) {
            this.adapter_.addClass(DISABLED);
            this.adapter_.removeClass(INVALID);
          } else {
            this.adapter_.removeClass(DISABLED);
          }
          if (this.icon_) {
            this.icon_.setDisabled(isDisabled);
          }
        }

        /**
         * @return {!Element|!NativeInputType} The native text input from the
         * host environment, or a dummy if none exists.
         * @private
         */

      }, {
        key: 'getNativeInput_',
        value: function getNativeInput_() {
          return this.adapter_.getNativeInput() ||
          /** @type {!NativeInputType} */{
            value: '',
            disabled: false,
            validity: {
              badInput: false,
              valid: true
            }
          };
        }
      }]);
      return MDCTextFieldFoundation;
    }(MDCFoundation);

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC TextField Line Ripple.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the line ripple into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCLineRippleAdapter = function () {
      function MDCLineRippleAdapter() {
        classCallCheck(this, MDCLineRippleAdapter);
      }

      createClass(MDCLineRippleAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the line ripple element.
         * @param {string} className
         */
        value: function addClass(className) {}

        /**
         * Removes a class from the line ripple element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}

        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}

        /**
         * Sets the style property with propertyName to value on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(propertyName, value) {}

        /**
         * Registers an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerEventHandler",
        value: function registerEventHandler(evtType, handler) {}

        /**
         * Deregisters an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterEventHandler",
        value: function deregisterEventHandler(evtType, handler) {}
      }]);
      return MDCLineRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$2 = {
      LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
      LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
    };

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @extends {MDCFoundation<!MDCLineRippleAdapter>}
     * @final
     */

    var MDCLineRippleFoundation = function (_MDCFoundation) {
      inherits(MDCLineRippleFoundation, _MDCFoundation);
      createClass(MDCLineRippleFoundation, null, [{
        key: 'cssClasses',

        /** @return enum {string} */
        get: function get$$1() {
          return cssClasses$2;
        }

        /**
         * {@see MDCLineRippleAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCLineRippleAdapter}
         */

      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return (/** @type {!MDCLineRippleAdapter} */{
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setStyle: function setStyle() {},
              registerEventHandler: function registerEventHandler() {},
              deregisterEventHandler: function deregisterEventHandler() {}
            }
          );
        }

        /**
         * @param {!MDCLineRippleAdapter=} adapter
         */

      }]);

      function MDCLineRippleFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /** @type {!MDCLineRippleAdapter} */{};
        classCallCheck(this, MDCLineRippleFoundation);

        /** @private {function(!Event): undefined} */
        var _this = possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, _extends(MDCLineRippleFoundation.defaultAdapter, adapter)));

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd(evt);
        };
        return _this;
      }

      createClass(MDCLineRippleFoundation, [{
        key: 'init',
        value: function init() {
          this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        }

        /**
         * Activates the line ripple
         */

      }, {
        key: 'activate',
        value: function activate() {
          this.adapter_.removeClass(cssClasses$2.LINE_RIPPLE_DEACTIVATING);
          this.adapter_.addClass(cssClasses$2.LINE_RIPPLE_ACTIVE);
        }

        /**
         * Sets the center of the ripple animation to the given X coordinate.
         * @param {number} xCoordinate
         */

      }, {
        key: 'setRippleCenter',
        value: function setRippleCenter(xCoordinate) {
          this.adapter_.setStyle('transform-origin', xCoordinate + 'px center');
        }

        /**
         * Deactivates the line ripple
         */

      }, {
        key: 'deactivate',
        value: function deactivate() {
          this.adapter_.addClass(cssClasses$2.LINE_RIPPLE_DEACTIVATING);
        }

        /**
         * Handles a transition end event
         * @param {!Event} evt
         */

      }, {
        key: 'handleTransitionEnd',
        value: function handleTransitionEnd(evt) {
          // Wait for the line ripple to be either transparent or opaque
          // before emitting the animation end event
          var isDeactivating = this.adapter_.hasClass(cssClasses$2.LINE_RIPPLE_DEACTIVATING);

          if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
              this.adapter_.removeClass(cssClasses$2.LINE_RIPPLE_ACTIVE);
              this.adapter_.removeClass(cssClasses$2.LINE_RIPPLE_DEACTIVATING);
            }
          }
        }
      }]);
      return MDCLineRippleFoundation;
    }(MDCFoundation);

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Floating Label.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the floating label into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCFloatingLabelAdapter = function () {
      function MDCFloatingLabelAdapter() {
        classCallCheck(this, MDCFloatingLabelAdapter);
      }

      createClass(MDCFloatingLabelAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the label element.
         * @param {string} className
         */
        value: function addClass(className) {}

        /**
         * Removes a class from the label element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}

        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {}

        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}

        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
      }]);
      return MDCFloatingLabelAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$3 = {
      LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
      LABEL_SHAKE: 'mdc-floating-label--shake'
    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
     * @final
     */

    var MDCFloatingLabelFoundation = function (_MDCFoundation) {
      inherits(MDCFloatingLabelFoundation, _MDCFoundation);
      createClass(MDCFloatingLabelFoundation, null, [{
        key: 'cssClasses',

        /** @return enum {string} */
        get: function get$$1() {
          return cssClasses$3;
        }

        /**
         * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCFloatingLabelAdapter}
         */

      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return (/** @type {!MDCFloatingLabelAdapter} */{
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              getWidth: function getWidth() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {}
            }
          );
        }

        /**
         * @param {!MDCFloatingLabelAdapter} adapter
         */

      }]);

      function MDCFloatingLabelFoundation(adapter) {
        classCallCheck(this, MDCFloatingLabelFoundation);

        /** @private {function(!Event): undefined} */
        var _this = possibleConstructorReturn(this, (MDCFloatingLabelFoundation.__proto__ || Object.getPrototypeOf(MDCFloatingLabelFoundation)).call(this, _extends(MDCFloatingLabelFoundation.defaultAdapter, adapter)));

        _this.shakeAnimationEndHandler_ = function () {
          return _this.handleShakeAnimationEnd_();
        };
        return _this;
      }

      createClass(MDCFloatingLabelFoundation, [{
        key: 'init',
        value: function init() {
          this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }

        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: 'getWidth',
        value: function getWidth() {
          return this.adapter_.getWidth();
        }

        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake adds shake class if true,
         * otherwise removes shake class.
         */

      }, {
        key: 'shake',
        value: function shake(shouldShake) {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
          } else {
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }

        /**
         * Styles the label to float or dock.
         * @param {boolean} shouldFloat adds float class if true, otherwise remove
         * float and shake class to dock label.
         */

      }, {
        key: 'float',
        value: function float(shouldFloat) {
          var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
              LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
              LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

          if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
          } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }

        /**
         * Handles an interaction event on the root element.
         */

      }, {
        key: 'handleShakeAnimationEnd_',
        value: function handleShakeAnimationEnd_() {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }]);
      return MDCFloatingLabelFoundation;
    }(MDCFoundation);

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Notched Outline.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Notched Outline into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCNotchedOutlineAdapter = function () {
      function MDCNotchedOutlineAdapter() {
        classCallCheck(this, MDCNotchedOutlineAdapter);
      }

      createClass(MDCNotchedOutlineAdapter, [{
        key: "getWidth",

        /**
         * Returns the width of the root element.
         * @return {number}
         */
        value: function getWidth() {}

        /**
         * Returns the height of the root element.
         * @return {number}
         */

      }, {
        key: "getHeight",
        value: function getHeight() {}

        /**
         * Adds a class to the root element.
         * @param {string} className
         */

      }, {
        key: "addClass",
        value: function addClass(className) {}

        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}

        /**
         * Sets the "d" attribute of the outline element's SVG path.
         * @param {string} value
         */

      }, {
        key: "setOutlinePathAttr",
        value: function setOutlinePathAttr(value) {}

        /**
         * Returns the idle outline element's computed style value of the given css property `propertyName`.
         * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
         * @param {string} propertyName
         * @return {string}
         */

      }, {
        key: "getIdleOutlineStyleValue",
        value: function getIdleOutlineStyleValue(propertyName) {}
      }]);
      return MDCNotchedOutlineAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$3 = {
      PATH_SELECTOR: '.mdc-notched-outline__path',
      IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
    };

    /** @enum {string} */
    var cssClasses$4 = {
      OUTLINE_NOTCHED: 'mdc-notched-outline--notched'
    };

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
     * @final
     */

    var MDCNotchedOutlineFoundation = function (_MDCFoundation) {
      inherits(MDCNotchedOutlineFoundation, _MDCFoundation);
      createClass(MDCNotchedOutlineFoundation, null, [{
        key: 'strings',

        /** @return enum {string} */
        get: function get$$1() {
          return strings$3;
        }

        /** @return enum {string} */

      }, {
        key: 'cssClasses',
        get: function get$$1() {
          return cssClasses$4;
        }

        /**
         * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCNotchedOutlineAdapter}
         */

      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return (/** @type {!MDCNotchedOutlineAdapter} */{
              getWidth: function getWidth() {},
              getHeight: function getHeight() {},
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              setOutlinePathAttr: function setOutlinePathAttr() {},
              getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
            }
          );
        }

        /**
         * @param {!MDCNotchedOutlineAdapter} adapter
         */

      }]);

      function MDCNotchedOutlineFoundation(adapter) {
        classCallCheck(this, MDCNotchedOutlineFoundation);
        return possibleConstructorReturn(this, (MDCNotchedOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCNotchedOutlineFoundation)).call(this, _extends(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
      }

      /**
       * Adds the outline notched selector and updates the notch width
       * calculated based off of notchWidth and isRtl.
       * @param {number} notchWidth
       * @param {boolean=} isRtl
       */


      createClass(MDCNotchedOutlineFoundation, [{
        key: 'notch',
        value: function notch(notchWidth) {
          var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

          this.adapter_.addClass(OUTLINE_NOTCHED);
          this.updateSvgPath_(notchWidth, isRtl);
        }

        /**
         * Removes notched outline selector to close the notch in the outline.
         */

      }, {
        key: 'closeNotch',
        value: function closeNotch() {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

          this.adapter_.removeClass(OUTLINE_NOTCHED);
        }

        /**
         * Updates the SVG path of the focus outline element based on the notchWidth
         * and the RTL context.
         * @param {number} notchWidth
         * @param {boolean=} isRtl
         * @private
         */

      }, {
        key: 'updateSvgPath_',
        value: function updateSvgPath_(notchWidth, isRtl) {
          // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
          var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
          var radius = parseFloat(radiusStyleValue);
          var width = this.adapter_.getWidth();
          var height = this.adapter_.getHeight();
          var cornerWidth = radius + 1.2;
          var leadingStrokeLength = Math.abs(11 - cornerWidth);
          var paddedNotchWidth = notchWidth + 8;

          // The right, bottom, and left sides of the outline follow the same SVG path.
          var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;

          var path = void 0;
          if (!isRtl) {
            path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
          } else {
            path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
          }

          this.adapter_.setOutlinePathAttr(path);
        }
      }]);
      return MDCNotchedOutlineFoundation;
    }(MDCFoundation);

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter = function () {
      function MDCRippleAdapter() {
        classCallCheck(this, MDCRippleAdapter);
      }

      createClass(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}

        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}

        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}

        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}

        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}

        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}

        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}

        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}

        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}

        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}

        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}

        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}

        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}

        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}

        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}

        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);
      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var cssClasses$5 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };

    var strings$4 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };

    var numbers$1 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_ = void 0;

    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */
    var supportsPassive_$1 = void 0;

    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */
    function detectEdgePseudoVarBug(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node);

      // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }

    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */

    function supportsCssVariables(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var supportsCssVariables = supportsCssVariables_;
      if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
      // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari
      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_ = supportsCssVariables;
      }
      return supportsCssVariables;
    }

    //
    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */
    function applyPassive$1() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$1 === undefined || forceRefresh) {
        var isSupported = false;
        try {
          globalObj.document.addEventListener('test', null, { get passive() {
              isSupported = true;
            } });
        } catch (e) {}

        supportsPassive_$1 = isSupported;
      }

      return supportsPassive_$1 ? { passive: true } : false;
    }

    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */
    function getMatchesProperty(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }

    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */
    function getNormalizedEventCoords(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;

      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;

      var normalizedX = void 0;
      var normalizedY = void 0;
      // Determine touch point relative to the ripple container.
      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return { x: normalizedX, y: normalizedY };
    }

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    // Activation events registered on the root element of each instance for activation
    var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

    // Deactivation events registered on documentElement when a pointer-related down event occurs
    var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

    // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
    /** @type {!Array<!EventTarget>} */
    var activatedTargets = [];

    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation = function (_MDCFoundation) {
      inherits(MDCRippleFoundation, _MDCFoundation);
      createClass(MDCRippleFoundation, null, [{
        key: 'cssClasses',
        get: function get$$1() {
          return cssClasses$5;
        }
      }, {
        key: 'strings',
        get: function get$$1() {
          return strings$4;
        }
      }, {
        key: 'numbers',
        get: function get$$1() {
          return numbers$1;
        }
      }, {
        key: 'defaultAdapter',
        get: function get$$1() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
            isUnbounded: function isUnbounded() /* boolean */{},
            isSurfaceActive: function isSurfaceActive() /* boolean */{},
            isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
            registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
            deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
            computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
            getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        classCallCheck(this, MDCRippleFoundation);

        /** @private {number} */
        var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

        _this.layoutFrame_ = 0;

        /** @private {!ClientRect} */
        _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

        /** @private {!ActivationStateType} */
        _this.activationState_ = _this.defaultActivationState_();

        /** @private {number} */
        _this.initialSize_ = 0;

        /** @private {number} */
        _this.maxRadius_ = 0;

        /** @private {function(!Event)} */
        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };

        /** @private {function(!Event)} */
        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };

        /** @private {function(?Event=)} */
        _this.focusHandler_ = function () {
          return requestAnimationFrame(function () {
            return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        };

        /** @private {function(?Event=)} */
        _this.blurHandler_ = function () {
          return requestAnimationFrame(function () {
            return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        };

        /** @private {!Function} */
        _this.resizeHandler_ = function () {
          return _this.layout();
        };

        /** @private {{left: number, top:number}} */
        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };

        /** @private {number} */
        _this.fgScale_ = 0;

        /** @private {number} */
        _this.activationTimer_ = 0;

        /** @private {number} */
        _this.fgDeactivationRemovalTimer_ = 0;

        /** @private {boolean} */
        _this.activationAnimationHasEnded_ = false;

        /** @private {!Function} */
        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;
          _this.runDeactivationUXLogicIfReady_();
        };

        /** @private {?Event} */
        _this.previousActivationEvent_ = null;
        return _this;
      }

      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      createClass(MDCRippleFoundation, [{
        key: 'isSupported_',
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }

        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: 'defaultActivationState_',
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
      }, {
        key: 'init',
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }
          this.registerRootHandlers_();

          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);
            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED);
              // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
              _this2.layoutInternal_();
            }
          });
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();

          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);
            _this3.adapter_.removeClass(UNBOUNDED);
            _this3.removeCssVars_();
          });
        }

        /** @private */

      }, {
        key: 'registerRootHandlers_',
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }

        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: 'registerDeactivationHandlers_',
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }

        /** @private */

      }, {
        key: 'deregisterRootHandlers_',
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }

        /** @private */

      }, {
        key: 'deregisterDeactivationHandlers_',
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }

        /** @private */

      }, {
        key: 'removeCssVars_',
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;

          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }

        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: 'activate_',
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;
          if (activationState.isActivated) {
            return;
          }

          // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

          var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });
          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets.push( /** @type {!EventTarget} */e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);
              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }

        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: 'checkElementMadeActive_',
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }

        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: 'activate',
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          this.activate_(event);
        }

        /** @private */

      }, {
        key: 'animateActivation_',
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


          this.layoutInternal_();

          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
                startPoint = _getFgTranslationCoor.startPoint,
                endPoint = _getFgTranslationCoor.endPoint;

            translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
            translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
          // Cancel any ongoing activation/deactivation animations
          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION);

          // Force layout in order to re-trigger the animation.
          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }

        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: 'getFgTranslationCoordinates_',
        value: function getFgTranslationCoordinates_() {
          var _activationState_ = this.activationState_,
              activationEvent = _activationState_.activationEvent,
              wasActivatedByPointer = _activationState_.wasActivatedByPointer;


          var startPoint = void 0;
          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords(
            /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          }
          // Center the element around the start point.
          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };

          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };

          return { startPoint: startPoint, endPoint: endPoint };
        }

        /** @private */

      }, {
        key: 'runDeactivationUXLogicIfReady_',
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _activationState_2 = this.activationState_,
              hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
              isActivated = _activationState_2.isActivated;

          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$1.FG_DEACTIVATION_MS);
          }
        }

        /** @private */

      }, {
        key: 'rmBoundedActivationClasses_',
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: 'resetActivationState_',
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_();
          // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.
          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }

        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: 'deactivate_',
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_;
          // This can happen in scenarios such as when you have a keyup event that blurs the element.
          if (!activationState.isActivated) {
            return;
          }

          var state = /** @type {!ActivationStateType} */_extends({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;
              _this13.animateDeactivation_(e, state);
              _this13.resetActivationState_();
            });
          }
        }

        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: 'deactivate',
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          this.deactivate_(event);
        }

        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: 'animateDeactivation_',
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: 'layout',
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }
          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();
            _this14.layoutFrame_ = 0;
          });
        }

        /** @private */

      }, {
        key: 'layoutInternal_',
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width);

          // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.
          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

          // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;

          this.updateLayoutCssVars_();
        }

        /** @private */

      }, {
        key: 'updateLayoutCssVars_',
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


          this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };

            this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
            this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
          }
        }

        /** @param {boolean} unbounded */

      }, {
        key: 'setUnbounded',
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }]);
      return MDCRippleFoundation;
    }(MDCFoundation);

    var RippleBase = function (_MDCRippleFoundation) {
      inherits(RippleBase, _MDCRippleFoundation);
      createClass(RippleBase, null, [{
        key: 'isSurfaceActive',
        value: function isSurfaceActive(ref) {
          return ref[RippleBase.MATCHES](':active');
        }
      }, {
        key: 'MATCHES',
        get: function get$$1() {
          /* global HTMLElement */
          return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
        }
      }]);

      function RippleBase(vm, options) {
        classCallCheck(this, RippleBase);
        return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return false;
          },
          isSurfaceActive: function isSurfaceActive() {
            return vm.$el[RippleBase.MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return vm.disabled;
          },
          addClass: function addClass(className) {
            vm.$set(vm.classes, className, true);
          },
          removeClass: function removeClass(className) {
            vm.$delete(vm.classes, className);
          },

          containsEventTarget: function containsEventTarget(target) {
            return vm.$el.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evt, handler) {
            vm.$el.addEventListener(evt, handler, applyPassive$1());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
            vm.$el.removeEventListener(evt, handler, applyPassive$1());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            vm.$set(vm.styles, varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return vm.$el.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return { x: window.pageXOffset, y: window.pageYOffset };
          }
        }, options)));
      }

      return RippleBase;
    }(MDCRippleFoundation);

    var mdcTextField = { render: function render() {
        var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-textfield-wrapper", style: { width: _vm.fullwidth ? '100%' : undefined }, attrs: { "id": _vm.id } }, [_c('div', { ref: "root", class: _vm.rootClasses }, [!!_vm.hasLeadingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasLeadingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("leading-icon", [_vm._v(_vm._s(_vm.hasLeadingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.multiline ? _c('textarea', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "id": _vm.vma_uid_, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls, "rows": _vm.rows, "cols": _vm.cols }, on: { "input": function input($event) {
              _vm.updateValue($event.target.value);
            } } }, 'textarea', _vm.$attrs, false), _vm.$listeners)) : _c('input', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "id": _vm.vma_uid_, "type": _vm.type, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls }, on: { "input": function input($event) {
              _vm.updateValue($event.target.value);
            } } }, 'input', _vm.$attrs, false), _vm.$listeners)), _vm._v(" "), _vm.hasLabel ? _c('label', { ref: "label", class: _vm.labelClassesUpgraded, attrs: { "for": _vm.vma_uid_ } }, [_vm._v(" " + _vm._s(_vm.label) + " ")]) : _vm._e(), _vm._v(" "), !!_vm.hasTrailingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasTrailingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("trailing-icon", [_vm._v(_vm._s(_vm.hasTrailingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outline", staticClass: "mdc-notched-outline", class: _vm.outlineClasses }, [_c('svg', [_c('path', { staticClass: "mdc-notched-outline__path", attrs: { "d": _vm.outlinePathAttr } })])]) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outlineIdle", staticClass: "mdc-notched-outline__idle" }) : _vm._e(), _vm._v(" "), _vm.hasLineRipple ? _c('div', { ref: "lineRipple", class: _vm.lineRippleClasses, style: _vm.lineRippleStyles }) : _vm._e()]), _vm._v(" "), _vm.helptext ? _c('p', { ref: "help", class: _vm.helpClasses, attrs: { "id": 'help-' + _vm.vma_uid_, "aria-hidden": "true" } }, [_vm._v(" " + _vm._s(_vm.helptext) + " ")]) : _vm._e()]);
      }, staticRenderFns: [],
      name: 'mdc-textfield',
      mixins: [CustomElementMixin, DispatchFocusMixin, VMAUniqueIdMixin],
      inheritAttrs: false,
      model: {
        prop: 'value',
        event: 'model'
      },
      props: {
        value: String,
        type: {
          type: String,
          default: 'text',
          validator: function validator(value) {
            return ['text', 'email', 'search', 'password', 'tel', 'url', 'number'].indexOf(value) !== -1;
          }
        },
        dense: Boolean,
        label: String,
        helptext: String,
        helptextPersistent: Boolean,
        helptextValidation: Boolean,
        box: Boolean,
        outline: Boolean,
        disabled: Boolean,
        required: Boolean,
        valid: { type: Boolean, default: undefined },
        fullwidth: Boolean,
        multiline: Boolean,
        leadingIcon: [String, Array, Object],
        trailingIcon: [String, Array, Object],
        size: { type: [Number, String], default: 20 },
        minlength: { type: [Number, String], default: undefined },
        maxlength: { type: [Number, String], default: undefined },
        rows: { type: [Number, String], default: 8 },
        cols: { type: [Number, String], default: 40 },
        id: { type: String }
      },
      data: function data() {
        return {
          text: this.value,
          rootClasses: {
            'mdc-textfield': true,
            'mdc-text-field': true,
            'mdc-text-field--upgraded': true,
            'mdc-text-field--disabled': this.disabled,
            'mdc-text-field--dense': this.dense,
            'mdc-text-field--fullwidth': this.fullwidth,
            'mdc-text-field--textarea': this.multiline,
            'mdc-text-field--box': !this.fullwidth && this.box,
            'mdc-text-field--outlined': !this.fullwidth && this.outline
          },
          inputClasses: {
            'mdc-text-field__input': true
          },
          labelClasses: {
            'mdc-floating-label': true
          },
          lineRippleClasses: {
            'mdc-line-ripple': true
          },
          lineRippleStyles: {},
          helpClasses: {
            'mdc-text-field-helper-text': true,
            'mdc-text-field-helper-text--persistent': this.helptextPersistent,
            'mdc-text-field-helper-text--validation-msg': this.helptextValidation
          },
          outlineClasses: {},
          outlinePathAttr: undefined
        };
      },
      computed: {
        inputPlaceHolder: function inputPlaceHolder() {
          return this.fullwidth ? this.label : undefined;
        },
        inputAriaControls: function inputAriaControls() {
          return this.help ? 'help-' + this.vma_uid_ : undefined;
        },
        hasLabel: function hasLabel() {
          return !this.fullwidth && this.label;
        },
        hasOutline: function hasOutline() {
          return !this.fullwidth && this.outline;
        },
        hasLineRipple: function hasLineRipple() {
          return !this.hasOutline && !this.multiline;
        },
        hasLeadingIcon: function hasLeadingIcon() {
          if ((this.leadingIcon || this.$slots['leading-icon']) && !(this.trailingIcon || this.$slots['trailing-icon'])) {
            return this.leadingIcon ? extractIconProp(this.leadingIcon) : {};
          }
          return false;
        },
        hasTrailingIcon: function hasTrailingIcon() {
          if (this.trailingIcon || this.$slots['trailing-icon']) {
            return this.trailingIcon ? extractIconProp(this.trailingIcon) : {};
          }
          return false;
        },
        labelClassesUpgraded: function labelClassesUpgraded() {
          return _extends(this.labelClasses, {
            'mdc-floating-label--float-above': this.value
          });
        }
      },
      watch: {
        disabled: function disabled() {
          this.foundation && this.foundation.setDisabled(this.disabled);
        },
        required: function required() {
          this.$refs.input && (this.$refs.input.required = this.required);
        },
        valid: function valid() {
          if (typeof this.valid !== 'undefined') {
            this.foundation && this.foundation.setValid(this.valid);
          }
        },
        dense: function dense() {
          this.$set(this.rootClasses, 'mdc-text-field--dense', this.dense);
        },
        helptextPersistent: function helptextPersistent() {
          this.helperTextFoundation && this.helperTextFoundation.setPersistent(this.helptextPersistent);
        },
        helptextValidation: function helptextValidation() {
          this.helperTextFoundation && this.helperTextFoundation.setValidation(this.helptextValidation);
        },
        value: function value(_value) {
          if (this.foundation) {
            if (_value !== this.foundation.getValue()) {
              this.foundation.setValue(_value);
            }
          }
        }
      },
      mounted: function mounted() {
        var _this = this;

        if (this.$refs.lineRipple) {
          this.lineRippleFoundation = new MDCLineRippleFoundation({
            addClass: function addClass(className) {
              _this.$set(_this.lineRippleClasses, className, true);
            },
            removeClass: function removeClass(className) {
              _this.$delete(_this.lineRippleClasses, className);
            },
            hasClass: function hasClass(className) {
              _this.$refs.lineRipple.classList.contains(className);
            },
            setStyle: function setStyle(name, value) {
              _this.$set(_this.lineRippleStyles, name, value);
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
              _this.$refs.lineRipple.addEventListener(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
              _this.$refs.lineRipple.removeEventListener(evtType, handler);
            }
          });
          this.lineRippleFoundation.init();
        }

        if (this.$refs.help) {
          this.helperTextFoundation = new MDCTextFieldHelperTextFoundation({
            addClass: function addClass(className) {
              _this.$set(_this.helpClasses, className, true);
            },
            removeClass: function removeClass(className) {
              _this.$delete(_this.helpClasses, className);
            },
            hasClass: function hasClass(className) {
              return _this.$refs.help.classList.contains(className);
            },
            setAttr: function setAttr(name, value) {
              _this.$refs.help.setAttribute(name, value);
            },
            removeAttr: function removeAttr(name) {
              _this.$refs.help.removeAttribute(name);
            },
            setContent: function setContent() /*content*/{
              // help text get's updated from {{helptext}}
              // this.$refs.help.textContent = content;
            }
          });
          this.helperTextFoundation.init();
        }

        if (this.$refs.icon) {
          if (this.hasLeadingIcon) {
            this.$set(this.rootClasses, 'mdc-text-field--with-leading-icon', true);
          } else if (this.hasTrailingIcon) {
            this.$set(this.rootClasses, 'mdc-text-field--with-trailing-icon', true);
          }

          this.iconFoundation = new MDCTextFieldIconFoundation({
            setAttr: function setAttr(attr, value) {
              return _this.$refs.icon.setAttribute(attr, value);
            },
            getAttr: function getAttr(attr) {
              return _this.$refs.icon.getAttribute(attr);
            },
            removeAttr: function removeAttr(attr) {
              return _this.$refs.icon.removeAttribute(attr);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              _this.$refs.icon.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              _this.$refs.icon.removeEventListener(evtType, handler);
            },
            notifyIconAction: function notifyIconAction() {
              return _this.$emit('icon-action');
            }
          });
          this.iconFoundation.init();
        }

        if (this.$refs.label) {
          this.labelFoundation = new MDCFloatingLabelFoundation({
            addClass: function addClass(className) {
              _this.$set(_this.labelClasses, className, true);
            },
            removeClass: function removeClass(className) {
              _this.$delete(_this.labelClasses, className);
            },
            getWidth: function getWidth() {
              return _this.$refs.label.offsetWidth;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              _this.$refs.label.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              _this.$refs.label.removeEventListener(evtType, handler);
            }
          });
          this.labelFoundation.init();
        }

        if (this.$refs.outline) {
          this.outlineFoundation = new MDCNotchedOutlineFoundation({
            getWidth: function getWidth() {
              return _this.$refs.outline.offsetWidth;
            },
            getHeight: function getHeight() {
              return _this.$refs.outline.offsetHeight;
            },
            addClass: function addClass(className) {
              _this.$set(_this.outlineClasses, className, true);
            },
            removeClass: function removeClass(className) {
              _this.$delete(_this.outlineClasses, className);
            },
            setOutlinePathAttr: function setOutlinePathAttr(value) {
              _this.outlinePathAttr = value;
            },
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
              var idleOutlineElement = _this.$refs.outlineIdle;
              if (idleOutlineElement) {
                return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
              }
            }
          });
          this.outlineFoundation.init();
        }

        this.foundation = new MDCTextFieldFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.rootClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.rootClasses, className);
          },
          hasClass: function hasClass(className) {
            _this.$refs.root.classList.contains(className);
          },
          registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
            _this.$refs.root.addEventListener(evtType, handler);
          },
          deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
            _this.$refs.root.removeEventListener(evtType, handler);
          },
          isFocused: function isFocused() {
            return document.activeElement === _this.$refs.input;
          },
          isRtl: function isRtl() {
            return window.getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
          },
          deactivateLineRipple: function deactivateLineRipple() {
            if (_this.lineRippleFoundation) {
              _this.lineRippleFoundation.deactivate();
            }
          },
          activateLineRipple: function activateLineRipple() {
            if (_this.lineRippleFoundation) {
              _this.lineRippleFoundation.activate();
            }
          },
          setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
            if (_this.lineRippleFoundation) {
              _this.lineRippleFoundation.setRippleCenter(normalizedX);
            }
          },
          registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
            _this.$refs.input.addEventListener(evtType, handler, applyPassive());
          },
          deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
            _this.$refs.input.removeEventListener(evtType, handler, applyPassive());
          },
          registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
            var observer = new MutationObserver(handler);
            var targetNode = _this.$refs.input;
            var config = { attributes: true };
            observer.observe(targetNode, config);
            return observer;
          },
          deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
            observer.disconnect();
          },
          shakeLabel: function shakeLabel(shouldShake) {
            _this.labelFoundation.shake(shouldShake);
          },
          floatLabel: function floatLabel(shouldFloat) {
            _this.labelFoundation.float(shouldFloat);
          },
          hasLabel: function hasLabel() {
            return !!_this.$refs.label;
          },
          getLabelWidth: function getLabelWidth() {
            return _this.labelFoundation.getWidth();
          },
          getNativeInput: function getNativeInput() {
            return _this.$refs.input;
          },
          hasOutline: function hasOutline() {
            return !!_this.hasOutline;
          },
          notchOutline: function notchOutline(notchWidth, isRtl) {
            return _this.outlineFoundation.notch(notchWidth, isRtl);
          },
          closeOutline: function closeOutline() {
            return _this.outlineFoundation.closeNotch();
          }
        }, {
          helperText: this.helperTextFoundation,
          icon: this.iconFoundation
        });

        this.foundation.init();
        this.foundation.setValue(this.value);
        this.foundation.setDisabled(this.disabled);
        this.$refs.input && (this.$refs.input.required = this.required);
        if (typeof this.valid !== 'undefined') {
          this.foundation.setValid(this.valid);
        }

        if (this.textbox) {
          this.ripple = new RippleBase(this);
          this.ripple.init();
        }
      },
      beforeDestroy: function beforeDestroy() {
        this.foundation && this.foundation.destroy();
        this.lineRippleFoundation && this.lineRippleFoundation.destroy();
        this.helperTextFoundation && this.helperTextFoundation.destroy();
        this.iconFoundation && this.iconFoundation.destroy();
        this.labelFoundation && this.labelFoundation.destroy();
        this.outlineFoundation && this.outlineFoundation.destroy();
        this.ripple && this.ripple.destroy();
      },

      methods: {
        updateValue: function updateValue(value) {
          this.$emit('model', value);
        },
        focus: function focus() {
          this.$refs.input && this.$refs.input.focus();
        },
        blur: function blur() {
          this.$refs.input && this.$refs.input.blur();
        }
      }
    };

    var plugin = BasePlugin({
      mdcTextField: mdcTextField
    });

    autoInit(plugin);

    return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dGZpZWxkLmpzIiwic291cmNlcyI6WyIuLi8uLi9jb21wb25lbnRzL2Jhc2UvYXBwbHktcGFzc2l2ZS5qcyIsIi4uLy4uL2NvbXBvbmVudHMvYmFzZS9hdXRvLWluaXQuanMiLCIuLi8uLi9jb21wb25lbnRzL2Jhc2UvYmFzZS1wbHVnaW4uanMiLCIuLi8uLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWVsZW1lbnQuanMiLCIuLi8uLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWV2ZW50LmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1pY29uLmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2Rpc3BhdGNoLWZvY3VzLW1peGluLmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL3VuaXF1ZWlkLW1peGluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9hZGFwdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaGVscGVyLXRleHQvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaGVscGVyLXRleHQvZm91bmRhdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ljb24vYWRhcHRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ljb24vY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvYWRhcHRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2NvbnN0YW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ZvdW5kYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2FkYXB0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2NvbnN0YW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvYWRhcHRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mbG9hdGluZy1sYWJlbC9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9ub3RjaGVkLW91dGxpbmUvYWRhcHRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbm90Y2hlZC1vdXRsaW5lL2NvbnN0YW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbm90Y2hlZC1vdXRsaW5lL2ZvdW5kYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9hZGFwdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvdXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLWJhc2UuanMiLCIuLi8uLi9jb21wb25lbnRzL3RleHRmaWVsZC9tZGMtdGV4dGZpZWxkLnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvdGV4dGZpZWxkL2luZGV4LmpzIiwiLi4vLi4vY29tcG9uZW50cy90ZXh0ZmllbGQvZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHN1cHBvcnRzUGFzc2l2ZV9cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZVxuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtcbiAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSB7IHBhc3NpdmU6IHRydWUgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vZW1wdHlcbiAgICB9XG5cbiAgICBzdXBwb3J0c1Bhc3NpdmVfID0gaXNTdXBwb3J0ZWRcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYXV0b0luaXQocGx1Z2luKSB7XG4gIC8vIEF1dG8taW5zdGFsbFxuICBsZXQgX1Z1ZSA9IG51bGxcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgX1Z1ZSA9IHdpbmRvdy5WdWVcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8qZ2xvYmFsIGdsb2JhbCovXG4gICAgX1Z1ZSA9IGdsb2JhbC5WdWVcbiAgfVxuICBpZiAoX1Z1ZSkge1xuICAgIF9WdWUudXNlKHBsdWdpbilcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIEJhc2VQbHVnaW4oY29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdfX1ZFUlNJT05fXycsXG4gICAgaW5zdGFsbDogdm0gPT4ge1xuICAgICAgZm9yIChsZXQga2V5IGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNba2V5XVxuICAgICAgICB2bS5jb21wb25lbnQoY29tcG9uZW50Lm5hbWUsIGNvbXBvbmVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHNcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUVsZW1lbnQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcihjcmVhdGVFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICBjb250ZXh0LnByb3BzLmlzIHx8IGNvbnRleHQucHJvcHMudGFnIHx8ICdkaXYnLFxuICAgICAgY29udGV4dC5kYXRhLFxuICAgICAgY29udGV4dC5jaGlsZHJlblxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tRWxlbWVudE1peGluID0ge1xuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tRWxlbWVudFxuICB9XG59XG4iLCIvKiBnbG9iYWwgQ3VzdG9tRXZlbnQgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRDdXN0b21FdmVudChlbCwgZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgbGV0IGV2dFxuICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50JylcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpXG4gIH1cbiAgZWwuZGlzcGF0Y2hFdmVudChldnQpXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdEljb25Qcm9wKGljb25Qcm9wKSB7XG4gIGlmICh0eXBlb2YgaWNvblByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHsgJ21hdGVyaWFsLWljb25zJzogdHJ1ZSB9LFxuICAgICAgY29udGVudDogaWNvblByb3BcbiAgICB9XG4gIH0gZWxzZSBpZiAoaWNvblByb3AgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiBpY29uUHJvcC5yZWR1Y2UoXG4gICAgICAgIChyZXN1bHQsIHZhbHVlKSA9PiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBbdmFsdWVdOiB0cnVlIH0pLFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgaWNvblByb3AgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IGljb25Qcm9wLmNsYXNzTmFtZVxuICAgICAgICAuc3BsaXQoJyAnKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIChyZXN1bHQsIHZhbHVlKSA9PiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBbdmFsdWVdOiB0cnVlIH0pLFxuICAgICAgICAgIHt9XG4gICAgICAgICksXG4gICAgICBjb250ZW50OiBpY29uUHJvcC50ZXh0Q29udGVudFxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRm9jdXNNaXhpbiA9IHtcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4geyBoYXNGb2N1czogZmFsc2UgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlXG4gICAgfSxcbiAgICBvbk1vdXNlVXAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZVxuICAgIH0sXG4gICAgb25Gb2N1c0V2ZW50KCkge1xuICAgICAgLy8gZGlzcGF0Y2ggYXN5bmMgdG8gbGV0IHRpbWUgdG8gb3RoZXIgZm9jdXMgZXZlbnQgdG8gcHJvcGFnYXRlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGlzcGF0Y2hGb2N1c0V2ZW50KCksIDApXG4gICAgfSxcbiAgICBvbkJsdXJFdmVudCgpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGFzeW5jIHRvIGxldCB0aW1lIHRvIG90aGVyIGZvY3VzIGV2ZW50IHRvIHByb3BhZ2F0ZVxuICAgICAgLy8gYWxzbyBmaWx0dXIgYmx1ciBpZiBtb3VzZWRvd25cbiAgICAgIHRoaXMuX2FjdGl2ZSB8fCBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGlzcGF0Y2hGb2N1c0V2ZW50KCksIDApXG4gICAgfSxcbiAgICBkaXNwYXRjaEZvY3VzRXZlbnQoKSB7XG4gICAgICBsZXQgaGFzRm9jdXMgPVxuICAgICAgICB0aGlzLiRlbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fFxuICAgICAgICB0aGlzLiRlbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgICAgaWYgKGhhc0ZvY3VzICE9IHRoaXMuaGFzRm9jdXMpIHtcbiAgICAgICAgdGhpcy4kZW1pdChoYXNGb2N1cyA/ICdmb2N1cycgOiAnYmx1cicpXG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSBoYXNGb2N1c1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLm9uRm9jdXNFdmVudClcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMub25CbHVyRXZlbnQpXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bilcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApXG4gIH1cbn1cbiIsImxldCB1aWRfID0gMFxuXG5leHBvcnQgY29uc3QgVk1BVW5pcXVlSWRNaXhpbiA9IHtcbiAgYmVmb3JlQ3JlYXRlKCkge1xuICAgIHRoaXMudm1hX3VpZF8gPSBgX3ZtYV8ke3VpZF8rK31gXG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKi9cbmNsYXNzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVte2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGV2ZXJ5XG4gICAgLy8gQ1NTIGNsYXNzIHRoZSBmb3VuZGF0aW9uIGNsYXNzIG5lZWRzIGFzIGEgcHJvcGVydHkuIGUuZy4ge0FDVElWRTogJ21kYy1jb21wb25lbnQtLWFjdGl2ZSd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBzZW1hbnRpYyBzdHJpbmdzIGFzIGNvbnN0YW50cy4gZS5nLiB7QVJJQV9ST0xFOiAndGFibGlzdCd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBvZiBpdHMgc2VtYW50aWMgbnVtYmVycyBhcyBjb25zdGFudHMuIGUuZy4ge0FOSU1BVElPTl9ERUxBWV9NUzogMzUwfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshT2JqZWN0fSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gbWF5IGNob29zZSB0byBpbXBsZW1lbnQgdGhpcyBnZXR0ZXIgaW4gb3JkZXIgdG8gcHJvdmlkZSBhIGNvbnZlbmllbnRcbiAgICAvLyB3YXkgb2Ygdmlld2luZyB0aGUgbmVjZXNzYXJ5IG1ldGhvZHMgb2YgYW4gYWRhcHRlci4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGFkYXB0ZXJcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0E9fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyID0ge30pIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUF9ICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKHJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBkZS1pbml0aWFsaXphdGlvbiByb3V0aW5lcyAoZGUtcmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRleHQgRmllbGQgSGVscGVyIFRleHQuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVGV4dEZpZWxkIGhlbHBlciB0ZXh0IGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgaGVscGVyIHRleHQgZWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgd2l0aCBhIGdpdmVuIHZhbHVlIG9uIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVBdHRyKGF0dHIpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBmb3IgdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJJQV9ISURERU46ICdhcmlhLWhpZGRlbicsXG4gIFJPTEU6ICdyb2xlJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgSEVMUEVSX1RFWFRfUEVSU0lTVEVOVDogJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS1wZXJzaXN0ZW50JyxcbiAgSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0c6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tdmFsaWRhdGlvbi1tc2cnLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQXR0cjogKCkgPT4ge30sXG4gICAgICBzZXRDb250ZW50OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBoZWxwZXIgdGV4dCBmaWVsZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICovXG4gIHNldENvbnRlbnQoY29udGVudCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0Q29udGVudChjb250ZW50KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGlzUGVyc2lzdGVudCBTZXRzIHRoZSBwZXJzaXN0ZW5jeSBvZiB0aGUgaGVscGVyIHRleHQuICovXG4gIHNldFBlcnNpc3RlbnQoaXNQZXJzaXN0ZW50KSB7XG4gICAgaWYgKGlzUGVyc2lzdGVudCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZGF0aW9uIFRydWUgdG8gbWFrZSB0aGUgaGVscGVyIHRleHQgYWN0IGFzIGFuXG4gICAqICAgZXJyb3IgdmFsaWRhdGlvbiBtZXNzYWdlLlxuICAgKi9cbiAgc2V0VmFsaWRhdGlvbihpc1ZhbGlkYXRpb24pIHtcbiAgICBpZiAoaXNWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBNYWtlcyB0aGUgaGVscGVyIHRleHQgdmlzaWJsZSB0byB0aGUgc2NyZWVuIHJlYWRlci4gKi9cbiAgc2hvd1RvU2NyZWVuUmVhZGVyKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cihzdHJpbmdzLkFSSUFfSElEREVOKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWxpZGl0eSBvZiB0aGUgaGVscGVyIHRleHQgYmFzZWQgb24gdGhlIGlucHV0IHZhbGlkaXR5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlucHV0SXNWYWxpZFxuICAgKi9cbiAgc2V0VmFsaWRpdHkoaW5wdXRJc1ZhbGlkKSB7XG4gICAgY29uc3QgaGVscGVyVGV4dElzUGVyc2lzdGVudCA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICBjb25zdCBoZWxwZXJUZXh0SXNWYWxpZGF0aW9uTXNnID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICBjb25zdCB2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5ID0gaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyAmJiAhaW5wdXRJc1ZhbGlkO1xuXG4gICAgaWYgKHZhbGlkYXRpb25Nc2dOZWVkc0Rpc3BsYXkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLlJPTEUsICdhbGVydCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHIoc3RyaW5ncy5ST0xFKTtcbiAgICB9XG5cbiAgICBpZiAoIWhlbHBlclRleHRJc1BlcnNpc3RlbnQgJiYgIXZhbGlkYXRpb25Nc2dOZWVkc0Rpc3BsYXkpIHtcbiAgICAgIHRoaXMuaGlkZV8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGlkZXMgdGhlIGhlbHAgdGV4dCBmcm9tIHNjcmVlbiByZWFkZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGlkZV8oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuQVJJQV9ISURERU4sICd0cnVlJyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRleHQgRmllbGQgSWNvbi5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSB0ZXh0IGZpZWxkIGljb24gaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEljb25BZGFwdGVyIHtcbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBdHRyKGF0dHIpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIG9uIHRoZSBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cihhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKi9cbiAgcmVtb3ZlQXR0cihhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIGV2ZW50IFwiTURDVGV4dEZpZWxkOmljb25cIiBkZW5vdGluZyBhIHVzZXIgaGFzIGNsaWNrZWQgdGhlIGljb24uXG4gICAqL1xuICBub3RpZnlJY29uQWN0aW9uKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBJQ09OX0VWRU5UOiAnTURDVGV4dEZpZWxkOmljb24nLFxuICBJQ09OX1JPTEU6ICdidXR0b24nLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRJY29uQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEljb25BZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEljb25BZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9ICovICh7XG4gICAgICBnZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQXR0cjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUljb25BY3Rpb246ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RleHRGaWVsZEljb25BZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmc/fSAqL1xuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSBudWxsO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVJbnRlcmFjdGlvbihldnQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gdGhpcy5hZGFwdGVyXy5nZXRBdHRyKCd0YWJpbmRleCcpO1xuXG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBoZWxwZXIgdGV4dCBmaWVsZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICAgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMuc2F2ZWRUYWJJbmRleF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cigncm9sZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ3RhYmluZGV4JywgdGhpcy5zYXZlZFRhYkluZGV4Xyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ3JvbGUnLCBzdHJpbmdzLklDT05fUk9MRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUljb25BY3Rpb24oKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBmcm9tICcuL2hlbHBlci10ZXh0L2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGZyb20gJy4vaWNvbi9mb3VuZGF0aW9uJztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdmFsdWU6IHN0cmluZyxcbiAqICAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gKiAgIGJhZElucHV0OiBib29sZWFuLFxuICogICB2YWxpZGl0eToge1xuICogICAgIGJhZElucHV0OiBib29sZWFuLFxuICogICAgIHZhbGlkOiBib29sZWFuLFxuICogICB9LFxuICogfX1cbiAqL1xubGV0IE5hdGl2ZUlucHV0VHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBoZWxwZXJUZXh0OiAoIU1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9ufHVuZGVmaW5lZCksXG4gKiAgIGljb246ICghTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqIH19XG4gKi9cbmxldCBGb3VuZGF0aW9uTWFwVHlwZTtcblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUZXh0IEZpZWxkIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgcm9vdCBFbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByb290IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHZhbGlkYXRpb24gYXR0cmlidXRlIGNoYW5nZSBsaXN0ZW5lciBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbighQXJyYXkpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICogQHJldHVybiB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAqL1xuICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgb2JzZXJ2ZXIgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIob2JzZXJ2ZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZWxlbWVudCwgd2l0aCBhXG4gICAqIHNpbWlsYXIgQVBJIHNoYXBlLiBUaGUgb2JqZWN0IHJldHVybmVkIHNob3VsZCBpbmNsdWRlIHRoZSB2YWx1ZSwgZGlzYWJsZWRcbiAgICogYW5kIGJhZElucHV0IHByb3BlcnRpZXMsIGFzIHdlbGwgYXMgdGhlIGNoZWNrVmFsaWRpdHkoKSBmdW5jdGlvbi4gV2UgbmV2ZXJcbiAgICogYWx0ZXIgdGhlIHZhbHVlIHdpdGhpbiBvdXIgY29kZSwgaG93ZXZlciB3ZSBkbyB1cGRhdGUgdGhlIGRpc2FibGVkXG4gICAqIHByb3BlcnR5LCBzbyBpZiB5b3UgY2hvb3NlIHRvIGR1Y2stdHlwZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGlzIG1ldGhvZFxuICAgKiBpbiB5b3VyIGltcGxlbWVudGF0aW9uIGl0J3MgaW1wb3J0YW50IHRvIGtlZXAgdGhpcyBpbiBtaW5kLiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIG51bGwsIHdoaWNoIHRoZSBmb3VuZGF0aW9uIHdpbGwgaGFuZGxlIGdyYWNlZnVsbHkuXG4gICAqIEByZXR1cm4gez9FbGVtZW50fD9OYXRpdmVJbnB1dFR5cGV9XG4gICAqL1xuICBnZXROYXRpdmVJbnB1dCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dGZpZWxkIGlzIGZvY3VzZWQuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMucm9vdF9gLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJvb3QgZWxlbWVudCBpcyBzZXQgdG8gUlRMLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgYWN0aXZhdGVMaW5lUmlwcGxlKCkge31cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgZGVhY3RpdmF0ZUxpbmVSaXBwbGUoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm0gb3JpZ2luIG9mIHRoZSBsaW5lIHJpcHBsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRYXG4gICAqL1xuICBzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIFNoYWtlcyBsYWJlbCBpZiBzaG91bGRTaGFrZSBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFNoYWtlXG4gICAqL1xuICBzaGFrZUxhYmVsKHNob3VsZFNoYWtlKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIEZsb2F0cyB0aGUgbGFiZWwgYWJvdmUgdGhlIGlucHV0IGVsZW1lbnQgaWYgc2hvdWxkRmxvYXQgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRGbG9hdFxuICAgKi9cbiAgZmxvYXRMYWJlbChzaG91bGRGbG9hdCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGxhYmVsIGVsZW1lbnQgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2Vzbid0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzTGFiZWwoKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIFJldHVybnMgd2lkdGggb2YgbGFiZWwgaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMYWJlbFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG91dGxpbmUgZWxlbWVudCBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXNuJ3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNPdXRsaW5lKCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cy5cbiAgICogVXBkYXRlcyBTVkcgUGF0aCBhbmQgb3V0bGluZSBlbGVtZW50IGJhc2VkIG9uIHRoZVxuICAgKiBsYWJlbCBlbGVtZW50IHdpZHRoIGFuZCBSVEwgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsV2lkdGhcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaXNSdGxcbiAgICovXG4gIG5vdGNoT3V0bGluZShsYWJlbFdpZHRoLCBpc1J0bCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cy5cbiAgICogQ2xvc2VzIG5vdGNoIGluIG91dGxpbmUgZWxlbWVudC5cbiAgICovXG4gIGNsb3NlT3V0bGluZSgpIHt9XG59XG5cbmV4cG9ydCB7TURDVGV4dEZpZWxkQWRhcHRlciwgTmF0aXZlSW5wdXRUeXBlLCBGb3VuZGF0aW9uTWFwVHlwZX07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX0NPTlRST0xTOiAnYXJpYS1jb250cm9scycsXG4gIElOUFVUX1NFTEVDVE9SOiAnLm1kYy10ZXh0LWZpZWxkX19pbnB1dCcsXG4gIExBQkVMX1NFTEVDVE9SOiAnLm1kYy1mbG9hdGluZy1sYWJlbCcsXG4gIElDT05fU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX2ljb24nLFxuICBPVVRMSU5FX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmUnLFxuICBMSU5FX1JJUFBMRV9TRUxFQ1RPUjogJy5tZGMtbGluZS1yaXBwbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXRleHQtZmllbGQnLFxuICBVUEdSQURFRDogJ21kYy10ZXh0LWZpZWxkLS11cGdyYWRlZCcsXG4gIERJU0FCTEVEOiAnbWRjLXRleHQtZmllbGQtLWRpc2FibGVkJyxcbiAgREVOU0U6ICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnLFxuICBGT0NVU0VEOiAnbWRjLXRleHQtZmllbGQtLWZvY3VzZWQnLFxuICBJTlZBTElEOiAnbWRjLXRleHQtZmllbGQtLWludmFsaWQnLFxuICBCT1g6ICdtZGMtdGV4dC1maWVsZC0tYm94JyxcbiAgT1VUTElORUQ6ICdtZGMtdGV4dC1maWVsZC0tb3V0bGluZWQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBMQUJFTF9TQ0FMRTogMC43NSxcbiAgREVOU0VfTEFCRUxfU0NBTEU6IDAuOTIzLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZnJvbSAnLi9oZWxwZXItdGV4dC9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiBmcm9tICcuL2ljb24vZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RleHRGaWVsZEFkYXB0ZXIsIE5hdGl2ZUlucHV0VHlwZSwgRm91bmRhdGlvbk1hcFR5cGV9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vLyB3aGl0ZWxpc3QgYmFzZWQgb2ZmIG9mIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0hUTUwvSFRNTDUvQ29uc3RyYWludF92YWxpZGF0aW9uXG4vLyB1bmRlciBzZWN0aW9uOiBgVmFsaWRhdGlvbi1yZWxhdGVkIGF0dHJpYnV0ZXNgXG5jb25zdCBWQUxJREFUSU9OX0FUVFJfV0hJVEVMSVNUID0gW1xuICAncGF0dGVybicsICdtaW4nLCAnbWF4JywgJ3JlcXVpcmVkJywgJ3N0ZXAnLCAnbWlubGVuZ3RoJywgJ21heGxlbmd0aCcsXG5dO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgc2hvdWxkU2hha2UoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzVmFsaWQoKSAmJiAhdGhpcy5pc0ZvY3VzZWRfO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBzaG91bGRGbG9hdCgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNCYWRJbnB1dF8oKSAmJiAoISF0aGlzLmdldFZhbHVlKCkgfHwgdGhpcy5pc0ZvY3VzZWRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBnZXROYXRpdmVJbnB1dDogKCkgPT4ge30sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW46ICgpID0+IHt9LFxuICAgICAgc2hha2VMYWJlbDogKCkgPT4ge30sXG4gICAgICBmbG9hdExhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGhhc0xhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGdldExhYmVsV2lkdGg6ICgpID0+IHt9LFxuICAgICAgaGFzT3V0bGluZTogKCkgPT4ge30sXG4gICAgICBub3RjaE91dGxpbmU6ICgpID0+IHt9LFxuICAgICAgY2xvc2VPdXRsaW5lOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRBZGFwdGVyfSBhZGFwdGVyXG4gICAqIEBwYXJhbSB7IUZvdW5kYXRpb25NYXBUeXBlPX0gZm91bmRhdGlvbk1hcCBNYXAgZnJvbSBzdWJjb21wb25lbnQgbmFtZXMgdG8gdGhlaXIgc3ViZm91bmRhdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyLCBmb3VuZGF0aW9uTWFwID0gLyoqIEB0eXBlIHshRm91bmRhdGlvbk1hcFR5cGV9ICovICh7fSkpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhlbHBlclRleHRfID0gZm91bmRhdGlvbk1hcC5oZWxwZXJUZXh0O1xuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmljb25fID0gZm91bmRhdGlvbk1hcC5pY29uO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNWYWxpZF8gPSB0cnVlO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5hY3RpdmF0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuZGVhY3RpdmF0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8gPSAoKSA9PiB0aGlzLmF1dG9Db21wbGV0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8gPSAoZXZ0KSA9PiB0aGlzLnNldFRyYW5zZm9ybU9yaWdpbihldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24oKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFBcnJheSk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyXyA9IChtdXRhdGlvbnMpID0+IHRoaXMuaGFuZGxlVmFsaWRhdGlvbkF0dHJpYnV0ZU11dGF0aW9uKG11dGF0aW9ucyk7XG4gICAgLyoqIEBwcml2YXRlIHshTXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICB0aGlzLnZhbGlkYXRpb25PYnNlcnZlcl87XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICAvLyBFbnN1cmUgbGFiZWwgZG9lcyBub3QgY29sbGlkZSB3aXRoIGFueSBwcmUtZmlsbGVkIHZhbHVlLlxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0xhYmVsKCkgJiYgdGhpcy5nZXRWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgICB0aGlzLm5vdGNoT3V0bGluZSh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc0ZvY3VzZWQoKSkge1xuICAgICAgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuaW5wdXRCbHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignaW5wdXQnLCB0aGlzLmlucHV0SW5wdXRIYW5kbGVyXyk7XG4gICAgWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnNldFBvaW50ZXJYT2Zmc2V0Xyk7XG4gICAgfSk7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMudmFsaWRhdGlvbk9ic2VydmVyXyA9IHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcihcbiAgICAgIHRoaXMudmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuaW5wdXRCbHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdpbnB1dCcsIHRoaXMuaW5wdXRJbnB1dEhhbmRsZXJfKTtcbiAgICBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8pO1xuICAgIH0pO1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKHRoaXMudmFsaWRhdGlvbk9ic2VydmVyXyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB1c2VyIGludGVyYWN0aW9ucyB3aXRoIHRoZSBUZXh0IEZpZWxkLlxuICAgKi9cbiAgaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlSW5wdXQoKS5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB2YWxpZGF0aW9uIGF0dHJpYnV0ZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7IUFycmF5PE11dGF0aW9uUmVjb3JkPn0gbXV0YXRpb25zTGlzdFxuICAgKi9cbiAgaGFuZGxlVmFsaWRhdGlvbkF0dHJpYnV0ZU11dGF0aW9uKG11dGF0aW9uc0xpc3QpIHtcbiAgICBtdXRhdGlvbnNMaXN0LnNvbWUoKG11dGF0aW9uKSA9PiB7XG4gICAgICBpZiAoVkFMSURBVElPTl9BVFRSX1dISVRFTElTVC5pbmRleE9mKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpID4gLTEpIHtcbiAgICAgICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMvY2xvc2VzIHRoZSBub3RjaGVkIG91dGxpbmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3Blbk5vdGNoXG4gICAqL1xuICBub3RjaE91dGxpbmUob3Blbk5vdGNoKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc091dGxpbmUoKSB8fCAhdGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wZW5Ob3RjaCkge1xuICAgICAgY29uc3QgaXNEZW5zZSA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5ERU5TRSk7XG4gICAgICBjb25zdCBsYWJlbFNjYWxlID0gaXNEZW5zZSA/IG51bWJlcnMuREVOU0VfTEFCRUxfU0NBTEUgOiBudW1iZXJzLkxBQkVMX1NDQUxFO1xuICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0TGFiZWxXaWR0aCgpICogbGFiZWxTY2FsZTtcbiAgICAgIGNvbnN0IGlzUnRsID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RjaE91dGxpbmUobGFiZWxXaWR0aCwgaXNSdGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmNsb3NlT3V0bGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIHRleHQgZmllbGQgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBhY3RpdmF0ZUZvY3VzKCkge1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IHRydWU7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZUxpbmVSaXBwbGUoKTtcbiAgICB0aGlzLm5vdGNoT3V0bGluZSh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNob3dUb1NjcmVlblJlYWRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaW5lIHJpcHBsZSdzIHRyYW5zZm9ybSBvcmlnaW4sIHNvIHRoYXQgdGhlIGxpbmUgcmlwcGxlIGFjdGl2YXRlXG4gICAqIGFuaW1hdGlvbiB3aWxsIGFuaW1hdGUgb3V0IGZyb20gdGhlIHVzZXIncyBjbGljayBsb2NhdGlvbi5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgc2V0VHJhbnNmb3JtT3JpZ2luKGV2dCkge1xuICAgIGNvbnN0IHRhcmdldENsaWVudFJlY3QgPSBldnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGV2dENvb3JkcyA9IHt4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFl9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRYID0gZXZ0Q29vcmRzLnggLSB0YXJnZXRDbGllbnRSZWN0LmxlZnQ7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIFRleHQgRmllbGQncyBmb2N1cyBzdGF0ZSBpbiBjYXNlcyB3aGVuIHRoZSBpbnB1dCB2YWx1ZVxuICAgKiBjaGFuZ2VzIHdpdGhvdXQgdXNlciBpbnB1dCAoZS5nLiBwcm9ncmFtYXRpY2FsbHkpLlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlRm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLnJlY2VpdmVkVXNlcklucHV0Xykge1xuICAgICAgdGhpcy5hY3RpdmF0ZUZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBUZXh0IEZpZWxkJ3MgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBkZWFjdGl2YXRlRm9jdXMoKSB7XG4gICAgdGhpcy5pc0ZvY3VzZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlTGluZVJpcHBsZSgpO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5nZXROYXRpdmVJbnB1dF8oKTtcbiAgICBjb25zdCBzaG91bGRSZW1vdmVMYWJlbEZsb2F0ID0gIWlucHV0LnZhbHVlICYmICF0aGlzLmlzQmFkSW5wdXRfKCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zaGFrZUxhYmVsKHRoaXMuc2hvdWxkU2hha2UpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICAgIGlmIChzaG91bGRSZW1vdmVMYWJlbEZsb2F0KSB7XG4gICAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgRWxlbWVudC5cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IG9uIHRoZSBpbnB1dCBFbGVtZW50LlxuICAgKi9cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zaGFrZUxhYmVsKHRoaXMuc2hvdWxkU2hha2UpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGEgY3VzdG9tIHZhbGlkaXR5IGlzIHNldCwgcmV0dXJucyB0aGF0IHZhbHVlLlxuICAgKiAgICAgT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSByZXN1bHQgb2YgbmF0aXZlIHZhbGlkaXR5IGNoZWNrcy5cbiAgICovXG4gIGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ19cbiAgICAgID8gdGhpcy5pc1ZhbGlkXyA6IHRoaXMuaXNOYXRpdmVJbnB1dFZhbGlkXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZCBTZXRzIHRoZSB2YWxpZGl0eSBzdGF0ZSBvZiB0aGUgVGV4dCBGaWVsZC5cbiAgICovXG4gIHNldFZhbGlkKGlzVmFsaWQpIHtcbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gdHJ1ZTtcbiAgICB0aGlzLmlzVmFsaWRfID0gaXNWYWxpZDtcbiAgICAvLyBSZXRyaWV2ZSBmcm9tIHRoZSBnZXR0ZXIgdG8gZW5zdXJlIGNvcnJlY3QgbG9naWMgaXMgYXBwbGllZC5cbiAgICBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIFRleHQgRmllbGQgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLmRpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgU2V0cyB0aGUgdGV4dC1maWVsZCBkaXNhYmxlZCBvciBlbmFibGVkLlxuICAgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUlucHV0XygpLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgdGhpcy5zdHlsZURpc2FibGVkXyhkaXNhYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQuXG4gICAqL1xuICBzZXRIZWxwZXJUZXh0Q29udGVudChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2V0Q29udGVudChjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgVGV4dCBGaWVsZCBpbnB1dCBmYWlscyBpbiBjb252ZXJ0aW5nIHRoZVxuICAgKiAgICAgdXNlci1zdXBwbGllZCB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzQmFkSW5wdXRfKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbGlkaXR5LmJhZElucHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZXN1bHQgb2YgbmF0aXZlIHZhbGlkaXR5IGNoZWNraW5nXG4gICAqICAgICAoVmFsaWRpdHlTdGF0ZS52YWxpZCkuXG4gICAqL1xuICBpc05hdGl2ZUlucHV0VmFsaWRfKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbGlkaXR5LnZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSB2YWxpZGl0eSBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKSB7XG4gICAgY29uc3Qge0lOVkFMSUR9ID0gTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKElOVkFMSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKElOVkFMSUQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oZWxwZXJUZXh0Xykge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Xy5zZXRWYWxpZGl0eShpc1ZhbGlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIGZvY3VzZWQgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGb2N1c2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdHlsZUZvY3VzZWRfKGlzRm9jdXNlZCkge1xuICAgIGNvbnN0IHtGT0NVU0VEfSA9IE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoaXNGb2N1c2VkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZPQ1VTRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZPQ1VTRUQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgZGlzYWJsZWQgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3R5bGVEaXNhYmxlZF8oaXNEaXNhYmxlZCkge1xuICAgIGNvbnN0IHtESVNBQkxFRCwgSU5WQUxJRH0gPSBNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhJTlZBTElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmljb25fKSB7XG4gICAgICB0aGlzLmljb25fLnNldERpc2FibGVkKGlzRGlzYWJsZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRWxlbWVudHwhTmF0aXZlSW5wdXRUeXBlfSBUaGUgbmF0aXZlIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAgICogaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBkdW1teSBpZiBub25lIGV4aXN0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5hdGl2ZUlucHV0XygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVJbnB1dCgpIHx8XG4gICAgLyoqIEB0eXBlIHshTmF0aXZlSW5wdXRUeXBlfSAqLyAoe1xuICAgICAgdmFsdWU6ICcnLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgdmFsaWRpdHk6IHtcbiAgICAgICAgYmFkSW5wdXQ6IGZhbHNlLFxuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dEZpZWxkIExpbmUgUmlwcGxlLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIGxpbmUgcmlwcGxlIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENMaW5lUmlwcGxlQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHlsZSBwcm9wZXJ0eSB3aXRoIHByb3BlcnR5TmFtZSB0byB2YWx1ZSBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGUocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJFdmVudEhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpbmVSaXBwbGVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgTElORV9SSVBQTEVfQUNUSVZFOiAnbWRjLWxpbmUtcmlwcGxlLS1hY3RpdmUnLFxuICBMSU5FX1JJUFBMRV9ERUFDVElWQVRJTkc6ICdtZGMtbGluZS1yaXBwbGUtLWRlYWN0aXZhdGluZycsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0xpbmVSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENMaW5lUmlwcGxlQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTGluZVJpcHBsZUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDTGluZVJpcHBsZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENMaW5lUmlwcGxlQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IC8qKiBAdHlwZSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyfSAqLyAoe30pKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENMaW5lUmlwcGxlRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRXZlbnRIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgbGluZSByaXBwbGVcbiAgICovXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9BQ1RJVkUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgcmlwcGxlIGFuaW1hdGlvbiB0byB0aGUgZ2l2ZW4gWCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geENvb3JkaW5hdGVcbiAgICovXG4gIHNldFJpcHBsZUNlbnRlcih4Q29vcmRpbmF0ZSkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCBgJHt4Q29vcmRpbmF0ZX1weCBjZW50ZXJgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgbGluZSByaXBwbGVcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHRyYW5zaXRpb24gZW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KSB7XG4gICAgLy8gV2FpdCBmb3IgdGhlIGxpbmUgcmlwcGxlIHRvIGJlIGVpdGhlciB0cmFuc3BhcmVudCBvciBvcGFxdWVcbiAgICAvLyBiZWZvcmUgZW1pdHRpbmcgdGhlIGFuaW1hdGlvbiBlbmQgZXZlbnRcbiAgICBjb25zdCBpc0RlYWN0aXZhdGluZyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuXG4gICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09ICdvcGFjaXR5Jykge1xuICAgICAgaWYgKGlzRGVhY3RpdmF0aW5nKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9BQ1RJVkUpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDTGluZVJpcHBsZUZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIEZsb2F0aW5nIExhYmVsLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIGZsb2F0aW5nIGxhYmVsIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENGbG9hdGluZ0xhYmVsQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGbG9hdGluZ0xhYmVsQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIExBQkVMX0ZMT0FUX0FCT1ZFOiAnbWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZScsXG4gIExBQkVMX1NIQUtFOiAnbWRjLWZsb2F0aW5nLWxhYmVsLS1zaGFrZScsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBnZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENGbG9hdGluZ0xhYmVsQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuc2hha2VBbmltYXRpb25FbmRIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlU2hha2VBbmltYXRpb25FbmRfKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2FuaW1hdGlvbmVuZCcsIHRoaXMuc2hha2VBbmltYXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYW5pbWF0aW9uZW5kJywgdGhpcy5zaGFrZUFuaW1hdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0V2lkdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGxhYmVsIHRvIHByb2R1Y2UgdGhlIGxhYmVsIHNoYWtlIGZvciBlcnJvcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkU2hha2UgYWRkcyBzaGFrZSBjbGFzcyBpZiB0cnVlLFxuICAgKiBvdGhlcndpc2UgcmVtb3ZlcyBzaGFrZSBjbGFzcy5cbiAgICovXG4gIHNoYWtlKHNob3VsZFNoYWtlKSB7XG4gICAgY29uc3Qge0xBQkVMX1NIQUtFfSA9IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHNob3VsZFNoYWtlKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKExBQkVMX1NIQUtFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9TSEFLRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgbGFiZWwgdG8gZmxvYXQgb3IgZG9jay5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRGbG9hdCBhZGRzIGZsb2F0IGNsYXNzIGlmIHRydWUsIG90aGVyd2lzZSByZW1vdmVcbiAgICogZmxvYXQgYW5kIHNoYWtlIGNsYXNzIHRvIGRvY2sgbGFiZWwuXG4gICAqL1xuICBmbG9hdChzaG91bGRGbG9hdCkge1xuICAgIGNvbnN0IHtMQUJFTF9GTE9BVF9BQk9WRSwgTEFCRUxfU0hBS0V9ID0gTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoc2hvdWxkRmxvYXQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTEFCRUxfRkxPQVRfQUJPVkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX0ZMT0FUX0FCT1ZFKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGFuIGludGVyYWN0aW9uIGV2ZW50IG9uIHRoZSByb290IGVsZW1lbnQuXG4gICAqL1xuICBoYW5kbGVTaGFrZUFuaW1hdGlvbkVuZF8oKSB7XG4gICAgY29uc3Qge0xBQkVMX1NIQUtFfSA9IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9TSEFLRSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIE5vdGNoZWQgT3V0bGluZS5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBOb3RjaGVkIE91dGxpbmUgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRIZWlnaHQoKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFwiZFwiIGF0dHJpYnV0ZSBvZiB0aGUgb3V0bGluZSBlbGVtZW50J3MgU1ZHIHBhdGguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0T3V0bGluZVBhdGhBdHRyKHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpZGxlIG91dGxpbmUgZWxlbWVudCdzIGNvbXB1dGVkIHN0eWxlIHZhbHVlIG9mIHRoZSBnaXZlbiBjc3MgcHJvcGVydHkgYHByb3BlcnR5TmFtZWAuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGdldENvbXB1dGVkU3R5bGUoLi4uKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSlgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZShwcm9wZXJ0eU5hbWUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFBBVEhfU0VMRUNUT1I6ICcubWRjLW5vdGNoZWQtb3V0bGluZV9fcGF0aCcsXG4gIElETEVfT1VUTElORV9TRUxFQ1RPUjogJy5tZGMtbm90Y2hlZC1vdXRsaW5lX19pZGxlJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgT1VUTElORV9OT1RDSEVEOiAnbWRjLW5vdGNoZWQtb3V0bGluZS0tbm90Y2hlZCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn0gKi8gKHtcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGdldEhlaWdodDogKCkgPT4ge30sXG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRPdXRsaW5lUGF0aEF0dHI6ICgpID0+IHt9LFxuICAgICAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIG91dGxpbmUgbm90Y2hlZCBzZWxlY3RvciBhbmQgdXBkYXRlcyB0aGUgbm90Y2ggd2lkdGhcbiAgICogY2FsY3VsYXRlZCBiYXNlZCBvZmYgb2Ygbm90Y2hXaWR0aCBhbmQgaXNSdGwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub3RjaFdpZHRoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUnRsXG4gICAqL1xuICBub3RjaChub3RjaFdpZHRoLCBpc1J0bCA9IGZhbHNlKSB7XG4gICAgY29uc3Qge09VVExJTkVfTk9UQ0hFRH0gPSBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE9VVExJTkVfTk9UQ0hFRCk7XG4gICAgdGhpcy51cGRhdGVTdmdQYXRoXyhub3RjaFdpZHRoLCBpc1J0bCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBub3RjaGVkIG91dGxpbmUgc2VsZWN0b3IgdG8gY2xvc2UgdGhlIG5vdGNoIGluIHRoZSBvdXRsaW5lLlxuICAgKi9cbiAgY2xvc2VOb3RjaCgpIHtcbiAgICBjb25zdCB7T1VUTElORV9OT1RDSEVEfSA9IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoT1VUTElORV9OT1RDSEVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBTVkcgcGF0aCBvZiB0aGUgZm9jdXMgb3V0bGluZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBub3RjaFdpZHRoXG4gICAqIGFuZCB0aGUgUlRMIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub3RjaFdpZHRoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUnRsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVTdmdQYXRoXyhub3RjaFdpZHRoLCBpc1J0bCkge1xuICAgIC8vIEZhbGwgYmFjayB0byByZWFkaW5nIGEgc3BlY2lmaWMgY29ybmVyJ3Mgc3R5bGUgYmVjYXVzZSBGaXJlZm94IGRvZXNuJ3QgcmVwb3J0IHRoZSBzdHlsZSBvbiBib3JkZXItcmFkaXVzLlxuICAgIGNvbnN0IHJhZGl1c1N0eWxlVmFsdWUgPSB0aGlzLmFkYXB0ZXJfLmdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZSgnYm9yZGVyLXJhZGl1cycpIHx8XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlKCdib3JkZXItdG9wLWxlZnQtcmFkaXVzJyk7XG4gICAgY29uc3QgcmFkaXVzID0gcGFyc2VGbG9hdChyYWRpdXNTdHlsZVZhbHVlKTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmFkYXB0ZXJfLmdldEhlaWdodCgpO1xuICAgIGNvbnN0IGNvcm5lcldpZHRoID0gcmFkaXVzICsgMS4yO1xuICAgIGNvbnN0IGxlYWRpbmdTdHJva2VMZW5ndGggPSBNYXRoLmFicygxMSAtIGNvcm5lcldpZHRoKTtcbiAgICBjb25zdCBwYWRkZWROb3RjaFdpZHRoID0gbm90Y2hXaWR0aCArIDg7XG5cbiAgICAvLyBUaGUgcmlnaHQsIGJvdHRvbSwgYW5kIGxlZnQgc2lkZXMgb2YgdGhlIG91dGxpbmUgZm9sbG93IHRoZSBzYW1lIFNWRyBwYXRoLlxuICAgIGNvbnN0IHBhdGhNaWRkbGUgPSAnYScgKyByYWRpdXMgKyAnLCcgKyByYWRpdXMgKyAnIDAgMCAxICcgKyByYWRpdXMgKyAnLCcgKyByYWRpdXNcbiAgICAgICsgJ3YnICsgKGhlaWdodCAtICgyICogY29ybmVyV2lkdGgpKVxuICAgICAgKyAnYScgKyByYWRpdXMgKyAnLCcgKyByYWRpdXMgKyAnIDAgMCAxICcgKyAtcmFkaXVzICsgJywnICsgcmFkaXVzXG4gICAgICArICdoJyArICgtd2lkdGggKyAoMiAqIGNvcm5lcldpZHRoKSlcbiAgICAgICsgJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgLXJhZGl1cyArICcsJyArIC1yYWRpdXNcbiAgICAgICsgJ3YnICsgKC1oZWlnaHQgKyAoMiAqIGNvcm5lcldpZHRoKSlcbiAgICAgICsgJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgcmFkaXVzICsgJywnICsgLXJhZGl1cztcblxuICAgIGxldCBwYXRoO1xuICAgIGlmICghaXNSdGwpIHtcbiAgICAgIHBhdGggPSAnTScgKyAoY29ybmVyV2lkdGggKyBsZWFkaW5nU3Ryb2tlTGVuZ3RoICsgcGFkZGVkTm90Y2hXaWR0aCkgKyAnLCcgKyAxXG4gICAgICAgICsgJ2gnICsgKHdpZHRoIC0gKDIgKiBjb3JuZXJXaWR0aCkgLSBwYWRkZWROb3RjaFdpZHRoIC0gbGVhZGluZ1N0cm9rZUxlbmd0aClcbiAgICAgICAgKyBwYXRoTWlkZGxlXG4gICAgICAgICsgJ2gnICsgbGVhZGluZ1N0cm9rZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9ICdNJyArICh3aWR0aCAtIGNvcm5lcldpZHRoIC0gbGVhZGluZ1N0cm9rZUxlbmd0aCkgKyAnLCcgKyAxXG4gICAgICAgICsgJ2gnICsgbGVhZGluZ1N0cm9rZUxlbmd0aFxuICAgICAgICArIHBhdGhNaWRkbGVcbiAgICAgICAgKyAnaCcgKyAod2lkdGggLSAoMiAqIGNvcm5lcldpZHRoKSAtIHBhZGRlZE5vdGNoV2lkdGggLSBsZWFkaW5nU3Ryb2tlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE91dGxpbmVQYXRoQXR0cihwYXRoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJpcHBsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBDU1MgdmFyaWFibGVzXG4gKiAtIHBvc2l0aW9uXG4gKiAtIGRpbWVuc2lvbnNcbiAqIC0gc2Nyb2xsIHBvc2l0aW9uXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHVuYm91bmRlZCwgYWN0aXZlIGFuZCBkaXNhYmxlZCBzdGF0ZXNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUFkYXB0ZXIge1xuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzVW5ib3VuZGVkKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlQWN0aXZlKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlRGlzYWJsZWQoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXQgKi9cbiAgY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJOYW1lXG4gICAqIEBwYXJhbSB7P251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAqL1xuICB1cGRhdGVDc3NWYXJpYWJsZSh2YXJOYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVCb3VuZGluZ1JlY3QoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSAqL1xuICBnZXRXaW5kb3dQYWdlT2Zmc2V0KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICAvLyBSaXBwbGUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIFwicm9vdFwiIGNvbXBvbmVudCBpcyByZWFsbHkgYSBcIm1peGluXCIgb2Ygc29ydHMsXG4gIC8vIGdpdmVuIHRoYXQgaXQncyBhbiAndXBncmFkZScgdG8gYW4gZXhpc3RpbmcgY29tcG9uZW50LiBUaGF0IGJlaW5nIHNhaWQgaXQgaXMgdGhlIHJvb3RcbiAgLy8gQ1NTIGNsYXNzIHRoYXQgYWxsIG90aGVyIENTUyBjbGFzc2VzIGRlcml2ZSBmcm9tLlxuICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXG4gIFVOQk9VTkRFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLXVuYm91bmRlZCcsXG4gIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxuICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcbiAgRkdfREVBQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1kZWFjdGl2YXRpb24nLFxufTtcblxuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVkFSX0xFRlQ6ICctLW1kYy1yaXBwbGUtbGVmdCcsXG4gIFZBUl9UT1A6ICctLW1kYy1yaXBwbGUtdG9wJyxcbiAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXG4gIFZBUl9GR19TQ0FMRTogJy0tbWRjLXJpcHBsZS1mZy1zY2FsZScsXG4gIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0JyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9FTkQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCcsXG59O1xuXG5jb25zdCBudW1iZXJzID0ge1xuICBQQURESU5HOiAxMCxcbiAgSU5JVElBTF9PUklHSU5fU0NBTEU6IDAuNixcbiAgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM6IDIyNSwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtdHJhbnNsYXRlLWR1cmF0aW9uIChpLmUuIGFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtZmFkZS1vdXQtZHVyYXRpb24gKGkuZS4gZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgVEFQX0RFTEFZX01TOiAzMDAsIC8vIERlbGF5IGJldHdlZW4gdG91Y2ggYW5kIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgb24gdG91Y2ggZGV2aWNlc1xufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgQ1NTIGN1c3RvbSB2YXJpYWJsZSBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBhcHBseVBhc3NpdmUgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKSB7XG4gIC8vIERldGVjdCB2ZXJzaW9ucyBvZiBFZGdlIHdpdGggYnVnZ3kgdmFyKCkgc3VwcG9ydFxuICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzExNDk1NDQ4L1xuICBjb25zdCBkb2N1bWVudCA9IHdpbmRvd09iai5kb2N1bWVudDtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBub2RlLmNsYXNzTmFtZSA9ICdtZGMtcmlwcGxlLXN1cmZhY2UtLXRlc3QtZWRnZS12YXItYnVnJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAvLyBUaGUgYnVnIGV4aXN0cyBpZiA6OmJlZm9yZSBzdHlsZSBlbmRzIHVwIHByb3BhZ2F0aW5nIHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgLy8gQWRkaXRpb25hbGx5LCBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgbnVsbCBpbiBpZnJhbWVzIHdpdGggZGlzcGxheTogXCJub25lXCIgaW4gRmlyZWZveCxcbiAgLy8gYnV0IEZpcmVmb3ggaXMga25vd24gdG8gc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93T2JqLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGNvbnN0IGhhc1BzZXVkb1ZhckJ1ZyA9IGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BTdHlsZSA9PT0gJ3NvbGlkJztcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIGhhc1BzZXVkb1ZhckJ1Zztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSAhZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcztcbn1cblxuLy9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHtwYXNzaXZlOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBIVE1MRWxlbWVudFByb3RvdHlwZVxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudFByb3RvdHlwZSkge1xuICByZXR1cm4gW1xuICAgICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFFdmVudH0gZXZcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcGFnZU9mZnNldFxuICogQHBhcmFtIHshQ2xpZW50UmVjdH0gY2xpZW50UmVjdFxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKGV2LCBwYWdlT2Zmc2V0LCBjbGllbnRSZWN0KSB7XG4gIGNvbnN0IHt4LCB5fSA9IHBhZ2VPZmZzZXQ7XG4gIGNvbnN0IGRvY3VtZW50WCA9IHggKyBjbGllbnRSZWN0LmxlZnQ7XG4gIGNvbnN0IGRvY3VtZW50WSA9IHkgKyBjbGllbnRSZWN0LnRvcDtcblxuICBsZXQgbm9ybWFsaXplZFg7XG4gIGxldCBub3JtYWxpemVkWTtcbiAgLy8gRGV0ZXJtaW5lIHRvdWNoIHBvaW50IHJlbGF0aXZlIHRvIHRoZSByaXBwbGUgY29udGFpbmVyLlxuICBpZiAoZXYudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9IGVsc2Uge1xuICAgIG5vcm1hbGl6ZWRYID0gZXYucGFnZVggLSBkb2N1bWVudFg7XG4gICAgbm9ybWFsaXplZFkgPSBldi5wYWdlWSAtIGRvY3VtZW50WTtcbiAgfVxuXG4gIHJldHVybiB7eDogbm9ybWFsaXplZFgsIHk6IG5vcm1hbGl6ZWRZfTtcbn1cblxuZXhwb3J0IHtzdXBwb3J0c0Nzc1ZhcmlhYmxlcywgYXBwbHlQYXNzaXZlLCBnZXRNYXRjaGVzUHJvcGVydHksIGdldE5vcm1hbGl6ZWRFdmVudENvb3Jkc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge2dldE5vcm1hbGl6ZWRFdmVudENvb3Jkc30gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBpc0FjdGl2YXRlZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIGFjdGl2YXRpb25FdmVudDogRXZlbnQsXG4gKiAgIGlzUHJvZ3JhbW1hdGljOiAoYm9vbGVhbnx1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgQWN0aXZhdGlvblN0YXRlVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBkZWFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGZvY3VzOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGJsdXI6IChzdHJpbmd8dW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IExpc3RlbmVySW5mb1R5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCFFdmVudCksXG4gKiAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uKCFFdmVudCksXG4gKiAgIGZvY3VzOiBmdW5jdGlvbigpLFxuICogICBibHVyOiBmdW5jdGlvbigpXG4gKiB9fVxuICovXG5sZXQgTGlzdGVuZXJzVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB4OiBudW1iZXIsXG4gKiAgIHk6IG51bWJlclxuICogfX1cbiAqL1xubGV0IFBvaW50VHlwZTtcblxuLy8gQWN0aXZhdGlvbiBldmVudHMgcmVnaXN0ZXJlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIGVhY2ggaW5zdGFuY2UgZm9yIGFjdGl2YXRpb25cbmNvbnN0IEFDVElWQVRJT05fRVZFTlRfVFlQRVMgPSBbJ3RvdWNoc3RhcnQnLCAncG9pbnRlcmRvd24nLCAnbW91c2Vkb3duJywgJ2tleWRvd24nXTtcblxuLy8gRGVhY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIGRvY3VtZW50RWxlbWVudCB3aGVuIGEgcG9pbnRlci1yZWxhdGVkIGRvd24gZXZlbnQgb2NjdXJzXG5jb25zdCBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hlbmQnLCAncG9pbnRlcnVwJywgJ21vdXNldXAnXTtcblxuLy8gVHJhY2tzIGFjdGl2YXRpb25zIHRoYXQgaGF2ZSBvY2N1cnJlZCBvbiB0aGUgY3VycmVudCBmcmFtZSwgdG8gYXZvaWQgc2ltdWx0YW5lb3VzIG5lc3RlZCBhY3RpdmF0aW9uc1xuLyoqIEB0eXBlIHshQXJyYXk8IUV2ZW50VGFyZ2V0Pn0gKi9cbmxldCBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1JpcHBsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSaXBwbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IC8qIGJvb2xlYW4gLSBjYWNoZWQgKi8ge30sXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICgvKiB0YXJnZXQ6ICFFdmVudFRhcmdldCAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIENsaWVudFJlY3QgKi8ge30sXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAvKiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9ICovIHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUgeyFDbGllbnRSZWN0fSAqL1xuICAgIHRoaXMuZnJhbWVfID0gLyoqIEB0eXBlIHshQ2xpZW50UmVjdH0gKi8gKHt3aWR0aDogMCwgaGVpZ2h0OiAwfSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4UmFkaXVzXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuYWN0aXZhdGVfKGUpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuZGVhY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKD9FdmVudD0pfSAqL1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyXyA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICgpID0+IHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpXG4gICAgKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXG4gICAgICAoKSA9PiB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKVxuICAgICk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlcn19ICovXG4gICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ1NjYWxlXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHs/RXZlbnR9ICovXG4gICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIGNvbXB1dGUgdGhpcyBwcm9wZXJ0eSBzbyB0aGF0IHdlIGFyZSBub3QgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWVudFxuICAgKiB1bnRpbCB0aGUgcG9pbnQgaW4gdGltZSB3aGVyZSB0aGUgZm91bmRhdGlvbiByZXF1ZXN0cyBpdC4gVGhpcyBwcmV2ZW50cyBzY2VuYXJpb3Mgd2hlcmVcbiAgICogY2xpZW50LXNpZGUgZmVhdHVyZS1kZXRlY3Rpb24gbWF5IGhhcHBlbiB0b28gZWFybHksIHN1Y2ggYXMgd2hlbiBjb21wb25lbnRzIGFyZSByZW5kZXJlZCBvbiB0aGUgc2VydmVyXG4gICAqIGFuZCB0aGVuIGluaXRpYWxpemVkIGF0IG1vdW50IHRpbWUgb24gdGhlIGNsaWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzU3VwcG9ydGVkXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5icm93c2VyU3VwcG9ydHNDc3NWYXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9XG4gICAqL1xuICBkZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IGZhbHNlLFxuICAgICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiBmYWxzZSxcbiAgICAgIHdhc0VsZW1lbnRNYWRlQWN0aXZlOiBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb25FdmVudDogbnVsbCxcbiAgICAgIGlzUHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWdpc3RlclJvb3RIYW5kbGVyc18oKTtcblxuICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFJPT1QpO1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgICAgIC8vIFVuYm91bmRlZCByaXBwbGVzIG5lZWQgbGF5b3V0IGxvZ2ljIGFwcGxpZWQgaW1tZWRpYXRlbHkgdG8gc2V0IGNvb3JkaW5hdGVzIGZvciBib3RoIHNoYWRlIGFuZCByaXBwbGVcbiAgICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZhdGlvblRpbWVyXykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyXyk7XG4gICAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuICAgICAgY29uc3Qge0ZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG4gICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG5cbiAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhST09UKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoVU5CT1VOREVEKTtcbiAgICAgIHRoaXMucmVtb3ZlQ3NzVmFyc18oKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKGUpIHtcbiAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBkZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbW92ZUNzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtzdHJpbmdzfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4gICAgT2JqZWN0LmtleXMoc3RyaW5ncykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgaWYgKGsuaW5kZXhPZignVkFSXycpID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoc3RyaW5nc1trXSwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjdGl2YXRlXyhlKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgcmVhY3RpbmcgdG8gZm9sbG93LW9uIGV2ZW50cyBmaXJlZCBieSB0b3VjaCBkZXZpY2UgYWZ0ZXIgYW4gYWxyZWFkeS1wcm9jZXNzZWQgdXNlciBpbnRlcmFjdGlvblxuICAgIGNvbnN0IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ID0gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF87XG4gICAgY29uc3QgaXNTYW1lSW50ZXJhY3Rpb24gPSBwcmV2aW91c0FjdGl2YXRpb25FdmVudCAmJiBlICYmIHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50LnR5cGUgIT09IGUudHlwZTtcbiAgICBpZiAoaXNTYW1lSW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQgPSB0cnVlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA9IGUgPT09IG51bGw7XG4gICAgYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudCA9IGU7XG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA/IGZhbHNlIDogKFxuICAgICAgZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICdwb2ludGVyZG93bidcbiAgICApO1xuXG4gICAgY29uc3QgaGFzQWN0aXZhdGVkQ2hpbGQgPVxuICAgICAgZSAmJiBhY3RpdmF0ZWRUYXJnZXRzLmxlbmd0aCA+IDAgJiYgYWN0aXZhdGVkVGFyZ2V0cy5zb21lKCh0YXJnZXQpID0+IHRoaXMuYWRhcHRlcl8uY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpKTtcbiAgICBpZiAoaGFzQWN0aXZhdGVkQ2hpbGQpIHtcbiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlc2V0IGFjdGl2YXRpb24gc3RhdGUsIHdoaWxlIHByZXNlcnZpbmcgbG9naWMgdGhhdCBwcmV2ZW50cyB0b3VjaCBmb2xsb3ctb24gZXZlbnRzXG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlKSB7XG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzLnB1c2goLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChlLnRhcmdldCkpO1xuICAgICAgdGhpcy5yZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKTtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgPSB0aGlzLmNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpO1xuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIFJlc2V0IGFycmF5IG9uIG5leHQgZnJhbWUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgaGFzIGhhZCBhIGNoYW5jZSB0byBidWJibGUgdG8gcHJldmVudCBhbmNlc3RvciByaXBwbGVzXG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlICYmIChlLmtleSA9PT0gJyAnIHx8IGUua2V5Q29kZSA9PT0gMzIpKSB7XG4gICAgICAgIC8vIElmIHNwYWNlIHdhcyBwcmVzc2VkLCB0cnkgYWdhaW4gd2l0aGluIGFuIHJBRiBjYWxsIHRvIGRldGVjdCA6YWN0aXZlLCBiZWNhdXNlIGRpZmZlcmVudCBVQXMgcmVwb3J0XG4gICAgICAgIC8vIGFjdGl2ZSBzdGF0ZXMgaW5jb25zaXN0ZW50bHkgd2hlbiB0aGV5J3JlIGNhbGxlZCB3aXRoaW4gZXZlbnQgaGFuZGxpbmcgY29kZTpcbiAgICAgICAgLy8gLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MzU5NzFcbiAgICAgICAgLy8gLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjkzNzQxXG4gICAgICAgIC8vIFdlIHRyeSBmaXJzdCBvdXRzaWRlIHJBRiB0byBzdXBwb3J0IEVkZ2UsIHdoaWNoIGRvZXMgbm90IGV4aGliaXQgdGhpcyBwcm9ibGVtLCBidXQgd2lsbCBjcmFzaCBpZiBhIENTU1xuICAgICAgICAvLyB2YXJpYWJsZSBpcyBzZXQgd2l0aGluIGEgckFGIGNhbGxiYWNrIGZvciBhIHN1Ym1pdCBidXR0b24gaW50ZXJhY3Rpb24gKCMyMjQxKS5cbiAgICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKTtcbiAgICAgICAgaWYgKGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgLy8gUmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSBpbW1lZGlhdGVseSBpZiBlbGVtZW50IHdhcyBub3QgbWFkZSBhY3RpdmUuXG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLnR5cGUgPT09ICdrZXlkb3duJykgPyB0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZUFjdGl2ZSgpIDogdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYW5pbWF0ZUFjdGl2YXRpb25fKCkge1xuICAgIGNvbnN0IHtWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0RFQUNUSVZBVElPTl9USU1FT1VUX01TfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycztcblxuICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG5cbiAgICBsZXQgdHJhbnNsYXRlU3RhcnQgPSAnJztcbiAgICBsZXQgdHJhbnNsYXRlRW5kID0gJyc7XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgY29uc3Qge3N0YXJ0UG9pbnQsIGVuZFBvaW50fSA9IHRoaXMuZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpO1xuICAgICAgdHJhbnNsYXRlU3RhcnQgPSBgJHtzdGFydFBvaW50Lnh9cHgsICR7c3RhcnRQb2ludC55fXB4YDtcbiAgICAgIHRyYW5zbGF0ZUVuZCA9IGAke2VuZFBvaW50Lnh9cHgsICR7ZW5kUG9pbnQueX1weGA7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCB0cmFuc2xhdGVTdGFydCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX0VORCwgdHJhbnNsYXRlRW5kKTtcbiAgICAvLyBDYW5jZWwgYW55IG9uZ29pbmcgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gYW5pbWF0aW9uc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyk7XG4gICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG5cbiAgICAvLyBGb3JjZSBsYXlvdXQgaW4gb3JkZXIgdG8gcmUtdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXygpLCBERUFDVElWQVRJT05fVElNRU9VVF9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7e3N0YXJ0UG9pbnQ6IFBvaW50VHlwZSwgZW5kUG9pbnQ6IFBvaW50VHlwZX19XG4gICAqL1xuICBnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCkge1xuICAgIGNvbnN0IHthY3RpdmF0aW9uRXZlbnQsIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcn0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG5cbiAgICBsZXQgc3RhcnRQb2ludDtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyKSB7XG4gICAgICBzdGFydFBvaW50ID0gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKFxuICAgICAgICAvKiogQHR5cGUgeyFFdmVudH0gKi8gKGFjdGl2YXRpb25FdmVudCksXG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93UGFnZU9mZnNldCgpLCB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQb2ludCA9IHtcbiAgICAgICAgeDogdGhpcy5mcmFtZV8ud2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLmZyYW1lXy5oZWlnaHQgLyAyLFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2VudGVyIHRoZSBlbGVtZW50IGFyb3VuZCB0aGUgc3RhcnQgcG9pbnQuXG4gICAgc3RhcnRQb2ludCA9IHtcbiAgICAgIHg6IHN0YXJ0UG9pbnQueCAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogc3RhcnRQb2ludC55IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIGNvbnN0IGVuZFBvaW50ID0ge1xuICAgICAgeDogKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6ICh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICByZXR1cm4ge3N0YXJ0UG9pbnQsIGVuZFBvaW50fTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJvdGggd2hlbiBhIHBvaW50aW5nIGRldmljZSBpcyByZWxlYXNlZCwgYW5kIHdoZW4gdGhlIGFjdGl2YXRpb24gYW5pbWF0aW9uIGVuZHMuXG4gICAgLy8gVGhlIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gc2hvdWxkIG9ubHkgcnVuIGFmdGVyIGJvdGggb2YgdGhvc2Ugb2NjdXIuXG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge2hhc0RlYWN0aXZhdGlvblVYUnVuLCBpc0FjdGl2YXRlZH0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgY29uc3QgYWN0aXZhdGlvbkhhc0VuZGVkID0gaGFzRGVhY3RpdmF0aW9uVVhSdW4gfHwgIWlzQWN0aXZhdGVkO1xuXG4gICAgaWYgKGFjdGl2YXRpb25IYXNFbmRlZCAmJiB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8pIHtcbiAgICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB9LCBudW1iZXJzLkZHX0RFQUNUSVZBVElPTl9NUyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpIHtcbiAgICBjb25zdCB7RkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgfVxuXG4gIHJlc2V0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXy5hY3RpdmF0aW9uRXZlbnQ7XG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIC8vIFRvdWNoIGRldmljZXMgbWF5IGZpcmUgYWRkaXRpb25hbCBldmVudHMgZm9yIHRoZSBzYW1lIGludGVyYWN0aW9uIHdpdGhpbiBhIHNob3J0IHRpbWUuXG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzIGV2ZW50IHVudGlsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCBzdWJzZXF1ZW50IGV2ZW50cyBhcmUgZm9yIG5ldyBpbnRlcmFjdGlvbnMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IG51bGwsIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5UQVBfREVMQVlfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWFjdGl2YXRlXyhlKSB7XG4gICAgY29uc3QgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBzY2VuYXJpb3Mgc3VjaCBhcyB3aGVuIHlvdSBoYXZlIGEga2V5dXAgZXZlbnQgdGhhdCBibHVycyB0aGUgZWxlbWVudC5cbiAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gLyoqIEB0eXBlIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gKi8gKE9iamVjdC5hc3NpZ24oe30sIGFjdGl2YXRpb25TdGF0ZSkpO1xuXG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYykge1xuICAgICAgY29uc3QgZXZ0T2JqZWN0ID0gbnVsbDtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKGV2dE9iamVjdCwgc3RhdGUpKTtcbiAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfLmhhc0RlYWN0aXZhdGlvblVYUnVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhlLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMucmVzZXRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZGVhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmRlYWN0aXZhdGVfKGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFuaW1hdGVEZWFjdGl2YXRpb25fKGUsIHt3YXNBY3RpdmF0ZWRCeVBvaW50ZXIsIHdhc0VsZW1lbnRNYWRlQWN0aXZlfSkge1xuICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIgfHwgd2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmxheW91dEZyYW1lXykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZyYW1lXyA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KHRoaXMuZnJhbWVfLmhlaWdodCwgdGhpcy5mcmFtZV8ud2lkdGgpO1xuXG4gICAgLy8gU3VyZmFjZSBkaWFtZXRlciBpcyB0cmVhdGVkIGRpZmZlcmVudGx5IGZvciB1bmJvdW5kZWQgdnMuIGJvdW5kZWQgcmlwcGxlcy5cbiAgICAvLyBVbmJvdW5kZWQgcmlwcGxlIGRpYW1ldGVyIGlzIGNhbGN1bGF0ZWQgc21hbGxlciBzaW5jZSB0aGUgc3VyZmFjZSBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGJlIHBhZGRlZCBhcHByb3ByaWF0ZWx5XG4gICAgLy8gdG8gZXh0ZW5kIHRoZSBoaXRib3gsIGFuZCB0aGUgcmlwcGxlIGlzIGV4cGVjdGVkIHRvIG1lZXQgdGhlIGVkZ2VzIG9mIHRoZSBwYWRkZWQgaGl0Ym94ICh3aGljaCBpcyB0eXBpY2FsbHlcbiAgICAvLyBzcXVhcmUpLiBCb3VuZGVkIHJpcHBsZXMsIG9uIHRoZSBvdGhlciBoYW5kLCBhcmUgZnVsbHkgZXhwZWN0ZWQgdG8gZXhwYW5kIGJleW9uZCB0aGUgc3VyZmFjZSdzIGxvbmdlc3QgZGlhbWV0ZXJcbiAgICAvLyAoY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGlhZ29uYWwgcGx1cyBhIGNvbnN0YW50IHBhZGRpbmcpLCBhbmQgYXJlIGNsaXBwZWQgYXQgdGhlIHN1cmZhY2UncyBib3JkZXIgdmlhXG4gICAgLy8gYG92ZXJmbG93OiBoaWRkZW5gLlxuICAgIGNvbnN0IGdldEJvdW5kZWRSYWRpdXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuZnJhbWVfLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuZnJhbWVfLmhlaWdodCwgMikpO1xuICAgICAgcmV0dXJuIGh5cG90ZW51c2UgKyBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuUEFERElORztcbiAgICB9O1xuXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpID8gbWF4RGltIDogZ2V0Qm91bmRlZFJhZGl1cygpO1xuXG4gICAgLy8gUmlwcGxlIGlzIHNpemVkIGFzIGEgZnJhY3Rpb24gb2YgdGhlIGxhcmdlc3QgZGltZW5zaW9uIG9mIHRoZSBzdXJmYWNlLCB0aGVuIHNjYWxlcyB1cCB1c2luZyBhIENTUyBzY2FsZSB0cmFuc2Zvcm1cbiAgICB0aGlzLmluaXRpYWxTaXplXyA9IG1heERpbSAqIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5JTklUSUFMX09SSUdJTl9TQ0FMRTtcbiAgICB0aGlzLmZnU2NhbGVfID0gdGhpcy5tYXhSYWRpdXNfIC8gdGhpcy5pbml0aWFsU2l6ZV87XG5cbiAgICB0aGlzLnVwZGF0ZUxheW91dENzc1ZhcnNfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdXBkYXRlTGF5b3V0Q3NzVmFyc18oKSB7XG4gICAgY29uc3Qge1xuICAgICAgVkFSX0ZHX1NJWkUsIFZBUl9MRUZULCBWQVJfVE9QLCBWQVJfRkdfU0NBTEUsXG4gICAgfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NJWkUsIGAke3RoaXMuaW5pdGlhbFNpemVffXB4YCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0NBTEUsIHRoaXMuZmdTY2FsZV8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgICB0b3A6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMikpLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfTEVGVCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLmxlZnR9cHhgKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX1RPUCwgYCR7dGhpcy51bmJvdW5kZWRDb29yZHNfLnRvcH1weGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHVuYm91bmRlZCAqL1xuICBzZXRVbmJvdW5kZWQodW5ib3VuZGVkKSB7XG4gICAgY29uc3Qge1VOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHVuYm91bmRlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4iLCJpbXBvcnQgTURDUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMnXG5pbXBvcnQge1xuICBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyxcbiAgZ2V0TWF0Y2hlc1Byb3BlcnR5LFxuICBhcHBseVBhc3NpdmVcbn0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS91dGlsJ1xuXG5leHBvcnQgY2xhc3MgUmlwcGxlQmFzZSBleHRlbmRzIE1EQ1JpcHBsZUZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IE1BVENIRVMoKSB7XG4gICAgLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG4gICAgcmV0dXJuIChcbiAgICAgIFJpcHBsZUJhc2UuX21hdGNoZXMgfHxcbiAgICAgIChSaXBwbGVCYXNlLl9tYXRjaGVzID0gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSkpXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIGlzU3VyZmFjZUFjdGl2ZShyZWYpIHtcbiAgICByZXR1cm4gcmVmW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICB9XG5cbiAgY29uc3RydWN0b3Iodm0sIG9wdGlvbnMpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdm0uJGVsW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2bS5kaXNhYmxlZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2bS4kc2V0KHZtLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdm0uJGRlbGV0ZSh2bS5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiB0YXJnZXQgPT4gdm0uJGVsLmNvbnRhaW5zKHRhcmdldCksXG4gICAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHZtLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB2bS4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgZXZ0VHlwZSxcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBldnRUeXBlLFxuICAgICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgICBhcHBseVBhc3NpdmUoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdm0uJHNldCh2bS5zdHlsZXMsIHZhck5hbWUsIHZhbHVlKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZtLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0V2luZG93UGFnZU9mZnNldDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUmlwcGxlTWl4aW4gPSB7XG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpzdHlsZT1cInt3aWR0aDpmdWxsd2lkdGg/JzEwMCUnOnVuZGVmaW5lZH1cIlxuICAgIDppZD1cImlkXCJcbiAgICBjbGFzcz1cIm1kYy10ZXh0ZmllbGQtd3JhcHBlclwiPlxuXG4gICAgPGRpdlxuICAgICAgcmVmPVwicm9vdFwiXG4gICAgICA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiPlxuXG4gICAgICA8aVxuICAgICAgICB2LWlmPVwiISFoYXNMZWFkaW5nSWNvblwiXG4gICAgICAgIHJlZj1cImljb25cIlxuICAgICAgICA6Y2xhc3M9XCJoYXNMZWFkaW5nSWNvbi5jbGFzc2VzXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtdGV4dC1maWVsZF9faWNvblwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwibGVhZGluZy1pY29uXCI+e3sgaGFzTGVhZGluZ0ljb24uY29udGVudCB9fTwvc2xvdD5cbiAgICAgIDwvaT5cblxuICAgICAgPCEtLSB3b3JrYXJyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JvbGx1cC1wbHVnaW4tdnVlL2lzc3Vlcy8xNzQgLS0+XG4gICAgICA8IS0tIGVzbGludC1kaXNhYmxlIHZ1ZS9odG1sLXNlbGYtY2xvc2luZyAtLT5cbiAgICAgIDx0ZXh0YXJlYVxuICAgICAgICB2LWlmPVwibXVsdGlsaW5lXCJcbiAgICAgICAgcmVmPVwiaW5wdXRcIlxuICAgICAgICB2LWJpbmQ9XCIkYXR0cnNcIlxuICAgICAgICA6aWQ9XCJ2bWFfdWlkX1wiXG4gICAgICAgIDpjbGFzcz1cImlucHV0Q2xhc3Nlc1wiXG4gICAgICAgIDptaW5sZW5ndGg9XCJtaW5sZW5ndGhcIlxuICAgICAgICA6bWF4bGVuZ3RoPVwibWF4bGVuZ3RoXCJcbiAgICAgICAgOnBsYWNlaG9sZGVyPVwiaW5wdXRQbGFjZUhvbGRlclwiXG4gICAgICAgIDphcmlhLWxhYmVsPVwiaW5wdXRQbGFjZUhvbGRlclwiXG4gICAgICAgIDphcmlhLWNvbnRyb2xzPVwiaW5wdXRBcmlhQ29udHJvbHNcIlxuICAgICAgICA6cm93cz1cInJvd3NcIlxuICAgICAgICA6Y29scz1cImNvbHNcIlxuICAgICAgICB2LW9uPVwiJGxpc3RlbmVyc1wiXG4gICAgICAgIEBpbnB1dD1cInVwZGF0ZVZhbHVlKCRldmVudC50YXJnZXQudmFsdWUpXCJcbiAgICAgID48L3RleHRhcmVhPlxuXG4gICAgICA8aW5wdXRcbiAgICAgICAgdi1lbHNlXG4gICAgICAgIHJlZj1cImlucHV0XCJcbiAgICAgICAgdi1iaW5kPVwiJGF0dHJzXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6Y2xhc3M9XCJpbnB1dENsYXNzZXNcIlxuICAgICAgICA6dHlwZT1cInR5cGVcIlxuICAgICAgICA6bWlubGVuZ3RoPVwibWlubGVuZ3RoXCJcbiAgICAgICAgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXG4gICAgICAgIDpwbGFjZWhvbGRlcj1cImlucHV0UGxhY2VIb2xkZXJcIlxuICAgICAgICA6YXJpYS1sYWJlbD1cImlucHV0UGxhY2VIb2xkZXJcIlxuICAgICAgICA6YXJpYS1jb250cm9scz1cImlucHV0QXJpYUNvbnRyb2xzXCJcbiAgICAgICAgdi1vbj1cIiRsaXN0ZW5lcnNcIlxuICAgICAgICBAaW5wdXQ9XCJ1cGRhdGVWYWx1ZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4gICAgICA+XG5cbiAgICAgIDxsYWJlbFxuICAgICAgICB2LWlmPVwiaGFzTGFiZWxcIlxuICAgICAgICByZWY9XCJsYWJlbFwiXG4gICAgICAgIDpjbGFzcz1cImxhYmVsQ2xhc3Nlc1VwZ3JhZGVkXCJcbiAgICAgICAgOmZvcj1cInZtYV91aWRfXCI+XG4gICAgICAgIHt7IGxhYmVsIH19XG4gICAgICA8L2xhYmVsPlxuXG4gICAgICA8aVxuICAgICAgICB2LWlmPVwiISFoYXNUcmFpbGluZ0ljb25cIlxuICAgICAgICByZWY9XCJpY29uXCJcbiAgICAgICAgOmNsYXNzPVwiaGFzVHJhaWxpbmdJY29uLmNsYXNzZXNcIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICBjbGFzcz1cIm1kYy10ZXh0LWZpZWxkX19pY29uXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJ0cmFpbGluZy1pY29uXCI+e3sgaGFzVHJhaWxpbmdJY29uLmNvbnRlbnQgfX08L3Nsb3Q+XG4gICAgICA8L2k+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgdi1pZj1cImhhc091dGxpbmVcIlxuICAgICAgICByZWY9XCJvdXRsaW5lXCJcbiAgICAgICAgOmNsYXNzPVwib3V0bGluZUNsYXNzZXNcIlxuICAgICAgICBjbGFzcz1cIm1kYy1ub3RjaGVkLW91dGxpbmVcIj5cbiAgICAgICAgPHN2Zz5cbiAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgOmQ9XCJvdXRsaW5lUGF0aEF0dHJcIlxuICAgICAgICAgICAgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lX19wYXRoXCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXZcbiAgICAgICAgdi1pZj1cImhhc091dGxpbmVcIlxuICAgICAgICByZWY9XCJvdXRsaW5lSWRsZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZV9faWRsZVwiLz5cbiAgICAgIDxkaXZcbiAgICAgICAgdi1pZj1cImhhc0xpbmVSaXBwbGVcIlxuICAgICAgICByZWY9XCJsaW5lUmlwcGxlXCJcbiAgICAgICAgOmNsYXNzPVwibGluZVJpcHBsZUNsYXNzZXNcIlxuICAgICAgICA6c3R5bGU9XCJsaW5lUmlwcGxlU3R5bGVzXCIvPlxuXG4gICAgPC9kaXY+XG5cbiAgICA8cFxuICAgICAgdi1pZj1cImhlbHB0ZXh0XCJcbiAgICAgIHJlZj1cImhlbHBcIlxuICAgICAgOmlkPVwiJ2hlbHAtJyt2bWFfdWlkX1wiXG4gICAgICA6Y2xhc3M9XCJoZWxwQ2xhc3Nlc1wiXG4gICAgICBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgIHt7IGhlbHB0ZXh0IH19XG4gICAgPC9wPlxuXG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUZXh0ZmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvZm91bmRhdGlvbidcbmltcG9ydCBNRENMaW5lUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbidcbmltcG9ydCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9ub3RjaGVkLW91dGxpbmUvZm91bmRhdGlvbidcblxuaW1wb3J0IHtcbiAgZXh0cmFjdEljb25Qcm9wLFxuICBEaXNwYXRjaEZvY3VzTWl4aW4sXG4gIEN1c3RvbUVsZW1lbnRNaXhpbixcbiAgVk1BVW5pcXVlSWRNaXhpbixcbiAgYXBwbHlQYXNzaXZlXG59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGV4dGZpZWxkJyxcbiAgbWl4aW5zOiBbQ3VzdG9tRWxlbWVudE1peGluLCBEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW5dLFxuICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdtb2RlbCdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICd0ZXh0JyxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBbXG4gICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAnZW1haWwnLFxuICAgICAgICAgICAgJ3NlYXJjaCcsXG4gICAgICAgICAgICAncGFzc3dvcmQnLFxuICAgICAgICAgICAgJ3RlbCcsXG4gICAgICAgICAgICAndXJsJyxcbiAgICAgICAgICAgICdudW1iZXInXG4gICAgICAgICAgXS5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG4gICAgZGVuc2U6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICBoZWxwdGV4dDogU3RyaW5nLFxuICAgIGhlbHB0ZXh0UGVyc2lzdGVudDogQm9vbGVhbixcbiAgICBoZWxwdGV4dFZhbGlkYXRpb246IEJvb2xlYW4sXG4gICAgYm94OiBCb29sZWFuLFxuICAgIG91dGxpbmU6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgcmVxdWlyZWQ6IEJvb2xlYW4sXG4gICAgdmFsaWQ6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXG4gICAgZnVsbHdpZHRoOiBCb29sZWFuLFxuICAgIG11bHRpbGluZTogQm9vbGVhbixcbiAgICBsZWFkaW5nSWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgdHJhaWxpbmdJY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICBzaXplOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDIwIH0sXG4gICAgbWlubGVuZ3RoOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IHVuZGVmaW5lZCB9LFxuICAgIG1heGxlbmd0aDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiB1bmRlZmluZWQgfSxcbiAgICByb3dzOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDggfSxcbiAgICBjb2xzOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDQwIH0sXG4gICAgaWQ6IHsgdHlwZTogU3RyaW5nIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHRoaXMudmFsdWUsXG4gICAgICByb290Q2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRleHRmaWVsZCc6IHRydWUsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZCc6IHRydWUsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tdXBncmFkZWQnOiB0cnVlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tZnVsbHdpZHRoJzogdGhpcy5mdWxsd2lkdGgsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tdGV4dGFyZWEnOiB0aGlzLm11bHRpbGluZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1ib3gnOiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5ib3gsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tb3V0bGluZWQnOiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5vdXRsaW5lXG4gICAgICB9LFxuICAgICAgaW5wdXRDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGV4dC1maWVsZF9faW5wdXQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGFiZWxDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtZmxvYXRpbmctbGFiZWwnOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZVJpcHBsZUNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1saW5lLXJpcHBsZSc6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5lUmlwcGxlU3R5bGVzOiB7fSxcbiAgICAgIGhlbHBDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dCc6IHRydWUsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tcGVyc2lzdGVudCc6IHRoaXMuaGVscHRleHRQZXJzaXN0ZW50LFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJzogdGhpcy5oZWxwdGV4dFZhbGlkYXRpb25cbiAgICAgIH0sXG4gICAgICBvdXRsaW5lQ2xhc3Nlczoge30sXG4gICAgICBvdXRsaW5lUGF0aEF0dHI6IHVuZGVmaW5lZFxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpbnB1dFBsYWNlSG9sZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnVsbHdpZHRoID8gdGhpcy5sYWJlbCA6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgaW5wdXRBcmlhQ29udHJvbHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwID8gJ2hlbHAtJyArIHRoaXMudm1hX3VpZF8gOiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGhhc0xhYmVsKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmZ1bGx3aWR0aCAmJiB0aGlzLmxhYmVsXG4gICAgfSxcbiAgICBoYXNPdXRsaW5lKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmZ1bGx3aWR0aCAmJiB0aGlzLm91dGxpbmVcbiAgICB9LFxuICAgIGhhc0xpbmVSaXBwbGUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzT3V0bGluZSAmJiAhdGhpcy5tdWx0aWxpbmVcbiAgICB9LFxuICAgIGhhc0xlYWRpbmdJY29uKCkge1xuICAgICAgaWYgKFxuICAgICAgICAodGhpcy5sZWFkaW5nSWNvbiB8fCB0aGlzLiRzbG90c1snbGVhZGluZy1pY29uJ10pICYmXG4gICAgICAgICEodGhpcy50cmFpbGluZ0ljb24gfHwgdGhpcy4kc2xvdHNbJ3RyYWlsaW5nLWljb24nXSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWFkaW5nSWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLmxlYWRpbmdJY29uKSA6IHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9LFxuICAgIGhhc1RyYWlsaW5nSWNvbigpIHtcbiAgICAgIGlmICh0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLiRzbG90c1sndHJhaWxpbmctaWNvbiddKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWlsaW5nSWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLnRyYWlsaW5nSWNvbikgOiB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSxcbiAgICBsYWJlbENsYXNzZXNVcGdyYWRlZCgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMubGFiZWxDbGFzc2VzLCB7XG4gICAgICAgICdtZGMtZmxvYXRpbmctbGFiZWwtLWZsb2F0LWFib3ZlJzogdGhpcy52YWx1ZVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgZGlzYWJsZWQoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgfSxcbiAgICByZXF1aXJlZCgpIHtcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgKHRoaXMuJHJlZnMuaW5wdXQucmVxdWlyZWQgPSB0aGlzLnJlcXVpcmVkKVxuICAgIH0sXG4gICAgdmFsaWQoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudmFsaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0VmFsaWQodGhpcy52YWxpZClcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbnNlKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnLCB0aGlzLmRlbnNlKVxuICAgIH0sXG4gICAgaGVscHRleHRQZXJzaXN0ZW50KCkge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbiAmJlxuICAgICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLnNldFBlcnNpc3RlbnQodGhpcy5oZWxwdGV4dFBlcnNpc3RlbnQpXG4gICAgfSxcbiAgICBoZWxwdGV4dFZhbGlkYXRpb24oKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uICYmXG4gICAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uc2V0VmFsaWRhdGlvbih0aGlzLmhlbHB0ZXh0VmFsaWRhdGlvbilcbiAgICB9LFxuICAgIHZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5mb3VuZGF0aW9uKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmFsdWUodmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMuJHJlZnMubGluZVJpcHBsZSkge1xuICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbiA9IG5ldyBNRENMaW5lUmlwcGxlRm91bmRhdGlvbih7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmxpbmVSaXBwbGVDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxpbmVSaXBwbGVDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGluZVJpcHBsZS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZTogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMubGluZVJpcHBsZVN0eWxlcywgbmFtZSwgdmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGluZVJpcHBsZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5saW5lUmlwcGxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJHJlZnMuaGVscCkge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbiA9IG5ldyBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbih7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmhlbHBDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmhlbHBDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmhlbHAuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5oZWxwLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQXR0cjogbmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5oZWxwLnJlbW92ZUF0dHJpYnV0ZShuYW1lKVxuICAgICAgICB9LFxuICAgICAgICBzZXRDb250ZW50OiAoLypjb250ZW50Ki8pID0+IHtcbiAgICAgICAgICAvLyBoZWxwIHRleHQgZ2V0J3MgdXBkYXRlZCBmcm9tIHt7aGVscHRleHR9fVxuICAgICAgICAgIC8vIHRoaXMuJHJlZnMuaGVscC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLmluaXQoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiRyZWZzLmljb24pIHtcbiAgICAgIGlmICh0aGlzLmhhc0xlYWRpbmdJY29uKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCAnbWRjLXRleHQtZmllbGQtLXdpdGgtbGVhZGluZy1pY29uJywgdHJ1ZSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNUcmFpbGluZ0ljb24pIHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0td2l0aC10cmFpbGluZy1pY29uJywgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5pY29uRm91bmRhdGlvbiA9IG5ldyBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbih7XG4gICAgICAgIHNldEF0dHI6IChhdHRyLCB2YWx1ZSkgPT4gdGhpcy4kcmVmcy5pY29uLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSksXG4gICAgICAgIGdldEF0dHI6IGF0dHIgPT4gdGhpcy4kcmVmcy5pY29uLmdldEF0dHJpYnV0ZShhdHRyKSxcbiAgICAgICAgcmVtb3ZlQXR0cjogYXR0ciA9PiB0aGlzLiRyZWZzLmljb24ucmVtb3ZlQXR0cmlidXRlKGF0dHIpLFxuICAgICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmljb24uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaWNvbi5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmeUljb25BY3Rpb246ICgpID0+IHRoaXMuJGVtaXQoJ2ljb24tYWN0aW9uJylcbiAgICAgIH0pXG4gICAgICB0aGlzLmljb25Gb3VuZGF0aW9uLmluaXQoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiRyZWZzLmxhYmVsKSB7XG4gICAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiA9IG5ldyBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbih7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMubGFiZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJHJlZnMub3V0bGluZSkge1xuICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiA9IG5ldyBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24oe1xuICAgICAgICBnZXRXaWR0aDogKCkgPT4gdGhpcy4kcmVmcy5vdXRsaW5lLm9mZnNldFdpZHRoLFxuICAgICAgICBnZXRIZWlnaHQ6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLm91dGxpbmVDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLm91dGxpbmVDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldE91dGxpbmVQYXRoQXR0cjogdmFsdWUgPT4ge1xuICAgICAgICAgIHRoaXMub3V0bGluZVBhdGhBdHRyID0gdmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlOiBwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkbGVPdXRsaW5lRWxlbWVudCA9IHRoaXMuJHJlZnMub3V0bGluZUlkbGVcbiAgICAgICAgICBpZiAoaWRsZU91dGxpbmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93XG4gICAgICAgICAgICAgIC5nZXRDb21wdXRlZFN0eWxlKGlkbGVPdXRsaW5lRWxlbWVudClcbiAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRmaWVsZEZvdW5kYXRpb24oXG4gICAgICB7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGlzRm9jdXNlZDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRyZWZzLmlucHV0XG4gICAgICAgIH0sXG4gICAgICAgIGlzUnRsOiAoKSA9PlxuICAgICAgICAgIHdpbmRvd1xuICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5yb290KVxuICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgICAgZGVhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5kZWFjdGl2YXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2YXRlTGluZVJpcHBsZTogKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmFjdGl2YXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW46IG5vcm1hbGl6ZWRYID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5zZXRSaXBwbGVDZW50ZXIobm9ybWFsaXplZFgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgICAgfSxcbiAgICAgICAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVyKVxuICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLiRyZWZzLmlucHV0XG4gICAgICAgICAgY29uc3QgY29uZmlnID0geyBhdHRyaWJ1dGVzOiB0cnVlIH1cbiAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldE5vZGUsIGNvbmZpZylcbiAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXJcbiAgICAgICAgfSxcbiAgICAgICAgZGVyZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiBvYnNlcnZlciA9PiB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYWtlTGFiZWw6IHNob3VsZFNoYWtlID0+IHtcbiAgICAgICAgICB0aGlzLmxhYmVsRm91bmRhdGlvbi5zaGFrZShzaG91bGRTaGFrZSlcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRMYWJlbDogc2hvdWxkRmxvYXQgPT4ge1xuICAgICAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLmZsb2F0KHNob3VsZEZsb2F0KVxuICAgICAgICB9LFxuICAgICAgICBoYXNMYWJlbDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMubGFiZWxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGFiZWxXaWR0aDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsRm91bmRhdGlvbi5nZXRXaWR0aCgpXG4gICAgICAgIH0sXG4gICAgICAgIGdldE5hdGl2ZUlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuaW5wdXRcbiAgICAgICAgfSxcbiAgICAgICAgaGFzT3V0bGluZTogKCkgPT4gISF0aGlzLmhhc091dGxpbmUsXG4gICAgICAgIG5vdGNoT3V0bGluZTogKG5vdGNoV2lkdGgsIGlzUnRsKSA9PlxuICAgICAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24ubm90Y2gobm90Y2hXaWR0aCwgaXNSdGwpLFxuICAgICAgICBjbG9zZU91dGxpbmU6ICgpID0+IHRoaXMub3V0bGluZUZvdW5kYXRpb24uY2xvc2VOb3RjaCgpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBoZWxwZXJUZXh0OiB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLFxuICAgICAgICBpY29uOiB0aGlzLmljb25Gb3VuZGF0aW9uXG4gICAgICB9XG4gICAgKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgKHRoaXMuJHJlZnMuaW5wdXQucmVxdWlyZWQgPSB0aGlzLnJlcXVpcmVkKVxuICAgIGlmICh0eXBlb2YgdGhpcy52YWxpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWxpZCh0aGlzLnZhbGlkKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRleHRib3gpIHtcbiAgICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24gJiYgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uICYmIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5pY29uRm91bmRhdGlvbiAmJiB0aGlzLmljb25Gb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uICYmIHRoaXMubGFiZWxGb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24gJiYgdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLiRlbWl0KCdtb2RlbCcsIHZhbHVlKVxuICAgIH0sXG4gICAgZm9jdXMoKSB7XG4gICAgICB0aGlzLiRyZWZzLmlucHV0ICYmIHRoaXMuJHJlZnMuaW5wdXQuZm9jdXMoKVxuICAgIH0sXG4gICAgYmx1cigpIHtcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5ibHVyKClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVGV4dEZpZWxkIGZyb20gJy4vbWRjLXRleHRmaWVsZC52dWUnXG5cbmV4cG9ydCB7IG1kY1RleHRGaWVsZCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUZXh0RmllbGRcbn0pXG4iLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnXG5pbXBvcnQgeyBhdXRvSW5pdCB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgcGx1Z2luIGZyb20gJy4vaW5kZXguanMnXG5leHBvcnQgZGVmYXVsdCBwbHVnaW5cblxuYXV0b0luaXQocGx1Z2luKVxuIl0sIm5hbWVzIjpbInN1cHBvcnRzUGFzc2l2ZV8iLCJhcHBseVBhc3NpdmUiLCJnbG9iYWxPYmoiLCJ3aW5kb3ciLCJmb3JjZVJlZnJlc2giLCJ1bmRlZmluZWQiLCJpc1N1cHBvcnRlZCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJlIiwiYXV0b0luaXQiLCJwbHVnaW4iLCJfVnVlIiwiVnVlIiwiZ2xvYmFsIiwidXNlIiwiQmFzZVBsdWdpbiIsImNvbXBvbmVudHMiLCJ2ZXJzaW9uIiwiaW5zdGFsbCIsImtleSIsImNvbXBvbmVudCIsInZtIiwibmFtZSIsIkN1c3RvbUVsZW1lbnQiLCJmdW5jdGlvbmFsIiwicmVuZGVyIiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHQiLCJwcm9wcyIsImlzIiwidGFnIiwiZGF0YSIsImNoaWxkcmVuIiwiQ3VzdG9tRWxlbWVudE1peGluIiwiZXh0cmFjdEljb25Qcm9wIiwiaWNvblByb3AiLCJjbGFzc2VzIiwiY29udGVudCIsIkFycmF5IiwicmVkdWNlIiwicmVzdWx0IiwidmFsdWUiLCJiYWJlbEhlbHBlcnMuZXh0ZW5kcyIsImNsYXNzTmFtZSIsInNwbGl0IiwidGV4dENvbnRlbnQiLCJEaXNwYXRjaEZvY3VzTWl4aW4iLCJoYXNGb2N1cyIsIm1ldGhvZHMiLCJvbk1vdXNlRG93biIsIl9hY3RpdmUiLCJvbk1vdXNlVXAiLCJvbkZvY3VzRXZlbnQiLCJzZXRUaW1lb3V0IiwiZGlzcGF0Y2hGb2N1c0V2ZW50Iiwib25CbHVyRXZlbnQiLCIkZWwiLCJhY3RpdmVFbGVtZW50IiwiY29udGFpbnMiLCIkZW1pdCIsIm1vdW50ZWQiLCJiZWZvcmVEZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVpZF8iLCJWTUFVbmlxdWVJZE1peGluIiwiYmVmb3JlQ3JlYXRlIiwidm1hX3VpZF8iLCJNRENGb3VuZGF0aW9uIiwiYWRhcHRlciIsImFkYXB0ZXJfIiwiTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIiLCJhdHRyIiwic3RyaW5ncyIsIkFSSUFfSElEREVOIiwiUk9MRSIsImNzc0NsYXNzZXMiLCJIRUxQRVJfVEVYVF9QRVJTSVNURU5UIiwiSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0ciLCJNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJoYXNDbGFzcyIsInNldEF0dHIiLCJyZW1vdmVBdHRyIiwic2V0Q29udGVudCIsImRlZmF1bHRBZGFwdGVyIiwiaXNQZXJzaXN0ZW50IiwiaXNWYWxpZGF0aW9uIiwiaW5wdXRJc1ZhbGlkIiwiaGVscGVyVGV4dElzUGVyc2lzdGVudCIsImhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2ciLCJ2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5IiwiaGlkZV8iLCJNRENUZXh0RmllbGRJY29uQWRhcHRlciIsImV2dFR5cGUiLCJoYW5kbGVyIiwiSUNPTl9FVkVOVCIsIklDT05fUk9MRSIsIk1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIiwiZ2V0QXR0ciIsInJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlciIsIm5vdGlmeUljb25BY3Rpb24iLCJzYXZlZFRhYkluZGV4XyIsImludGVyYWN0aW9uSGFuZGxlcl8iLCJldnQiLCJoYW5kbGVJbnRlcmFjdGlvbiIsImZvckVhY2giLCJkaXNhYmxlZCIsInR5cGUiLCJrZXlDb2RlIiwiTURDVGV4dEZpZWxkQWRhcHRlciIsIm9ic2VydmVyIiwibm9ybWFsaXplZFgiLCJzaG91bGRTaGFrZSIsInNob3VsZEZsb2F0IiwibGFiZWxXaWR0aCIsImlzUnRsIiwiQVJJQV9DT05UUk9MUyIsIklOUFVUX1NFTEVDVE9SIiwiTEFCRUxfU0VMRUNUT1IiLCJJQ09OX1NFTEVDVE9SIiwiT1VUTElORV9TRUxFQ1RPUiIsIkxJTkVfUklQUExFX1NFTEVDVE9SIiwiUk9PVCIsIlVQR1JBREVEIiwiRElTQUJMRUQiLCJERU5TRSIsIkZPQ1VTRUQiLCJJTlZBTElEIiwiQk9YIiwiT1VUTElORUQiLCJudW1iZXJzIiwiTEFCRUxfU0NBTEUiLCJERU5TRV9MQUJFTF9TQ0FMRSIsIlZBTElEQVRJT05fQVRUUl9XSElURUxJU1QiLCJNRENUZXh0RmllbGRGb3VuZGF0aW9uIiwiaXNWYWxpZCIsImlzRm9jdXNlZF8iLCJpc0JhZElucHV0XyIsImdldFZhbHVlIiwicmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIiLCJkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIiLCJnZXROYXRpdmVJbnB1dCIsImlzRm9jdXNlZCIsImFjdGl2YXRlTGluZVJpcHBsZSIsImRlYWN0aXZhdGVMaW5lUmlwcGxlIiwic2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbiIsInNoYWtlTGFiZWwiLCJmbG9hdExhYmVsIiwiaGFzTGFiZWwiLCJnZXRMYWJlbFdpZHRoIiwiaGFzT3V0bGluZSIsIm5vdGNoT3V0bGluZSIsImNsb3NlT3V0bGluZSIsImZvdW5kYXRpb25NYXAiLCJoZWxwZXJUZXh0XyIsImhlbHBlclRleHQiLCJpY29uXyIsImljb24iLCJyZWNlaXZlZFVzZXJJbnB1dF8iLCJ1c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nXyIsImlzVmFsaWRfIiwiaW5wdXRGb2N1c0hhbmRsZXJfIiwiYWN0aXZhdGVGb2N1cyIsImlucHV0Qmx1ckhhbmRsZXJfIiwiZGVhY3RpdmF0ZUZvY3VzIiwiaW5wdXRJbnB1dEhhbmRsZXJfIiwiYXV0b0NvbXBsZXRlRm9jdXMiLCJzZXRQb2ludGVyWE9mZnNldF8iLCJzZXRUcmFuc2Zvcm1PcmlnaW4iLCJ0ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfIiwiaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24iLCJ2YWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcl8iLCJtdXRhdGlvbnMiLCJoYW5kbGVWYWxpZGF0aW9uQXR0cmlidXRlTXV0YXRpb24iLCJ2YWxpZGF0aW9uT2JzZXJ2ZXJfIiwibXV0YXRpb25zTGlzdCIsInNvbWUiLCJtdXRhdGlvbiIsImluZGV4T2YiLCJhdHRyaWJ1dGVOYW1lIiwic3R5bGVWYWxpZGl0eV8iLCJvcGVuTm90Y2giLCJpc0RlbnNlIiwibGFiZWxTY2FsZSIsInN0eWxlRm9jdXNlZF8iLCJzaG93VG9TY3JlZW5SZWFkZXIiLCJ0YXJnZXRDbGllbnRSZWN0IiwidGFyZ2V0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZXZ0Q29vcmRzIiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsImxlZnQiLCJpbnB1dCIsImdldE5hdGl2ZUlucHV0XyIsInNob3VsZFJlbW92ZUxhYmVsRmxvYXQiLCJpc05hdGl2ZUlucHV0VmFsaWRfIiwic3R5bGVEaXNhYmxlZF8iLCJ2YWxpZGl0eSIsImJhZElucHV0IiwidmFsaWQiLCJzZXRWYWxpZGl0eSIsImlzRGlzYWJsZWQiLCJzZXREaXNhYmxlZCIsIk1EQ0xpbmVSaXBwbGVBZGFwdGVyIiwicHJvcGVydHlOYW1lIiwiTElORV9SSVBQTEVfQUNUSVZFIiwiTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HIiwiTURDTGluZVJpcHBsZUZvdW5kYXRpb24iLCJzZXRTdHlsZSIsInJlZ2lzdGVyRXZlbnRIYW5kbGVyIiwiZGVyZWdpc3RlckV2ZW50SGFuZGxlciIsInRyYW5zaXRpb25FbmRIYW5kbGVyXyIsImhhbmRsZVRyYW5zaXRpb25FbmQiLCJ4Q29vcmRpbmF0ZSIsImlzRGVhY3RpdmF0aW5nIiwiTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIiLCJMQUJFTF9GTE9BVF9BQk9WRSIsIkxBQkVMX1NIQUtFIiwiTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24iLCJnZXRXaWR0aCIsInNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVTaGFrZUFuaW1hdGlvbkVuZF8iLCJNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXIiLCJQQVRIX1NFTEVDVE9SIiwiSURMRV9PVVRMSU5FX1NFTEVDVE9SIiwiT1VUTElORV9OT1RDSEVEIiwiTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uIiwiZ2V0SGVpZ2h0Iiwic2V0T3V0bGluZVBhdGhBdHRyIiwiZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlIiwibm90Y2hXaWR0aCIsInVwZGF0ZVN2Z1BhdGhfIiwicmFkaXVzU3R5bGVWYWx1ZSIsInJhZGl1cyIsInBhcnNlRmxvYXQiLCJ3aWR0aCIsImhlaWdodCIsImNvcm5lcldpZHRoIiwibGVhZGluZ1N0cm9rZUxlbmd0aCIsIk1hdGgiLCJhYnMiLCJwYWRkZWROb3RjaFdpZHRoIiwicGF0aE1pZGRsZSIsInBhdGgiLCJNRENSaXBwbGVBZGFwdGVyIiwidmFyTmFtZSIsIlVOQk9VTkRFRCIsIkJHX0ZPQ1VTRUQiLCJGR19BQ1RJVkFUSU9OIiwiRkdfREVBQ1RJVkFUSU9OIiwiVkFSX0xFRlQiLCJWQVJfVE9QIiwiVkFSX0ZHX1NJWkUiLCJWQVJfRkdfU0NBTEUiLCJWQVJfRkdfVFJBTlNMQVRFX1NUQVJUIiwiVkFSX0ZHX1RSQU5TTEFURV9FTkQiLCJQQURESU5HIiwiSU5JVElBTF9PUklHSU5fU0NBTEUiLCJERUFDVElWQVRJT05fVElNRU9VVF9NUyIsIkZHX0RFQUNUSVZBVElPTl9NUyIsIlRBUF9ERUxBWV9NUyIsInN1cHBvcnRzQ3NzVmFyaWFibGVzXyIsImRldGVjdEVkZ2VQc2V1ZG9WYXJCdWciLCJ3aW5kb3dPYmoiLCJub2RlIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY29tcHV0ZWRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJoYXNQc2V1ZG9WYXJCdWciLCJib3JkZXJUb3BTdHlsZSIsInJlbW92ZSIsInN1cHBvcnRzQ3NzVmFyaWFibGVzIiwic3VwcG9ydHNGdW5jdGlvblByZXNlbnQiLCJDU1MiLCJzdXBwb3J0cyIsImV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMiLCJ3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMiLCJnZXRNYXRjaGVzUHJvcGVydHkiLCJIVE1MRWxlbWVudFByb3RvdHlwZSIsImZpbHRlciIsInAiLCJwb3AiLCJnZXROb3JtYWxpemVkRXZlbnRDb29yZHMiLCJldiIsInBhZ2VPZmZzZXQiLCJjbGllbnRSZWN0IiwiZG9jdW1lbnRYIiwiZG9jdW1lbnRZIiwidG9wIiwibm9ybWFsaXplZFkiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMiLCJhY3RpdmF0ZWRUYXJnZXRzIiwiTURDUmlwcGxlRm91bmRhdGlvbiIsImJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMiLCJpc1VuYm91bmRlZCIsImlzU3VyZmFjZUFjdGl2ZSIsImlzU3VyZmFjZURpc2FibGVkIiwiY29udGFpbnNFdmVudFRhcmdldCIsInJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlclJlc2l6ZUhhbmRsZXIiLCJkZXJlZ2lzdGVyUmVzaXplSGFuZGxlciIsInVwZGF0ZUNzc1ZhcmlhYmxlIiwiY29tcHV0ZUJvdW5kaW5nUmVjdCIsImdldFdpbmRvd1BhZ2VPZmZzZXQiLCJsYXlvdXRGcmFtZV8iLCJmcmFtZV8iLCJhY3RpdmF0aW9uU3RhdGVfIiwiZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8iLCJpbml0aWFsU2l6ZV8iLCJtYXhSYWRpdXNfIiwiYWN0aXZhdGVIYW5kbGVyXyIsImFjdGl2YXRlXyIsImRlYWN0aXZhdGVIYW5kbGVyXyIsImRlYWN0aXZhdGVfIiwiZm9jdXNIYW5kbGVyXyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJsdXJIYW5kbGVyXyIsInJlc2l6ZUhhbmRsZXJfIiwibGF5b3V0IiwidW5ib3VuZGVkQ29vcmRzXyIsImZnU2NhbGVfIiwiYWN0aXZhdGlvblRpbWVyXyIsImZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyIsImFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8iLCJhY3RpdmF0aW9uVGltZXJDYWxsYmFja18iLCJydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8iLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudF8iLCJpc0FjdGl2YXRlZCIsImhhc0RlYWN0aXZhdGlvblVYUnVuIiwid2FzQWN0aXZhdGVkQnlQb2ludGVyIiwid2FzRWxlbWVudE1hZGVBY3RpdmUiLCJhY3RpdmF0aW9uRXZlbnQiLCJpc1Byb2dyYW1tYXRpYyIsImlzU3VwcG9ydGVkXyIsInJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsImxheW91dEludGVybmFsXyIsImNsZWFyVGltZW91dCIsImRlcmVnaXN0ZXJSb290SGFuZGxlcnNfIiwiZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyIsInJlbW92ZUNzc1ZhcnNfIiwiT2JqZWN0Iiwia2V5cyIsImsiLCJhY3RpdmF0aW9uU3RhdGUiLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudCIsImlzU2FtZUludGVyYWN0aW9uIiwiaGFzQWN0aXZhdGVkQ2hpbGQiLCJsZW5ndGgiLCJyZXNldEFjdGl2YXRpb25TdGF0ZV8iLCJwdXNoIiwicmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18iLCJjaGVja0VsZW1lbnRNYWRlQWN0aXZlXyIsImFuaW1hdGVBY3RpdmF0aW9uXyIsImV2ZW50IiwidHJhbnNsYXRlU3RhcnQiLCJ0cmFuc2xhdGVFbmQiLCJnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfIiwic3RhcnRQb2ludCIsImVuZFBvaW50Iiwicm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfIiwiYWN0aXZhdGlvbkhhc0VuZGVkIiwic3RhdGUiLCJldnRPYmplY3QiLCJhbmltYXRlRGVhY3RpdmF0aW9uXyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwibWF4RGltIiwibWF4IiwiZ2V0Qm91bmRlZFJhZGl1cyIsImh5cG90ZW51c2UiLCJzcXJ0IiwicG93IiwidXBkYXRlTGF5b3V0Q3NzVmFyc18iLCJyb3VuZCIsInVuYm91bmRlZCIsIlJpcHBsZUJhc2UiLCJyZWYiLCJNQVRDSEVTIiwiX21hdGNoZXMiLCJIVE1MRWxlbWVudCIsInByb3RvdHlwZSIsIm9wdGlvbnMiLCIkc2V0IiwiJGRlbGV0ZSIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlcyIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJtaXhpbnMiLCJpbmhlcml0QXR0cnMiLCJtb2RlbCIsInByb3AiLCJTdHJpbmciLCJkZWZhdWx0IiwidmFsaWRhdG9yIiwiZGVuc2UiLCJCb29sZWFuIiwibGFiZWwiLCJoZWxwdGV4dCIsImhlbHB0ZXh0UGVyc2lzdGVudCIsImhlbHB0ZXh0VmFsaWRhdGlvbiIsImJveCIsIm91dGxpbmUiLCJyZXF1aXJlZCIsImZ1bGx3aWR0aCIsIm11bHRpbGluZSIsImxlYWRpbmdJY29uIiwidHJhaWxpbmdJY29uIiwic2l6ZSIsIk51bWJlciIsIm1pbmxlbmd0aCIsIm1heGxlbmd0aCIsInJvd3MiLCJjb2xzIiwiaWQiLCJ0ZXh0Iiwicm9vdENsYXNzZXMiLCJpbnB1dENsYXNzZXMiLCJsYWJlbENsYXNzZXMiLCJsaW5lUmlwcGxlQ2xhc3NlcyIsImxpbmVSaXBwbGVTdHlsZXMiLCJoZWxwQ2xhc3NlcyIsIm91dGxpbmVDbGFzc2VzIiwib3V0bGluZVBhdGhBdHRyIiwiY29tcHV0ZWQiLCJpbnB1dFBsYWNlSG9sZGVyIiwiaW5wdXRBcmlhQ29udHJvbHMiLCJoZWxwIiwiaGFzTGluZVJpcHBsZSIsImhhc0xlYWRpbmdJY29uIiwiJHNsb3RzIiwiaGFzVHJhaWxpbmdJY29uIiwibGFiZWxDbGFzc2VzVXBncmFkZWQiLCJ3YXRjaCIsImZvdW5kYXRpb24iLCIkcmVmcyIsInNldFZhbGlkIiwiaGVscGVyVGV4dEZvdW5kYXRpb24iLCJzZXRQZXJzaXN0ZW50Iiwic2V0VmFsaWRhdGlvbiIsInNldFZhbHVlIiwibGluZVJpcHBsZSIsImxpbmVSaXBwbGVGb3VuZGF0aW9uIiwiY2xhc3NMaXN0IiwiaW5pdCIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImljb25Gb3VuZGF0aW9uIiwiZ2V0QXR0cmlidXRlIiwibGFiZWxGb3VuZGF0aW9uIiwib2Zmc2V0V2lkdGgiLCJvdXRsaW5lRm91bmRhdGlvbiIsIm9mZnNldEhlaWdodCIsImlkbGVPdXRsaW5lRWxlbWVudCIsIm91dGxpbmVJZGxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIk1EQ1RleHRmaWVsZEZvdW5kYXRpb24iLCJyb290IiwiZGVhY3RpdmF0ZSIsImFjdGl2YXRlIiwic2V0UmlwcGxlQ2VudGVyIiwiTXV0YXRpb25PYnNlcnZlciIsInRhcmdldE5vZGUiLCJjb25maWciLCJhdHRyaWJ1dGVzIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJzaGFrZSIsImZsb2F0Iiwibm90Y2giLCJjbG9zZU5vdGNoIiwidGV4dGJveCIsInJpcHBsZSIsImRlc3Ryb3kiLCJ1cGRhdGVWYWx1ZSIsImZvY3VzIiwiYmx1ciIsIm1kY1RleHRGaWVsZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQUFBLElBQUlBLHlCQUFKOztJQUVBOzs7Ozs7QUFNQSxJQUFPLFNBQVNDLFlBQVQsR0FBZ0U7SUFBQSxNQUExQ0MsU0FBMEMsdUVBQTlCQyxNQUE4QjtJQUFBLE1BQXRCQyxZQUFzQix1RUFBUCxLQUFPOztJQUNyRSxNQUFJSixxQkFBcUJLLFNBQXJCLElBQWtDRCxZQUF0QyxFQUFvRDtJQUNsRCxRQUFJRSxjQUFjLEtBQWxCO0lBQ0EsUUFBSTtJQUNGSixnQkFBVUssUUFBVixDQUFtQkMsZ0JBQW5CLENBQW9DLE1BQXBDLEVBQTRDLElBQTVDLEVBQWtEO0lBQ2hELFlBQUlDLE9BQUosR0FBYztJQUNaSCx3QkFBYyxFQUFFRyxTQUFTLElBQVgsRUFBZDtJQUNEO0lBSCtDLE9BQWxEO0lBS0QsS0FORCxDQU1FLE9BQU9DLENBQVAsRUFBVTtJQUNWO0lBQ0Q7O0lBRURWLHVCQUFtQk0sV0FBbkI7SUFDRDs7SUFFRCxTQUFPTixnQkFBUDtJQUNEOztJQ3pCTSxTQUFTVyxRQUFULENBQWtCQyxNQUFsQixFQUEwQjtJQUMvQjtJQUNBLE1BQUlDLE9BQU8sSUFB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
